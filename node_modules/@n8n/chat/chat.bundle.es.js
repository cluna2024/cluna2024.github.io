function ds(t, e) {
  const n = /* @__PURE__ */ Object.create(null), r = t.split(",");
  for (let s = 0; s < r.length; s++)
    n[r[s]] = !0;
  return e ? (s) => !!n[s.toLowerCase()] : (s) => !!n[s];
}
const ue = {}, Pt = [], Ue = () => {
}, vl = () => !1, xl = /^on[^a-z]/, or = (t) => xl.test(t), gs = (t) => t.startsWith("onUpdate:"), me = Object.assign, ms = (t, e) => {
  const n = t.indexOf(e);
  n > -1 && t.splice(n, 1);
}, yl = Object.prototype.hasOwnProperty, se = (t, e) => yl.call(t, e), G = Array.isArray, Bt = (t) => cr(t) === "[object Map]", Rc = (t) => cr(t) === "[object Set]", ee = (t) => typeof t == "function", _e = (t) => typeof t == "string", _s = (t) => typeof t == "symbol", fe = (t) => t !== null && typeof t == "object", qc = (t) => fe(t) && ee(t.then) && ee(t.catch), Mc = Object.prototype.toString, cr = (t) => Mc.call(t), kl = (t) => cr(t).slice(8, -1), Nc = (t) => cr(t) === "[object Object]", bs = (t) => _e(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, Hn = /* @__PURE__ */ ds(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), ir = (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (n) => e[n] || (e[n] = t(n));
}, El = /-(\w)/g, Vt = ir((t) => t.replace(El, (e, n) => n ? n.toUpperCase() : "")), wl = /\B([A-Z])/g, qt = ir(
  (t) => t.replace(wl, "-$1").toLowerCase()
), Ic = ir(
  (t) => t.charAt(0).toUpperCase() + t.slice(1)
), Sr = ir(
  (t) => t ? `on${Ic(t)}` : ""
), bn = (t, e) => !Object.is(t, e), jn = (t, e) => {
  for (let n = 0; n < t.length; n++)
    t[n](e);
}, Gn = (t, e, n) => {
  Object.defineProperty(t, e, {
    configurable: !0,
    enumerable: !1,
    value: n
  });
}, Xr = (t) => {
  const e = parseFloat(t);
  return isNaN(e) ? t : e;
}, Cl = (t) => {
  const e = _e(t) ? Number(t) : NaN;
  return isNaN(e) ? t : e;
};
let Xs;
const Qr = () => Xs || (Xs = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function vs(t) {
  if (G(t)) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
      const r = t[n], s = _e(r) ? Tl(r) : vs(r);
      if (s)
        for (const o in s)
          e[o] = s[o];
    }
    return e;
  } else {
    if (_e(t))
      return t;
    if (fe(t))
      return t;
  }
}
const Al = /;(?![^(]*\))/g, Sl = /:([^]+)/, Dl = /\/\*[^]*?\*\//g;
function Tl(t) {
  const e = {};
  return t.replace(Dl, "").split(Al).forEach((n) => {
    if (n) {
      const r = n.split(Sl);
      r.length > 1 && (e[r[0].trim()] = r[1].trim());
    }
  }), e;
}
function Sn(t) {
  let e = "";
  if (_e(t))
    e = t;
  else if (G(t))
    for (let n = 0; n < t.length; n++) {
      const r = Sn(t[n]);
      r && (e += r + " ");
    }
  else if (fe(t))
    for (const n in t)
      t[n] && (e += n + " ");
  return e.trim();
}
const Rl = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", ql = /* @__PURE__ */ ds(Rl);
function Fc(t) {
  return !!t || t === "";
}
const Zn = (t) => _e(t) ? t : t == null ? "" : G(t) || fe(t) && (t.toString === Mc || !ee(t.toString)) ? JSON.stringify(t, Lc, 2) : String(t), Lc = (t, e) => e && e.__v_isRef ? Lc(t, e.value) : Bt(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce((n, [r, s]) => (n[`${r} =>`] = s, n), {})
} : Rc(e) ? {
  [`Set(${e.size})`]: [...e.values()]
} : fe(e) && !G(e) && !Nc(e) ? String(e) : e;
let Be;
class Ml {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Be, !e && Be && (this.index = (Be.scopes || (Be.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  run(e) {
    if (this._active) {
      const n = Be;
      try {
        return Be = this, e();
      } finally {
        Be = n;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    Be = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    Be = this.parent;
  }
  stop(e) {
    if (this._active) {
      let n, r;
      for (n = 0, r = this.effects.length; n < r; n++)
        this.effects[n].stop();
      for (n = 0, r = this.cleanups.length; n < r; n++)
        this.cleanups[n]();
      if (this.scopes)
        for (n = 0, r = this.scopes.length; n < r; n++)
          this.scopes[n].stop(!0);
      if (!this.detached && this.parent && !e) {
        const s = this.parent.scopes.pop();
        s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function Nl(t, e = Be) {
  e && e.active && e.effects.push(t);
}
function Il() {
  return Be;
}
const xs = (t) => {
  const e = new Set(t);
  return e.w = 0, e.n = 0, e;
}, Oc = (t) => (t.w & ft) > 0, Pc = (t) => (t.n & ft) > 0, Fl = ({ deps: t }) => {
  if (t.length)
    for (let e = 0; e < t.length; e++)
      t[e].w |= ft;
}, Ll = (t) => {
  const { deps: e } = t;
  if (e.length) {
    let n = 0;
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      Oc(s) && !Pc(s) ? s.delete(t) : e[n++] = s, s.w &= ~ft, s.n &= ~ft;
    }
    e.length = n;
  }
}, Kn = /* @__PURE__ */ new WeakMap();
let un = 0, ft = 1;
const es = 30;
let $e;
const At = Symbol(""), ts = Symbol("");
class ys {
  constructor(e, n = null, r) {
    this.fn = e, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, Nl(this, r);
  }
  run() {
    if (!this.active)
      return this.fn();
    let e = $e, n = lt;
    for (; e; ) {
      if (e === this)
        return;
      e = e.parent;
    }
    try {
      return this.parent = $e, $e = this, lt = !0, ft = 1 << ++un, un <= es ? Fl(this) : Qs(this), this.fn();
    } finally {
      un <= es && Ll(this), ft = 1 << --un, $e = this.parent, lt = n, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    $e === this ? this.deferStop = !0 : this.active && (Qs(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function Qs(t) {
  const { deps: e } = t;
  if (e.length) {
    for (let n = 0; n < e.length; n++)
      e[n].delete(t);
    e.length = 0;
  }
}
let lt = !0;
const Bc = [];
function Jt() {
  Bc.push(lt), lt = !1;
}
function Yt() {
  const t = Bc.pop();
  lt = t === void 0 ? !0 : t;
}
function qe(t, e, n) {
  if (lt && $e) {
    let r = Kn.get(t);
    r || Kn.set(t, r = /* @__PURE__ */ new Map());
    let s = r.get(n);
    s || r.set(n, s = xs()), $c(s);
  }
}
function $c(t, e) {
  let n = !1;
  un <= es ? Pc(t) || (t.n |= ft, n = !Oc(t)) : n = !t.has($e), n && (t.add($e), $e.deps.push(t));
}
function tt(t, e, n, r, s, o) {
  const c = Kn.get(t);
  if (!c)
    return;
  let i = [];
  if (e === "clear")
    i = [...c.values()];
  else if (n === "length" && G(t)) {
    const l = Number(r);
    c.forEach((a, u) => {
      (u === "length" || u >= l) && i.push(a);
    });
  } else
    switch (n !== void 0 && i.push(c.get(n)), e) {
      case "add":
        G(t) ? bs(n) && i.push(c.get("length")) : (i.push(c.get(At)), Bt(t) && i.push(c.get(ts)));
        break;
      case "delete":
        G(t) || (i.push(c.get(At)), Bt(t) && i.push(c.get(ts)));
        break;
      case "set":
        Bt(t) && i.push(c.get(At));
        break;
    }
  if (i.length === 1)
    i[0] && ns(i[0]);
  else {
    const l = [];
    for (const a of i)
      a && l.push(...a);
    ns(xs(l));
  }
}
function ns(t, e) {
  const n = G(t) ? t : [...t];
  for (const r of n)
    r.computed && eo(r);
  for (const r of n)
    r.computed || eo(r);
}
function eo(t, e) {
  (t !== $e || t.allowRecurse) && (t.scheduler ? t.scheduler() : t.run());
}
function Ol(t, e) {
  var n;
  return (n = Kn.get(t)) == null ? void 0 : n.get(e);
}
const Pl = /* @__PURE__ */ ds("__proto__,__v_isRef,__isVue"), zc = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(_s)
), Bl = /* @__PURE__ */ ks(), $l = /* @__PURE__ */ ks(!1, !0), zl = /* @__PURE__ */ ks(!0), to = /* @__PURE__ */ Ul();
function Ul() {
  const t = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
    t[e] = function(...n) {
      const r = ce(this);
      for (let o = 0, c = this.length; o < c; o++)
        qe(r, "get", o + "");
      const s = r[e](...n);
      return s === -1 || s === !1 ? r[e](...n.map(ce)) : s;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
    t[e] = function(...n) {
      Jt();
      const r = ce(this)[e].apply(this, n);
      return Yt(), r;
    };
  }), t;
}
function Hl(t) {
  const e = ce(this);
  return qe(e, "has", t), e.hasOwnProperty(t);
}
function ks(t = !1, e = !1) {
  return function(r, s, o) {
    if (s === "__v_isReactive")
      return !t;
    if (s === "__v_isReadonly")
      return t;
    if (s === "__v_isShallow")
      return e;
    if (s === "__v_raw" && o === (t ? e ? oa : Gc : e ? Vc : jc).get(r))
      return r;
    const c = G(r);
    if (!t) {
      if (c && se(to, s))
        return Reflect.get(to, s, o);
      if (s === "hasOwnProperty")
        return Hl;
    }
    const i = Reflect.get(r, s, o);
    return (_s(s) ? zc.has(s) : Pl(s)) || (t || qe(r, "get", s), e) ? i : ye(i) ? c && bs(s) ? i : i.value : fe(i) ? t ? Zc(i) : Cs(i) : i;
  };
}
const jl = /* @__PURE__ */ Uc(), Vl = /* @__PURE__ */ Uc(!0);
function Uc(t = !1) {
  return function(n, r, s, o) {
    let c = n[r];
    if (Gt(c) && ye(c) && !ye(s))
      return !1;
    if (!t && (!Wn(s) && !Gt(s) && (c = ce(c), s = ce(s)), !G(n) && ye(c) && !ye(s)))
      return c.value = s, !0;
    const i = G(n) && bs(r) ? Number(r) < n.length : se(n, r), l = Reflect.set(n, r, s, o);
    return n === ce(o) && (i ? bn(s, c) && tt(n, "set", r, s) : tt(n, "add", r, s)), l;
  };
}
function Gl(t, e) {
  const n = se(t, e);
  t[e];
  const r = Reflect.deleteProperty(t, e);
  return r && n && tt(t, "delete", e, void 0), r;
}
function Zl(t, e) {
  const n = Reflect.has(t, e);
  return (!_s(e) || !zc.has(e)) && qe(t, "has", e), n;
}
function Kl(t) {
  return qe(t, "iterate", G(t) ? "length" : At), Reflect.ownKeys(t);
}
const Hc = {
  get: Bl,
  set: jl,
  deleteProperty: Gl,
  has: Zl,
  ownKeys: Kl
}, Wl = {
  get: zl,
  set(t, e) {
    return !0;
  },
  deleteProperty(t, e) {
    return !0;
  }
}, Jl = /* @__PURE__ */ me(
  {},
  Hc,
  {
    get: $l,
    set: Vl
  }
), Es = (t) => t, lr = (t) => Reflect.getPrototypeOf(t);
function Mn(t, e, n = !1, r = !1) {
  t = t.__v_raw;
  const s = ce(t), o = ce(e);
  n || (e !== o && qe(s, "get", e), qe(s, "get", o));
  const { has: c } = lr(s), i = r ? Es : n ? Ss : vn;
  if (c.call(s, e))
    return i(t.get(e));
  if (c.call(s, o))
    return i(t.get(o));
  t !== s && t.get(e);
}
function Nn(t, e = !1) {
  const n = this.__v_raw, r = ce(n), s = ce(t);
  return e || (t !== s && qe(r, "has", t), qe(r, "has", s)), t === s ? n.has(t) : n.has(t) || n.has(s);
}
function In(t, e = !1) {
  return t = t.__v_raw, !e && qe(ce(t), "iterate", At), Reflect.get(t, "size", t);
}
function no(t) {
  t = ce(t);
  const e = ce(this);
  return lr(e).has.call(e, t) || (e.add(t), tt(e, "add", t, t)), this;
}
function ro(t, e) {
  e = ce(e);
  const n = ce(this), { has: r, get: s } = lr(n);
  let o = r.call(n, t);
  o || (t = ce(t), o = r.call(n, t));
  const c = s.call(n, t);
  return n.set(t, e), o ? bn(e, c) && tt(n, "set", t, e) : tt(n, "add", t, e), this;
}
function so(t) {
  const e = ce(this), { has: n, get: r } = lr(e);
  let s = n.call(e, t);
  s || (t = ce(t), s = n.call(e, t)), r && r.call(e, t);
  const o = e.delete(t);
  return s && tt(e, "delete", t, void 0), o;
}
function oo() {
  const t = ce(this), e = t.size !== 0, n = t.clear();
  return e && tt(t, "clear", void 0, void 0), n;
}
function Fn(t, e) {
  return function(r, s) {
    const o = this, c = o.__v_raw, i = ce(c), l = e ? Es : t ? Ss : vn;
    return !t && qe(i, "iterate", At), c.forEach((a, u) => r.call(s, l(a), l(u), o));
  };
}
function Ln(t, e, n) {
  return function(...r) {
    const s = this.__v_raw, o = ce(s), c = Bt(o), i = t === "entries" || t === Symbol.iterator && c, l = t === "keys" && c, a = s[t](...r), u = n ? Es : e ? Ss : vn;
    return !e && qe(
      o,
      "iterate",
      l ? ts : At
    ), {
      // iterator protocol
      next() {
        const { value: f, done: p } = a.next();
        return p ? { value: f, done: p } : {
          value: i ? [u(f[0]), u(f[1])] : u(f),
          done: p
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function rt(t) {
  return function(...e) {
    return t === "delete" ? !1 : this;
  };
}
function Yl() {
  const t = {
    get(o) {
      return Mn(this, o);
    },
    get size() {
      return In(this);
    },
    has: Nn,
    add: no,
    set: ro,
    delete: so,
    clear: oo,
    forEach: Fn(!1, !1)
  }, e = {
    get(o) {
      return Mn(this, o, !1, !0);
    },
    get size() {
      return In(this);
    },
    has: Nn,
    add: no,
    set: ro,
    delete: so,
    clear: oo,
    forEach: Fn(!1, !0)
  }, n = {
    get(o) {
      return Mn(this, o, !0);
    },
    get size() {
      return In(this, !0);
    },
    has(o) {
      return Nn.call(this, o, !0);
    },
    add: rt("add"),
    set: rt("set"),
    delete: rt("delete"),
    clear: rt("clear"),
    forEach: Fn(!0, !1)
  }, r = {
    get(o) {
      return Mn(this, o, !0, !0);
    },
    get size() {
      return In(this, !0);
    },
    has(o) {
      return Nn.call(this, o, !0);
    },
    add: rt("add"),
    set: rt("set"),
    delete: rt("delete"),
    clear: rt("clear"),
    forEach: Fn(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((o) => {
    t[o] = Ln(
      o,
      !1,
      !1
    ), n[o] = Ln(
      o,
      !0,
      !1
    ), e[o] = Ln(
      o,
      !1,
      !0
    ), r[o] = Ln(
      o,
      !0,
      !0
    );
  }), [
    t,
    n,
    e,
    r
  ];
}
const [
  Xl,
  Ql,
  ea,
  ta
] = /* @__PURE__ */ Yl();
function ws(t, e) {
  const n = e ? t ? ta : ea : t ? Ql : Xl;
  return (r, s, o) => s === "__v_isReactive" ? !t : s === "__v_isReadonly" ? t : s === "__v_raw" ? r : Reflect.get(
    se(n, s) && s in r ? n : r,
    s,
    o
  );
}
const na = {
  get: /* @__PURE__ */ ws(!1, !1)
}, ra = {
  get: /* @__PURE__ */ ws(!1, !0)
}, sa = {
  get: /* @__PURE__ */ ws(!0, !1)
}, jc = /* @__PURE__ */ new WeakMap(), Vc = /* @__PURE__ */ new WeakMap(), Gc = /* @__PURE__ */ new WeakMap(), oa = /* @__PURE__ */ new WeakMap();
function ca(t) {
  switch (t) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function ia(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : ca(kl(t));
}
function Cs(t) {
  return Gt(t) ? t : As(
    t,
    !1,
    Hc,
    na,
    jc
  );
}
function la(t) {
  return As(
    t,
    !1,
    Jl,
    ra,
    Vc
  );
}
function Zc(t) {
  return As(
    t,
    !0,
    Wl,
    sa,
    Gc
  );
}
function As(t, e, n, r, s) {
  if (!fe(t) || t.__v_raw && !(e && t.__v_isReactive))
    return t;
  const o = s.get(t);
  if (o)
    return o;
  const c = ia(t);
  if (c === 0)
    return t;
  const i = new Proxy(
    t,
    c === 2 ? r : n
  );
  return s.set(t, i), i;
}
function $t(t) {
  return Gt(t) ? $t(t.__v_raw) : !!(t && t.__v_isReactive);
}
function Gt(t) {
  return !!(t && t.__v_isReadonly);
}
function Wn(t) {
  return !!(t && t.__v_isShallow);
}
function Kc(t) {
  return $t(t) || Gt(t);
}
function ce(t) {
  const e = t && t.__v_raw;
  return e ? ce(e) : t;
}
function Wc(t) {
  return Gn(t, "__v_skip", !0), t;
}
const vn = (t) => fe(t) ? Cs(t) : t, Ss = (t) => fe(t) ? Zc(t) : t;
function Jc(t) {
  lt && $e && (t = ce(t), $c(t.dep || (t.dep = xs())));
}
function Yc(t, e) {
  t = ce(t);
  const n = t.dep;
  n && ns(n);
}
function ye(t) {
  return !!(t && t.__v_isRef === !0);
}
function zt(t) {
  return aa(t, !1);
}
function aa(t, e) {
  return ye(t) ? t : new ua(t, e);
}
class ua {
  constructor(e, n) {
    this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? e : ce(e), this._value = n ? e : vn(e);
  }
  get value() {
    return Jc(this), this._value;
  }
  set value(e) {
    const n = this.__v_isShallow || Wn(e) || Gt(e);
    e = n ? e : ce(e), bn(e, this._rawValue) && (this._rawValue = e, this._value = n ? e : vn(e), Yc(this));
  }
}
function he(t) {
  return ye(t) ? t.value : t;
}
const fa = {
  get: (t, e, n) => he(Reflect.get(t, e, n)),
  set: (t, e, n, r) => {
    const s = t[e];
    return ye(s) && !ye(n) ? (s.value = n, !0) : Reflect.set(t, e, n, r);
  }
};
function Xc(t) {
  return $t(t) ? t : new Proxy(t, fa);
}
function pa(t) {
  const e = G(t) ? new Array(t.length) : {};
  for (const n in t)
    e[n] = da(t, n);
  return e;
}
class ha {
  constructor(e, n, r) {
    this._object = e, this._key = n, this._defaultValue = r, this.__v_isRef = !0;
  }
  get value() {
    const e = this._object[this._key];
    return e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    this._object[this._key] = e;
  }
  get dep() {
    return Ol(ce(this._object), this._key);
  }
}
function da(t, e, n) {
  const r = t[e];
  return ye(r) ? r : new ha(
    t,
    e,
    n
  );
}
class ga {
  constructor(e, n, r, s) {
    this._setter = n, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new ys(e, () => {
      this._dirty || (this._dirty = !0, Yc(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !s, this.__v_isReadonly = r;
  }
  get value() {
    const e = ce(this);
    return Jc(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value;
  }
  set value(e) {
    this._setter(e);
  }
}
function ma(t, e, n = !1) {
  let r, s;
  const o = ee(t);
  return o ? (r = t, s = Ue) : (r = t.get, s = t.set), new ga(r, s, o || !s, n);
}
function at(t, e, n, r) {
  let s;
  try {
    s = r ? t(...r) : t();
  } catch (o) {
    ar(o, e, n);
  }
  return s;
}
function Fe(t, e, n, r) {
  if (ee(t)) {
    const o = at(t, e, n, r);
    return o && qc(o) && o.catch((c) => {
      ar(c, e, n);
    }), o;
  }
  const s = [];
  for (let o = 0; o < t.length; o++)
    s.push(Fe(t[o], e, n, r));
  return s;
}
function ar(t, e, n, r = !0) {
  const s = e ? e.vnode : null;
  if (e) {
    let o = e.parent;
    const c = e.proxy, i = n;
    for (; o; ) {
      const a = o.ec;
      if (a) {
        for (let u = 0; u < a.length; u++)
          if (a[u](t, c, i) === !1)
            return;
      }
      o = o.parent;
    }
    const l = e.appContext.config.errorHandler;
    if (l) {
      at(
        l,
        null,
        10,
        [t, c, i]
      );
      return;
    }
  }
  _a(t, n, s, r);
}
function _a(t, e, n, r = !0) {
  console.error(t);
}
let xn = !1, rs = !1;
const ke = [];
let Ke = 0;
const Ut = [];
let et = null, xt = 0;
const Qc = /* @__PURE__ */ Promise.resolve();
let Ds = null;
function Zt(t) {
  const e = Ds || Qc;
  return t ? e.then(this ? t.bind(this) : t) : e;
}
function ba(t) {
  let e = Ke + 1, n = ke.length;
  for (; e < n; ) {
    const r = e + n >>> 1;
    yn(ke[r]) < t ? e = r + 1 : n = r;
  }
  return e;
}
function Ts(t) {
  (!ke.length || !ke.includes(
    t,
    xn && t.allowRecurse ? Ke + 1 : Ke
  )) && (t.id == null ? ke.push(t) : ke.splice(ba(t.id), 0, t), ei());
}
function ei() {
  !xn && !rs && (rs = !0, Ds = Qc.then(ni));
}
function va(t) {
  const e = ke.indexOf(t);
  e > Ke && ke.splice(e, 1);
}
function xa(t) {
  G(t) ? Ut.push(...t) : (!et || !et.includes(
    t,
    t.allowRecurse ? xt + 1 : xt
  )) && Ut.push(t), ei();
}
function co(t, e = xn ? Ke + 1 : 0) {
  for (; e < ke.length; e++) {
    const n = ke[e];
    n && n.pre && (ke.splice(e, 1), e--, n());
  }
}
function ti(t) {
  if (Ut.length) {
    const e = [...new Set(Ut)];
    if (Ut.length = 0, et) {
      et.push(...e);
      return;
    }
    for (et = e, et.sort((n, r) => yn(n) - yn(r)), xt = 0; xt < et.length; xt++)
      et[xt]();
    et = null, xt = 0;
  }
}
const yn = (t) => t.id == null ? 1 / 0 : t.id, ya = (t, e) => {
  const n = yn(t) - yn(e);
  if (n === 0) {
    if (t.pre && !e.pre)
      return -1;
    if (e.pre && !t.pre)
      return 1;
  }
  return n;
};
function ni(t) {
  rs = !1, xn = !0, ke.sort(ya);
  const e = Ue;
  try {
    for (Ke = 0; Ke < ke.length; Ke++) {
      const n = ke[Ke];
      n && n.active !== !1 && at(n, null, 14);
    }
  } finally {
    Ke = 0, ke.length = 0, ti(), xn = !1, Ds = null, (ke.length || Ut.length) && ni();
  }
}
function ka(t, e, ...n) {
  if (t.isUnmounted)
    return;
  const r = t.vnode.props || ue;
  let s = n;
  const o = e.startsWith("update:"), c = o && e.slice(7);
  if (c && c in r) {
    const u = `${c === "modelValue" ? "model" : c}Modifiers`, { number: f, trim: p } = r[u] || ue;
    p && (s = n.map((d) => _e(d) ? d.trim() : d)), f && (s = n.map(Xr));
  }
  let i, l = r[i = Sr(e)] || // also try camelCase event handler (#2249)
  r[i = Sr(Vt(e))];
  !l && o && (l = r[i = Sr(qt(e))]), l && Fe(
    l,
    t,
    6,
    s
  );
  const a = r[i + "Once"];
  if (a) {
    if (!t.emitted)
      t.emitted = {};
    else if (t.emitted[i])
      return;
    t.emitted[i] = !0, Fe(
      a,
      t,
      6,
      s
    );
  }
}
function ri(t, e, n = !1) {
  const r = e.emitsCache, s = r.get(t);
  if (s !== void 0)
    return s;
  const o = t.emits;
  let c = {}, i = !1;
  if (!ee(t)) {
    const l = (a) => {
      const u = ri(a, e, !0);
      u && (i = !0, me(c, u));
    };
    !n && e.mixins.length && e.mixins.forEach(l), t.extends && l(t.extends), t.mixins && t.mixins.forEach(l);
  }
  return !o && !i ? (fe(t) && r.set(t, null), null) : (G(o) ? o.forEach((l) => c[l] = null) : me(c, o), fe(t) && r.set(t, c), c);
}
function ur(t, e) {
  return !t || !or(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), se(t, e[0].toLowerCase() + e.slice(1)) || se(t, qt(e)) || se(t, e));
}
let Ee = null, si = null;
function Jn(t) {
  const e = Ee;
  return Ee = t, si = t && t.type.__scopeId || null, e;
}
function ut(t, e = Ee, n) {
  if (!e || t._n)
    return t;
  const r = (...s) => {
    r._d && vo(-1);
    const o = Jn(e);
    let c;
    try {
      c = t(...s);
    } finally {
      Jn(o), r._d && vo(1);
    }
    return c;
  };
  return r._n = !0, r._c = !0, r._d = !0, r;
}
function Dr(t) {
  const {
    type: e,
    vnode: n,
    proxy: r,
    withProxy: s,
    props: o,
    propsOptions: [c],
    slots: i,
    attrs: l,
    emit: a,
    render: u,
    renderCache: f,
    data: p,
    setupState: d,
    ctx: k,
    inheritAttrs: b
  } = t;
  let I, T;
  const C = Jn(t);
  try {
    if (n.shapeFlag & 4) {
      const A = s || r;
      I = Ze(
        u.call(
          A,
          A,
          f,
          o,
          d,
          p,
          k
        )
      ), T = l;
    } else {
      const A = e;
      I = Ze(
        A.length > 1 ? A(
          o,
          { attrs: l, slots: i, emit: a }
        ) : A(
          o,
          null
          /* we know it doesn't need it */
        )
      ), T = e.props ? l : Ea(l);
    }
  } catch (A) {
    gn.length = 0, ar(A, t, 1), I = de(Le);
  }
  let N = I;
  if (T && b !== !1) {
    const A = Object.keys(T), { shapeFlag: j } = N;
    A.length && j & 7 && (c && A.some(gs) && (T = wa(
      T,
      c
    )), N = pt(N, T));
  }
  return n.dirs && (N = pt(N), N.dirs = N.dirs ? N.dirs.concat(n.dirs) : n.dirs), n.transition && (N.transition = n.transition), I = N, Jn(C), I;
}
const Ea = (t) => {
  let e;
  for (const n in t)
    (n === "class" || n === "style" || or(n)) && ((e || (e = {}))[n] = t[n]);
  return e;
}, wa = (t, e) => {
  const n = {};
  for (const r in t)
    (!gs(r) || !(r.slice(9) in e)) && (n[r] = t[r]);
  return n;
};
function Ca(t, e, n) {
  const { props: r, children: s, component: o } = t, { props: c, children: i, patchFlag: l } = e, a = o.emitsOptions;
  if (e.dirs || e.transition)
    return !0;
  if (n && l >= 0) {
    if (l & 1024)
      return !0;
    if (l & 16)
      return r ? io(r, c, a) : !!c;
    if (l & 8) {
      const u = e.dynamicProps;
      for (let f = 0; f < u.length; f++) {
        const p = u[f];
        if (c[p] !== r[p] && !ur(a, p))
          return !0;
      }
    }
  } else
    return (s || i) && (!i || !i.$stable) ? !0 : r === c ? !1 : r ? c ? io(r, c, a) : !0 : !!c;
  return !1;
}
function io(t, e, n) {
  const r = Object.keys(e);
  if (r.length !== Object.keys(t).length)
    return !0;
  for (let s = 0; s < r.length; s++) {
    const o = r[s];
    if (e[o] !== t[o] && !ur(n, o))
      return !0;
  }
  return !1;
}
function Aa({ vnode: t, parent: e }, n) {
  for (; e && e.subTree === t; )
    (t = e.vnode).el = n, e = e.parent;
}
const Sa = (t) => t.__isSuspense;
function Da(t, e) {
  e && e.pendingBranch ? G(t) ? e.effects.push(...t) : e.effects.push(t) : xa(t);
}
const On = {};
function Tr(t, e, n) {
  return oi(t, e, n);
}
function oi(t, e, { immediate: n, deep: r, flush: s, onTrack: o, onTrigger: c } = ue) {
  var i;
  const l = Il() === ((i = xe) == null ? void 0 : i.scope) ? xe : null;
  let a, u = !1, f = !1;
  if (ye(t) ? (a = () => t.value, u = Wn(t)) : $t(t) ? (a = () => t, r = !0) : G(t) ? (f = !0, u = t.some((A) => $t(A) || Wn(A)), a = () => t.map((A) => {
    if (ye(A))
      return A.value;
    if ($t(A))
      return wt(A);
    if (ee(A))
      return at(A, l, 2);
  })) : ee(t) ? e ? a = () => at(t, l, 2) : a = () => {
    if (!(l && l.isUnmounted))
      return p && p(), Fe(
        t,
        l,
        3,
        [d]
      );
  } : a = Ue, e && r) {
    const A = a;
    a = () => wt(A());
  }
  let p, d = (A) => {
    p = C.onStop = () => {
      at(A, l, 4);
    };
  }, k;
  if (En)
    if (d = Ue, e ? n && Fe(e, l, 3, [
      a(),
      f ? [] : void 0,
      d
    ]) : a(), s === "sync") {
      const A = Eu();
      k = A.__watcherHandles || (A.__watcherHandles = []);
    } else
      return Ue;
  let b = f ? new Array(t.length).fill(On) : On;
  const I = () => {
    if (C.active)
      if (e) {
        const A = C.run();
        (r || u || (f ? A.some(
          (j, q) => bn(j, b[q])
        ) : bn(A, b))) && (p && p(), Fe(e, l, 3, [
          A,
          // pass undefined as the old value when it's changed for the first time
          b === On ? void 0 : f && b[0] === On ? [] : b,
          d
        ]), b = A);
      } else
        C.run();
  };
  I.allowRecurse = !!e;
  let T;
  s === "sync" ? T = I : s === "post" ? T = () => Te(I, l && l.suspense) : (I.pre = !0, l && (I.id = l.uid), T = () => Ts(I));
  const C = new ys(a, T);
  e ? n ? I() : b = C.run() : s === "post" ? Te(
    C.run.bind(C),
    l && l.suspense
  ) : C.run();
  const N = () => {
    C.stop(), l && l.scope && ms(l.scope.effects, C);
  };
  return k && k.push(N), N;
}
function Ta(t, e, n) {
  const r = this.proxy, s = _e(t) ? t.includes(".") ? ci(r, t) : () => r[t] : t.bind(r, r);
  let o;
  ee(e) ? o = e : (o = e.handler, n = e);
  const c = xe;
  Kt(this);
  const i = oi(s, o.bind(r), n);
  return c ? Kt(c) : St(), i;
}
function ci(t, e) {
  const n = e.split(".");
  return () => {
    let r = t;
    for (let s = 0; s < n.length && r; s++)
      r = r[n[s]];
    return r;
  };
}
function wt(t, e) {
  if (!fe(t) || t.__v_skip || (e = e || /* @__PURE__ */ new Set(), e.has(t)))
    return t;
  if (e.add(t), ye(t))
    wt(t.value, e);
  else if (G(t))
    for (let n = 0; n < t.length; n++)
      wt(t[n], e);
  else if (Rc(t) || Bt(t))
    t.forEach((n) => {
      wt(n, e);
    });
  else if (Nc(t))
    for (const n in t)
      wt(t[n], e);
  return t;
}
function ii(t, e) {
  const n = Ee;
  if (n === null)
    return t;
  const r = gr(n) || n.proxy, s = t.dirs || (t.dirs = []);
  for (let o = 0; o < e.length; o++) {
    let [c, i, l, a = ue] = e[o];
    c && (ee(c) && (c = {
      mounted: c,
      updated: c
    }), c.deep && wt(i), s.push({
      dir: c,
      instance: r,
      value: i,
      oldValue: void 0,
      arg: l,
      modifiers: a
    }));
  }
  return t;
}
function gt(t, e, n, r) {
  const s = t.dirs, o = e && e.dirs;
  for (let c = 0; c < s.length; c++) {
    const i = s[c];
    o && (i.oldValue = o[c].value);
    let l = i.dir[r];
    l && (Jt(), Fe(l, n, 8, [
      t.el,
      i,
      t,
      e
    ]), Yt());
  }
}
function Ra() {
  const t = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return Dn(() => {
    t.isMounted = !0;
  }), Rs(() => {
    t.isUnmounting = !0;
  }), t;
}
const Ie = [Function, Array], li = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: Ie,
  onEnter: Ie,
  onAfterEnter: Ie,
  onEnterCancelled: Ie,
  // leave
  onBeforeLeave: Ie,
  onLeave: Ie,
  onAfterLeave: Ie,
  onLeaveCancelled: Ie,
  // appear
  onBeforeAppear: Ie,
  onAppear: Ie,
  onAfterAppear: Ie,
  onAppearCancelled: Ie
}, qa = {
  name: "BaseTransition",
  props: li,
  setup(t, { slots: e }) {
    const n = mu(), r = Ra();
    let s;
    return () => {
      const o = e.default && ui(e.default(), !0);
      if (!o || !o.length)
        return;
      let c = o[0];
      if (o.length > 1) {
        for (const b of o)
          if (b.type !== Le) {
            c = b;
            break;
          }
      }
      const i = ce(t), { mode: l } = i;
      if (r.isLeaving)
        return Rr(c);
      const a = lo(c);
      if (!a)
        return Rr(c);
      const u = ss(
        a,
        i,
        r,
        n
      );
      os(a, u);
      const f = n.subTree, p = f && lo(f);
      let d = !1;
      const { getTransitionKey: k } = a.type;
      if (k) {
        const b = k();
        s === void 0 ? s = b : b !== s && (s = b, d = !0);
      }
      if (p && p.type !== Le && (!yt(a, p) || d)) {
        const b = ss(
          p,
          i,
          r,
          n
        );
        if (os(p, b), l === "out-in")
          return r.isLeaving = !0, b.afterLeave = () => {
            r.isLeaving = !1, n.update.active !== !1 && n.update();
          }, Rr(c);
        l === "in-out" && a.type !== Le && (b.delayLeave = (I, T, C) => {
          const N = ai(
            r,
            p
          );
          N[String(p.key)] = p, I._leaveCb = () => {
            T(), I._leaveCb = void 0, delete u.delayedLeave;
          }, u.delayedLeave = C;
        });
      }
      return c;
    };
  }
}, Ma = qa;
function ai(t, e) {
  const { leavingVNodes: n } = t;
  let r = n.get(e.type);
  return r || (r = /* @__PURE__ */ Object.create(null), n.set(e.type, r)), r;
}
function ss(t, e, n, r) {
  const {
    appear: s,
    mode: o,
    persisted: c = !1,
    onBeforeEnter: i,
    onEnter: l,
    onAfterEnter: a,
    onEnterCancelled: u,
    onBeforeLeave: f,
    onLeave: p,
    onAfterLeave: d,
    onLeaveCancelled: k,
    onBeforeAppear: b,
    onAppear: I,
    onAfterAppear: T,
    onAppearCancelled: C
  } = e, N = String(t.key), A = ai(n, t), j = ($, X) => {
    $ && Fe(
      $,
      r,
      9,
      X
    );
  }, q = ($, X) => {
    const z = X[1];
    j($, X), G($) ? $.every((J) => J.length <= 1) && z() : $.length <= 1 && z();
  }, W = {
    mode: o,
    persisted: c,
    beforeEnter($) {
      let X = i;
      if (!n.isMounted)
        if (s)
          X = b || i;
        else
          return;
      $._leaveCb && $._leaveCb(
        !0
        /* cancelled */
      );
      const z = A[N];
      z && yt(t, z) && z.el._leaveCb && z.el._leaveCb(), j(X, [$]);
    },
    enter($) {
      let X = l, z = a, J = u;
      if (!n.isMounted)
        if (s)
          X = I || l, z = T || a, J = C || u;
        else
          return;
      let B = !1;
      const re = $._enterCb = (D) => {
        B || (B = !0, D ? j(J, [$]) : j(z, [$]), W.delayedLeave && W.delayedLeave(), $._enterCb = void 0);
      };
      X ? q(X, [$, re]) : re();
    },
    leave($, X) {
      const z = String(t.key);
      if ($._enterCb && $._enterCb(
        !0
        /* cancelled */
      ), n.isUnmounting)
        return X();
      j(f, [$]);
      let J = !1;
      const B = $._leaveCb = (re) => {
        J || (J = !0, X(), re ? j(k, [$]) : j(d, [$]), $._leaveCb = void 0, A[z] === t && delete A[z]);
      };
      A[z] = t, p ? q(p, [$, B]) : B();
    },
    clone($) {
      return ss($, e, n, r);
    }
  };
  return W;
}
function Rr(t) {
  if (fr(t))
    return t = pt(t), t.children = null, t;
}
function lo(t) {
  return fr(t) ? t.children ? t.children[0] : void 0 : t;
}
function os(t, e) {
  t.shapeFlag & 6 && t.component ? os(t.component.subTree, e) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e;
}
function ui(t, e = !1, n) {
  let r = [], s = 0;
  for (let o = 0; o < t.length; o++) {
    let c = t[o];
    const i = n == null ? c.key : String(n) + String(c.key != null ? c.key : o);
    c.type === Re ? (c.patchFlag & 128 && s++, r = r.concat(
      ui(c.children, e, i)
    )) : (e || c.type !== Le) && r.push(i != null ? pt(c, { key: i }) : c);
  }
  if (s > 1)
    for (let o = 0; o < r.length; o++)
      r[o].patchFlag = -2;
  return r;
}
function He(t, e) {
  return ee(t) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => me({ name: t.name }, e, { setup: t }))()
  ) : t;
}
const pn = (t) => !!t.type.__asyncLoader, fr = (t) => t.type.__isKeepAlive;
function Na(t, e) {
  fi(t, "a", e);
}
function Ia(t, e) {
  fi(t, "da", e);
}
function fi(t, e, n = xe) {
  const r = t.__wdc || (t.__wdc = () => {
    let s = n;
    for (; s; ) {
      if (s.isDeactivated)
        return;
      s = s.parent;
    }
    return t();
  });
  if (pr(e, r, n), n) {
    let s = n.parent;
    for (; s && s.parent; )
      fr(s.parent.vnode) && Fa(r, e, n, s), s = s.parent;
  }
}
function Fa(t, e, n, r) {
  const s = pr(
    e,
    t,
    r,
    !0
    /* prepend */
  );
  pi(() => {
    ms(r[e], s);
  }, n);
}
function pr(t, e, n = xe, r = !1) {
  if (n) {
    const s = n[t] || (n[t] = []), o = e.__weh || (e.__weh = (...c) => {
      if (n.isUnmounted)
        return;
      Jt(), Kt(n);
      const i = Fe(e, n, t, c);
      return St(), Yt(), i;
    });
    return r ? s.unshift(o) : s.push(o), o;
  }
}
const nt = (t) => (e, n = xe) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!En || t === "sp") && pr(t, (...r) => e(...r), n)
), La = nt("bm"), Dn = nt("m"), Oa = nt("bu"), Pa = nt("u"), Rs = nt("bum"), pi = nt("um"), Ba = nt("sp"), $a = nt(
  "rtg"
), za = nt(
  "rtc"
);
function Ua(t, e = xe) {
  pr("ec", t, e);
}
const Ha = Symbol.for("v-ndc");
function ao(t, e, n, r) {
  let s;
  const o = n && n[r];
  if (G(t) || _e(t)) {
    s = new Array(t.length);
    for (let c = 0, i = t.length; c < i; c++)
      s[c] = e(t[c], c, void 0, o && o[c]);
  } else if (typeof t == "number") {
    s = new Array(t);
    for (let c = 0; c < t; c++)
      s[c] = e(c + 1, c, void 0, o && o[c]);
  } else if (fe(t))
    if (t[Symbol.iterator])
      s = Array.from(
        t,
        (c, i) => e(c, i, void 0, o && o[i])
      );
    else {
      const c = Object.keys(t);
      s = new Array(c.length);
      for (let i = 0, l = c.length; i < l; i++) {
        const a = c[i];
        s[i] = e(t[a], a, i, o && o[i]);
      }
    }
  else
    s = [];
  return n && (n[r] = s), s;
}
function ja(t, e) {
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    if (G(r))
      for (let s = 0; s < r.length; s++)
        t[r[s].name] = r[s].fn;
    else
      r && (t[r.name] = r.key ? (...s) => {
        const o = r.fn(...s);
        return o && (o.key = r.key), o;
      } : r.fn);
  }
  return t;
}
function hn(t, e, n = {}, r, s) {
  if (Ee.isCE || Ee.parent && pn(Ee.parent) && Ee.parent.isCE)
    return e !== "default" && (n.name = e), de("slot", n, r && r());
  let o = t[e];
  o && o._c && (o._d = !1), oe();
  const c = o && hi(o(n)), i = Se(
    Re,
    {
      key: n.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      c && c.key || `_${e}`
    },
    c || (r ? r() : []),
    c && t._ === 1 ? 64 : -2
  );
  return !s && i.scopeId && (i.slotScopeIds = [i.scopeId + "-s"]), o && o._c && (o._d = !0), i;
}
function hi(t) {
  return t.some((e) => Qn(e) ? !(e.type === Le || e.type === Re && !hi(e.children)) : !0) ? t : null;
}
const cs = (t) => t ? wi(t) ? gr(t) || t.proxy : cs(t.parent) : null, dn = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ me(/* @__PURE__ */ Object.create(null), {
    $: (t) => t,
    $el: (t) => t.vnode.el,
    $data: (t) => t.data,
    $props: (t) => t.props,
    $attrs: (t) => t.attrs,
    $slots: (t) => t.slots,
    $refs: (t) => t.refs,
    $parent: (t) => cs(t.parent),
    $root: (t) => cs(t.root),
    $emit: (t) => t.emit,
    $options: (t) => qs(t),
    $forceUpdate: (t) => t.f || (t.f = () => Ts(t.update)),
    $nextTick: (t) => t.n || (t.n = Zt.bind(t.proxy)),
    $watch: (t) => Ta.bind(t)
  })
), qr = (t, e) => t !== ue && !t.__isScriptSetup && se(t, e), Va = {
  get({ _: t }, e) {
    const { ctx: n, setupState: r, data: s, props: o, accessCache: c, type: i, appContext: l } = t;
    let a;
    if (e[0] !== "$") {
      const d = c[e];
      if (d !== void 0)
        switch (d) {
          case 1:
            return r[e];
          case 2:
            return s[e];
          case 4:
            return n[e];
          case 3:
            return o[e];
        }
      else {
        if (qr(r, e))
          return c[e] = 1, r[e];
        if (s !== ue && se(s, e))
          return c[e] = 2, s[e];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (a = t.propsOptions[0]) && se(a, e)
        )
          return c[e] = 3, o[e];
        if (n !== ue && se(n, e))
          return c[e] = 4, n[e];
        is && (c[e] = 0);
      }
    }
    const u = dn[e];
    let f, p;
    if (u)
      return e === "$attrs" && qe(t, "get", e), u(t);
    if (
      // css module (injected by vue-loader)
      (f = i.__cssModules) && (f = f[e])
    )
      return f;
    if (n !== ue && se(n, e))
      return c[e] = 4, n[e];
    if (
      // global properties
      p = l.config.globalProperties, se(p, e)
    )
      return p[e];
  },
  set({ _: t }, e, n) {
    const { data: r, setupState: s, ctx: o } = t;
    return qr(s, e) ? (s[e] = n, !0) : r !== ue && se(r, e) ? (r[e] = n, !0) : se(t.props, e) || e[0] === "$" && e.slice(1) in t ? !1 : (o[e] = n, !0);
  },
  has({
    _: { data: t, setupState: e, accessCache: n, ctx: r, appContext: s, propsOptions: o }
  }, c) {
    let i;
    return !!n[c] || t !== ue && se(t, c) || qr(e, c) || (i = o[0]) && se(i, c) || se(r, c) || se(dn, c) || se(s.config.globalProperties, c);
  },
  defineProperty(t, e, n) {
    return n.get != null ? t._.accessCache[e] = 0 : se(n, "value") && this.set(t, e, n.value, null), Reflect.defineProperty(t, e, n);
  }
};
function uo(t) {
  return G(t) ? t.reduce(
    (e, n) => (e[n] = null, e),
    {}
  ) : t;
}
let is = !0;
function Ga(t) {
  const e = qs(t), n = t.proxy, r = t.ctx;
  is = !1, e.beforeCreate && fo(e.beforeCreate, t, "bc");
  const {
    // state
    data: s,
    computed: o,
    methods: c,
    watch: i,
    provide: l,
    inject: a,
    // lifecycle
    created: u,
    beforeMount: f,
    mounted: p,
    beforeUpdate: d,
    updated: k,
    activated: b,
    deactivated: I,
    beforeDestroy: T,
    beforeUnmount: C,
    destroyed: N,
    unmounted: A,
    render: j,
    renderTracked: q,
    renderTriggered: W,
    errorCaptured: $,
    serverPrefetch: X,
    // public API
    expose: z,
    inheritAttrs: J,
    // assets
    components: B,
    directives: re,
    filters: D
  } = e;
  if (a && Za(a, r, null), c)
    for (const v in c) {
      const S = c[v];
      ee(S) && (r[v] = S.bind(n));
    }
  if (s) {
    const v = s.call(n, n);
    fe(v) && (t.data = Cs(v));
  }
  if (is = !0, o)
    for (const v in o) {
      const S = o[v], Z = ee(S) ? S.bind(n, n) : ee(S.get) ? S.get.bind(n, n) : Ue, te = !ee(S) && ee(S.set) ? S.set.bind(n) : Ue, ie = Xt({
        get: Z,
        set: te
      });
      Object.defineProperty(r, v, {
        enumerable: !0,
        configurable: !0,
        get: () => ie.value,
        set: (ae) => ie.value = ae
      });
    }
  if (i)
    for (const v in i)
      di(i[v], r, n, v);
  if (l) {
    const v = ee(l) ? l.call(n) : l;
    Reflect.ownKeys(v).forEach((S) => {
      Qa(S, v[S]);
    });
  }
  u && fo(u, t, "c");
  function V(v, S) {
    G(S) ? S.forEach((Z) => v(Z.bind(n))) : S && v(S.bind(n));
  }
  if (V(La, f), V(Dn, p), V(Oa, d), V(Pa, k), V(Na, b), V(Ia, I), V(Ua, $), V(za, q), V($a, W), V(Rs, C), V(pi, A), V(Ba, X), G(z))
    if (z.length) {
      const v = t.exposed || (t.exposed = {});
      z.forEach((S) => {
        Object.defineProperty(v, S, {
          get: () => n[S],
          set: (Z) => n[S] = Z
        });
      });
    } else
      t.exposed || (t.exposed = {});
  j && t.render === Ue && (t.render = j), J != null && (t.inheritAttrs = J), B && (t.components = B), re && (t.directives = re);
}
function Za(t, e, n = Ue) {
  G(t) && (t = ls(t));
  for (const r in t) {
    const s = t[r];
    let o;
    fe(s) ? "default" in s ? o = Ht(
      s.from || r,
      s.default,
      !0
      /* treat default function as factory */
    ) : o = Ht(s.from || r) : o = Ht(s), ye(o) ? Object.defineProperty(e, r, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (c) => o.value = c
    }) : e[r] = o;
  }
}
function fo(t, e, n) {
  Fe(
    G(t) ? t.map((r) => r.bind(e.proxy)) : t.bind(e.proxy),
    e,
    n
  );
}
function di(t, e, n, r) {
  const s = r.includes(".") ? ci(n, r) : () => n[r];
  if (_e(t)) {
    const o = e[t];
    ee(o) && Tr(s, o);
  } else if (ee(t))
    Tr(s, t.bind(n));
  else if (fe(t))
    if (G(t))
      t.forEach((o) => di(o, e, n, r));
    else {
      const o = ee(t.handler) ? t.handler.bind(n) : e[t.handler];
      ee(o) && Tr(s, o, t);
    }
}
function qs(t) {
  const e = t.type, { mixins: n, extends: r } = e, {
    mixins: s,
    optionsCache: o,
    config: { optionMergeStrategies: c }
  } = t.appContext, i = o.get(e);
  let l;
  return i ? l = i : !s.length && !n && !r ? l = e : (l = {}, s.length && s.forEach(
    (a) => Yn(l, a, c, !0)
  ), Yn(l, e, c)), fe(e) && o.set(e, l), l;
}
function Yn(t, e, n, r = !1) {
  const { mixins: s, extends: o } = e;
  o && Yn(t, o, n, !0), s && s.forEach(
    (c) => Yn(t, c, n, !0)
  );
  for (const c in e)
    if (!(r && c === "expose")) {
      const i = Ka[c] || n && n[c];
      t[c] = i ? i(t[c], e[c]) : e[c];
    }
  return t;
}
const Ka = {
  data: po,
  props: ho,
  emits: ho,
  // objects
  methods: fn,
  computed: fn,
  // lifecycle
  beforeCreate: Ae,
  created: Ae,
  beforeMount: Ae,
  mounted: Ae,
  beforeUpdate: Ae,
  updated: Ae,
  beforeDestroy: Ae,
  beforeUnmount: Ae,
  destroyed: Ae,
  unmounted: Ae,
  activated: Ae,
  deactivated: Ae,
  errorCaptured: Ae,
  serverPrefetch: Ae,
  // assets
  components: fn,
  directives: fn,
  // watch
  watch: Ja,
  // provide / inject
  provide: po,
  inject: Wa
};
function po(t, e) {
  return e ? t ? function() {
    return me(
      ee(t) ? t.call(this, this) : t,
      ee(e) ? e.call(this, this) : e
    );
  } : e : t;
}
function Wa(t, e) {
  return fn(ls(t), ls(e));
}
function ls(t) {
  if (G(t)) {
    const e = {};
    for (let n = 0; n < t.length; n++)
      e[t[n]] = t[n];
    return e;
  }
  return t;
}
function Ae(t, e) {
  return t ? [...new Set([].concat(t, e))] : e;
}
function fn(t, e) {
  return t ? me(/* @__PURE__ */ Object.create(null), t, e) : e;
}
function ho(t, e) {
  return t ? G(t) && G(e) ? [.../* @__PURE__ */ new Set([...t, ...e])] : me(
    /* @__PURE__ */ Object.create(null),
    uo(t),
    uo(e ?? {})
  ) : e;
}
function Ja(t, e) {
  if (!t)
    return e;
  if (!e)
    return t;
  const n = me(/* @__PURE__ */ Object.create(null), t);
  for (const r in e)
    n[r] = Ae(t[r], e[r]);
  return n;
}
function gi() {
  return {
    app: null,
    config: {
      isNativeTag: vl,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let Ya = 0;
function Xa(t, e) {
  return function(r, s = null) {
    ee(r) || (r = me({}, r)), s != null && !fe(s) && (s = null);
    const o = gi(), c = /* @__PURE__ */ new Set();
    let i = !1;
    const l = o.app = {
      _uid: Ya++,
      _component: r,
      _props: s,
      _container: null,
      _context: o,
      _instance: null,
      version: wu,
      get config() {
        return o.config;
      },
      set config(a) {
      },
      use(a, ...u) {
        return c.has(a) || (a && ee(a.install) ? (c.add(a), a.install(l, ...u)) : ee(a) && (c.add(a), a(l, ...u))), l;
      },
      mixin(a) {
        return o.mixins.includes(a) || o.mixins.push(a), l;
      },
      component(a, u) {
        return u ? (o.components[a] = u, l) : o.components[a];
      },
      directive(a, u) {
        return u ? (o.directives[a] = u, l) : o.directives[a];
      },
      mount(a, u, f) {
        if (!i) {
          const p = de(
            r,
            s
          );
          return p.appContext = o, u && e ? e(p, a) : t(p, a, f), i = !0, l._container = a, a.__vue_app__ = l, gr(p.component) || p.component.proxy;
        }
      },
      unmount() {
        i && (t(null, l._container), delete l._container.__vue_app__);
      },
      provide(a, u) {
        return o.provides[a] = u, l;
      },
      runWithContext(a) {
        Xn = l;
        try {
          return a();
        } finally {
          Xn = null;
        }
      }
    };
    return l;
  };
}
let Xn = null;
function Qa(t, e) {
  if (xe) {
    let n = xe.provides;
    const r = xe.parent && xe.parent.provides;
    r === n && (n = xe.provides = Object.create(r)), n[t] = e;
  }
}
function Ht(t, e, n = !1) {
  const r = xe || Ee;
  if (r || Xn) {
    const s = r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : Xn._context.provides;
    if (s && t in s)
      return s[t];
    if (arguments.length > 1)
      return n && ee(e) ? e.call(r && r.proxy) : e;
  }
}
function eu(t, e, n, r = !1) {
  const s = {}, o = {};
  Gn(o, dr, 1), t.propsDefaults = /* @__PURE__ */ Object.create(null), mi(t, e, s, o);
  for (const c in t.propsOptions[0])
    c in s || (s[c] = void 0);
  n ? t.props = r ? s : la(s) : t.type.props ? t.props = s : t.props = o, t.attrs = o;
}
function tu(t, e, n, r) {
  const {
    props: s,
    attrs: o,
    vnode: { patchFlag: c }
  } = t, i = ce(s), [l] = t.propsOptions;
  let a = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (r || c > 0) && !(c & 16)
  ) {
    if (c & 8) {
      const u = t.vnode.dynamicProps;
      for (let f = 0; f < u.length; f++) {
        let p = u[f];
        if (ur(t.emitsOptions, p))
          continue;
        const d = e[p];
        if (l)
          if (se(o, p))
            d !== o[p] && (o[p] = d, a = !0);
          else {
            const k = Vt(p);
            s[k] = as(
              l,
              i,
              k,
              d,
              t,
              !1
              /* isAbsent */
            );
          }
        else
          d !== o[p] && (o[p] = d, a = !0);
      }
    }
  } else {
    mi(t, e, s, o) && (a = !0);
    let u;
    for (const f in i)
      (!e || // for camelCase
      !se(e, f) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((u = qt(f)) === f || !se(e, u))) && (l ? n && // for camelCase
      (n[f] !== void 0 || // for kebab-case
      n[u] !== void 0) && (s[f] = as(
        l,
        i,
        f,
        void 0,
        t,
        !0
        /* isAbsent */
      )) : delete s[f]);
    if (o !== i)
      for (const f in o)
        (!e || !se(e, f)) && (delete o[f], a = !0);
  }
  a && tt(t, "set", "$attrs");
}
function mi(t, e, n, r) {
  const [s, o] = t.propsOptions;
  let c = !1, i;
  if (e)
    for (let l in e) {
      if (Hn(l))
        continue;
      const a = e[l];
      let u;
      s && se(s, u = Vt(l)) ? !o || !o.includes(u) ? n[u] = a : (i || (i = {}))[u] = a : ur(t.emitsOptions, l) || (!(l in r) || a !== r[l]) && (r[l] = a, c = !0);
    }
  if (o) {
    const l = ce(n), a = i || ue;
    for (let u = 0; u < o.length; u++) {
      const f = o[u];
      n[f] = as(
        s,
        l,
        f,
        a[f],
        t,
        !se(a, f)
      );
    }
  }
  return c;
}
function as(t, e, n, r, s, o) {
  const c = t[n];
  if (c != null) {
    const i = se(c, "default");
    if (i && r === void 0) {
      const l = c.default;
      if (c.type !== Function && !c.skipFactory && ee(l)) {
        const { propsDefaults: a } = s;
        n in a ? r = a[n] : (Kt(s), r = a[n] = l.call(
          null,
          e
        ), St());
      } else
        r = l;
    }
    c[
      0
      /* shouldCast */
    ] && (o && !i ? r = !1 : c[
      1
      /* shouldCastTrue */
    ] && (r === "" || r === qt(n)) && (r = !0));
  }
  return r;
}
function _i(t, e, n = !1) {
  const r = e.propsCache, s = r.get(t);
  if (s)
    return s;
  const o = t.props, c = {}, i = [];
  let l = !1;
  if (!ee(t)) {
    const u = (f) => {
      l = !0;
      const [p, d] = _i(f, e, !0);
      me(c, p), d && i.push(...d);
    };
    !n && e.mixins.length && e.mixins.forEach(u), t.extends && u(t.extends), t.mixins && t.mixins.forEach(u);
  }
  if (!o && !l)
    return fe(t) && r.set(t, Pt), Pt;
  if (G(o))
    for (let u = 0; u < o.length; u++) {
      const f = Vt(o[u]);
      go(f) && (c[f] = ue);
    }
  else if (o)
    for (const u in o) {
      const f = Vt(u);
      if (go(f)) {
        const p = o[u], d = c[f] = G(p) || ee(p) ? { type: p } : me({}, p);
        if (d) {
          const k = bo(Boolean, d.type), b = bo(String, d.type);
          d[
            0
            /* shouldCast */
          ] = k > -1, d[
            1
            /* shouldCastTrue */
          ] = b < 0 || k < b, (k > -1 || se(d, "default")) && i.push(f);
        }
      }
    }
  const a = [c, i];
  return fe(t) && r.set(t, a), a;
}
function go(t) {
  return t[0] !== "$";
}
function mo(t) {
  const e = t && t.toString().match(/^\s*(function|class) (\w+)/);
  return e ? e[2] : t === null ? "null" : "";
}
function _o(t, e) {
  return mo(t) === mo(e);
}
function bo(t, e) {
  return G(e) ? e.findIndex((n) => _o(n, t)) : ee(e) && _o(e, t) ? 0 : -1;
}
const bi = (t) => t[0] === "_" || t === "$stable", Ms = (t) => G(t) ? t.map(Ze) : [Ze(t)], nu = (t, e, n) => {
  if (e._n)
    return e;
  const r = ut((...s) => Ms(e(...s)), n);
  return r._c = !1, r;
}, vi = (t, e, n) => {
  const r = t._ctx;
  for (const s in t) {
    if (bi(s))
      continue;
    const o = t[s];
    if (ee(o))
      e[s] = nu(s, o, r);
    else if (o != null) {
      const c = Ms(o);
      e[s] = () => c;
    }
  }
}, xi = (t, e) => {
  const n = Ms(e);
  t.slots.default = () => n;
}, ru = (t, e) => {
  if (t.vnode.shapeFlag & 32) {
    const n = e._;
    n ? (t.slots = ce(e), Gn(e, "_", n)) : vi(
      e,
      t.slots = {}
    );
  } else
    t.slots = {}, e && xi(t, e);
  Gn(t.slots, dr, 1);
}, su = (t, e, n) => {
  const { vnode: r, slots: s } = t;
  let o = !0, c = ue;
  if (r.shapeFlag & 32) {
    const i = e._;
    i ? n && i === 1 ? o = !1 : (me(s, e), !n && i === 1 && delete s._) : (o = !e.$stable, vi(e, s)), c = e;
  } else
    e && (xi(t, e), c = { default: 1 });
  if (o)
    for (const i in s)
      !bi(i) && !(i in c) && delete s[i];
};
function us(t, e, n, r, s = !1) {
  if (G(t)) {
    t.forEach(
      (p, d) => us(
        p,
        e && (G(e) ? e[d] : e),
        n,
        r,
        s
      )
    );
    return;
  }
  if (pn(r) && !s)
    return;
  const o = r.shapeFlag & 4 ? gr(r.component) || r.component.proxy : r.el, c = s ? null : o, { i, r: l } = t, a = e && e.r, u = i.refs === ue ? i.refs = {} : i.refs, f = i.setupState;
  if (a != null && a !== l && (_e(a) ? (u[a] = null, se(f, a) && (f[a] = null)) : ye(a) && (a.value = null)), ee(l))
    at(l, i, 12, [c, u]);
  else {
    const p = _e(l), d = ye(l);
    if (p || d) {
      const k = () => {
        if (t.f) {
          const b = p ? se(f, l) ? f[l] : u[l] : l.value;
          s ? G(b) && ms(b, o) : G(b) ? b.includes(o) || b.push(o) : p ? (u[l] = [o], se(f, l) && (f[l] = u[l])) : (l.value = [o], t.k && (u[t.k] = l.value));
        } else
          p ? (u[l] = c, se(f, l) && (f[l] = c)) : d && (l.value = c, t.k && (u[t.k] = c));
      };
      c ? (k.id = -1, Te(k, n)) : k();
    }
  }
}
const Te = Da;
function ou(t) {
  return cu(t);
}
function cu(t, e) {
  const n = Qr();
  n.__VUE__ = !0;
  const {
    insert: r,
    remove: s,
    patchProp: o,
    createElement: c,
    createText: i,
    createComment: l,
    setText: a,
    setElementText: u,
    parentNode: f,
    nextSibling: p,
    setScopeId: d = Ue,
    insertStaticContent: k
  } = t, b = (h, g, _, E = null, x = null, M = null, O = !1, m = null, F = !!g.dynamicChildren) => {
    if (h === g)
      return;
    h && !yt(h, g) && (E = ht(h), ae(h, x, M, !0), h = null), g.patchFlag === -2 && (F = !1, g.dynamicChildren = null);
    const { type: y, ref: L, shapeFlag: P } = g;
    switch (y) {
      case hr:
        I(h, g, _, E);
        break;
      case Le:
        T(h, g, _, E);
        break;
      case Mr:
        h == null && C(g, _, E, O);
        break;
      case Re:
        B(
          h,
          g,
          _,
          E,
          x,
          M,
          O,
          m,
          F
        );
        break;
      default:
        P & 1 ? j(
          h,
          g,
          _,
          E,
          x,
          M,
          O,
          m,
          F
        ) : P & 6 ? re(
          h,
          g,
          _,
          E,
          x,
          M,
          O,
          m,
          F
        ) : (P & 64 || P & 128) && y.process(
          h,
          g,
          _,
          E,
          x,
          M,
          O,
          m,
          F,
          Qe
        );
    }
    L != null && x && us(L, h && h.ref, M, g || h, !g);
  }, I = (h, g, _, E) => {
    if (h == null)
      r(
        g.el = i(g.children),
        _,
        E
      );
    else {
      const x = g.el = h.el;
      g.children !== h.children && a(x, g.children);
    }
  }, T = (h, g, _, E) => {
    h == null ? r(
      g.el = l(g.children || ""),
      _,
      E
    ) : g.el = h.el;
  }, C = (h, g, _, E) => {
    [h.el, h.anchor] = k(
      h.children,
      g,
      _,
      E,
      h.el,
      h.anchor
    );
  }, N = ({ el: h, anchor: g }, _, E) => {
    let x;
    for (; h && h !== g; )
      x = p(h), r(h, _, E), h = x;
    r(g, _, E);
  }, A = ({ el: h, anchor: g }) => {
    let _;
    for (; h && h !== g; )
      _ = p(h), s(h), h = _;
    s(g);
  }, j = (h, g, _, E, x, M, O, m, F) => {
    O = O || g.type === "svg", h == null ? q(
      g,
      _,
      E,
      x,
      M,
      O,
      m,
      F
    ) : X(
      h,
      g,
      x,
      M,
      O,
      m,
      F
    );
  }, q = (h, g, _, E, x, M, O, m) => {
    let F, y;
    const { type: L, props: P, shapeFlag: U, transition: K, dirs: Q } = h;
    if (F = h.el = c(
      h.type,
      M,
      P && P.is,
      P
    ), U & 8 ? u(F, h.children) : U & 16 && $(
      h.children,
      F,
      null,
      E,
      x,
      M && L !== "foreignObject",
      O,
      m
    ), Q && gt(h, null, E, "created"), W(F, h, h.scopeId, O, E), P) {
      for (const R in P)
        R !== "value" && !Hn(R) && o(
          F,
          R,
          null,
          P[R],
          M,
          h.children,
          E,
          x,
          ge
        );
      "value" in P && o(F, "value", null, P.value), (y = P.onVnodeBeforeMount) && Ge(y, E, h);
    }
    Q && gt(h, null, E, "beforeMount");
    const w = (!x || x && !x.pendingBranch) && K && !K.persisted;
    w && K.beforeEnter(F), r(F, g, _), ((y = P && P.onVnodeMounted) || w || Q) && Te(() => {
      y && Ge(y, E, h), w && K.enter(F), Q && gt(h, null, E, "mounted");
    }, x);
  }, W = (h, g, _, E, x) => {
    if (_ && d(h, _), E)
      for (let M = 0; M < E.length; M++)
        d(h, E[M]);
    if (x) {
      let M = x.subTree;
      if (g === M) {
        const O = x.vnode;
        W(
          h,
          O,
          O.scopeId,
          O.slotScopeIds,
          x.parent
        );
      }
    }
  }, $ = (h, g, _, E, x, M, O, m, F = 0) => {
    for (let y = F; y < h.length; y++) {
      const L = h[y] = m ? ct(h[y]) : Ze(h[y]);
      b(
        null,
        L,
        g,
        _,
        E,
        x,
        M,
        O,
        m
      );
    }
  }, X = (h, g, _, E, x, M, O) => {
    const m = g.el = h.el;
    let { patchFlag: F, dynamicChildren: y, dirs: L } = g;
    F |= h.patchFlag & 16;
    const P = h.props || ue, U = g.props || ue;
    let K;
    _ && mt(_, !1), (K = U.onVnodeBeforeUpdate) && Ge(K, _, g, h), L && gt(g, h, _, "beforeUpdate"), _ && mt(_, !0);
    const Q = x && g.type !== "foreignObject";
    if (y ? z(
      h.dynamicChildren,
      y,
      m,
      _,
      E,
      Q,
      M
    ) : O || S(
      h,
      g,
      m,
      null,
      _,
      E,
      Q,
      M,
      !1
    ), F > 0) {
      if (F & 16)
        J(
          m,
          g,
          P,
          U,
          _,
          E,
          x
        );
      else if (F & 2 && P.class !== U.class && o(m, "class", null, U.class, x), F & 4 && o(m, "style", P.style, U.style, x), F & 8) {
        const w = g.dynamicProps;
        for (let R = 0; R < w.length; R++) {
          const H = w[R], Y = P[H], pe = U[H];
          (pe !== Y || H === "value") && o(
            m,
            H,
            Y,
            pe,
            x,
            h.children,
            _,
            E,
            ge
          );
        }
      }
      F & 1 && h.children !== g.children && u(m, g.children);
    } else
      !O && y == null && J(
        m,
        g,
        P,
        U,
        _,
        E,
        x
      );
    ((K = U.onVnodeUpdated) || L) && Te(() => {
      K && Ge(K, _, g, h), L && gt(g, h, _, "updated");
    }, E);
  }, z = (h, g, _, E, x, M, O) => {
    for (let m = 0; m < g.length; m++) {
      const F = h[m], y = g[m], L = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        F.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (F.type === Re || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !yt(F, y) || // - In the case of a component, it could contain anything.
        F.shapeFlag & 70) ? f(F.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          _
        )
      );
      b(
        F,
        y,
        L,
        null,
        E,
        x,
        M,
        O,
        !0
      );
    }
  }, J = (h, g, _, E, x, M, O) => {
    if (_ !== E) {
      if (_ !== ue)
        for (const m in _)
          !Hn(m) && !(m in E) && o(
            h,
            m,
            _[m],
            null,
            O,
            g.children,
            x,
            M,
            ge
          );
      for (const m in E) {
        if (Hn(m))
          continue;
        const F = E[m], y = _[m];
        F !== y && m !== "value" && o(
          h,
          m,
          y,
          F,
          O,
          g.children,
          x,
          M,
          ge
        );
      }
      "value" in E && o(h, "value", _.value, E.value);
    }
  }, B = (h, g, _, E, x, M, O, m, F) => {
    const y = g.el = h ? h.el : i(""), L = g.anchor = h ? h.anchor : i("");
    let { patchFlag: P, dynamicChildren: U, slotScopeIds: K } = g;
    K && (m = m ? m.concat(K) : K), h == null ? (r(y, _, E), r(L, _, E), $(
      g.children,
      _,
      L,
      x,
      M,
      O,
      m,
      F
    )) : P > 0 && P & 64 && U && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    h.dynamicChildren ? (z(
      h.dynamicChildren,
      U,
      _,
      x,
      M,
      O,
      m
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (g.key != null || x && g === x.subTree) && yi(
      h,
      g,
      !0
      /* shallow */
    )) : S(
      h,
      g,
      _,
      L,
      x,
      M,
      O,
      m,
      F
    );
  }, re = (h, g, _, E, x, M, O, m, F) => {
    g.slotScopeIds = m, h == null ? g.shapeFlag & 512 ? x.ctx.activate(
      g,
      _,
      E,
      O,
      F
    ) : D(
      g,
      _,
      E,
      x,
      M,
      O,
      F
    ) : ne(h, g, F);
  }, D = (h, g, _, E, x, M, O) => {
    const m = h.component = gu(
      h,
      E,
      x
    );
    if (fr(h) && (m.ctx.renderer = Qe), _u(m), m.asyncDep) {
      if (x && x.registerDep(m, V), !h.el) {
        const F = m.subTree = de(Le);
        T(null, F, g, _);
      }
      return;
    }
    V(
      m,
      h,
      g,
      _,
      x,
      M,
      O
    );
  }, ne = (h, g, _) => {
    const E = g.component = h.component;
    if (Ca(h, g, _))
      if (E.asyncDep && !E.asyncResolved) {
        v(E, g, _);
        return;
      } else
        E.next = g, va(E.update), E.update();
    else
      g.el = h.el, E.vnode = g;
  }, V = (h, g, _, E, x, M, O) => {
    const m = () => {
      if (h.isMounted) {
        let { next: L, bu: P, u: U, parent: K, vnode: Q } = h, w = L, R;
        mt(h, !1), L ? (L.el = Q.el, v(h, L, O)) : L = Q, P && jn(P), (R = L.props && L.props.onVnodeBeforeUpdate) && Ge(R, K, L, Q), mt(h, !0);
        const H = Dr(h), Y = h.subTree;
        h.subTree = H, b(
          Y,
          H,
          // parent may have changed if it's in a teleport
          f(Y.el),
          // anchor may have changed if it's in a fragment
          ht(Y),
          h,
          x,
          M
        ), L.el = H.el, w === null && Aa(h, H.el), U && Te(U, x), (R = L.props && L.props.onVnodeUpdated) && Te(
          () => Ge(R, K, L, Q),
          x
        );
      } else {
        let L;
        const { el: P, props: U } = g, { bm: K, m: Q, parent: w } = h, R = pn(g);
        if (mt(h, !1), K && jn(K), !R && (L = U && U.onVnodeBeforeMount) && Ge(L, w, g), mt(h, !0), P && sn) {
          const H = () => {
            h.subTree = Dr(h), sn(
              P,
              h.subTree,
              h,
              x,
              null
            );
          };
          R ? g.type.__asyncLoader().then(
            // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            () => !h.isUnmounted && H()
          ) : H();
        } else {
          const H = h.subTree = Dr(h);
          b(
            null,
            H,
            _,
            E,
            h,
            x,
            M
          ), g.el = H.el;
        }
        if (Q && Te(Q, x), !R && (L = U && U.onVnodeMounted)) {
          const H = g;
          Te(
            () => Ge(L, w, H),
            x
          );
        }
        (g.shapeFlag & 256 || w && pn(w.vnode) && w.vnode.shapeFlag & 256) && h.a && Te(h.a, x), h.isMounted = !0, g = _ = E = null;
      }
    }, F = h.effect = new ys(
      m,
      () => Ts(y),
      h.scope
      // track it in component's effect scope
    ), y = h.update = () => F.run();
    y.id = h.uid, mt(h, !0), y();
  }, v = (h, g, _) => {
    g.component = h;
    const E = h.vnode.props;
    h.vnode = g, h.next = null, tu(h, g.props, E, _), su(h, g.children, _), Jt(), co(), Yt();
  }, S = (h, g, _, E, x, M, O, m, F = !1) => {
    const y = h && h.children, L = h ? h.shapeFlag : 0, P = g.children, { patchFlag: U, shapeFlag: K } = g;
    if (U > 0) {
      if (U & 128) {
        te(
          y,
          P,
          _,
          E,
          x,
          M,
          O,
          m,
          F
        );
        return;
      } else if (U & 256) {
        Z(
          y,
          P,
          _,
          E,
          x,
          M,
          O,
          m,
          F
        );
        return;
      }
    }
    K & 8 ? (L & 16 && ge(y, x, M), P !== y && u(_, P)) : L & 16 ? K & 16 ? te(
      y,
      P,
      _,
      E,
      x,
      M,
      O,
      m,
      F
    ) : ge(y, x, M, !0) : (L & 8 && u(_, ""), K & 16 && $(
      P,
      _,
      E,
      x,
      M,
      O,
      m,
      F
    ));
  }, Z = (h, g, _, E, x, M, O, m, F) => {
    h = h || Pt, g = g || Pt;
    const y = h.length, L = g.length, P = Math.min(y, L);
    let U;
    for (U = 0; U < P; U++) {
      const K = g[U] = F ? ct(g[U]) : Ze(g[U]);
      b(
        h[U],
        K,
        _,
        null,
        x,
        M,
        O,
        m,
        F
      );
    }
    y > L ? ge(
      h,
      x,
      M,
      !0,
      !1,
      P
    ) : $(
      g,
      _,
      E,
      x,
      M,
      O,
      m,
      F,
      P
    );
  }, te = (h, g, _, E, x, M, O, m, F) => {
    let y = 0;
    const L = g.length;
    let P = h.length - 1, U = L - 1;
    for (; y <= P && y <= U; ) {
      const K = h[y], Q = g[y] = F ? ct(g[y]) : Ze(g[y]);
      if (yt(K, Q))
        b(
          K,
          Q,
          _,
          null,
          x,
          M,
          O,
          m,
          F
        );
      else
        break;
      y++;
    }
    for (; y <= P && y <= U; ) {
      const K = h[P], Q = g[U] = F ? ct(g[U]) : Ze(g[U]);
      if (yt(K, Q))
        b(
          K,
          Q,
          _,
          null,
          x,
          M,
          O,
          m,
          F
        );
      else
        break;
      P--, U--;
    }
    if (y > P) {
      if (y <= U) {
        const K = U + 1, Q = K < L ? g[K].el : E;
        for (; y <= U; )
          b(
            null,
            g[y] = F ? ct(g[y]) : Ze(g[y]),
            _,
            Q,
            x,
            M,
            O,
            m,
            F
          ), y++;
      }
    } else if (y > U)
      for (; y <= P; )
        ae(h[y], x, M, !0), y++;
    else {
      const K = y, Q = y, w = /* @__PURE__ */ new Map();
      for (y = Q; y <= U; y++) {
        const Me = g[y] = F ? ct(g[y]) : Ze(g[y]);
        Me.key != null && w.set(Me.key, y);
      }
      let R, H = 0;
      const Y = U - Q + 1;
      let pe = !1, Ne = 0;
      const dt = new Array(Y);
      for (y = 0; y < Y; y++)
        dt[y] = 0;
      for (y = K; y <= P; y++) {
        const Me = h[y];
        if (H >= Y) {
          ae(Me, x, M, !0);
          continue;
        }
        let Ve;
        if (Me.key != null)
          Ve = w.get(Me.key);
        else
          for (R = Q; R <= U; R++)
            if (dt[R - Q] === 0 && yt(Me, g[R])) {
              Ve = R;
              break;
            }
        Ve === void 0 ? ae(Me, x, M, !0) : (dt[Ve - Q] = y + 1, Ve >= Ne ? Ne = Ve : pe = !0, b(
          Me,
          g[Ve],
          _,
          null,
          x,
          M,
          O,
          m,
          F
        ), H++);
      }
      const qn = pe ? iu(dt) : Pt;
      for (R = qn.length - 1, y = Y - 1; y >= 0; y--) {
        const Me = Q + y, Ve = g[Me], Ys = Me + 1 < L ? g[Me + 1].el : E;
        dt[y] === 0 ? b(
          null,
          Ve,
          _,
          Ys,
          x,
          M,
          O,
          m,
          F
        ) : pe && (R < 0 || y !== qn[R] ? ie(Ve, _, Ys, 2) : R--);
      }
    }
  }, ie = (h, g, _, E, x = null) => {
    const { el: M, type: O, transition: m, children: F, shapeFlag: y } = h;
    if (y & 6) {
      ie(h.component.subTree, g, _, E);
      return;
    }
    if (y & 128) {
      h.suspense.move(g, _, E);
      return;
    }
    if (y & 64) {
      O.move(h, g, _, Qe);
      return;
    }
    if (O === Re) {
      r(M, g, _);
      for (let P = 0; P < F.length; P++)
        ie(F[P], g, _, E);
      r(h.anchor, g, _);
      return;
    }
    if (O === Mr) {
      N(h, g, _);
      return;
    }
    if (E !== 2 && y & 1 && m)
      if (E === 0)
        m.beforeEnter(M), r(M, g, _), Te(() => m.enter(M), x);
      else {
        const { leave: P, delayLeave: U, afterLeave: K } = m, Q = () => r(M, g, _), w = () => {
          P(M, () => {
            Q(), K && K();
          });
        };
        U ? U(M, Q, w) : w();
      }
    else
      r(M, g, _);
  }, ae = (h, g, _, E = !1, x = !1) => {
    const {
      type: M,
      props: O,
      ref: m,
      children: F,
      dynamicChildren: y,
      shapeFlag: L,
      patchFlag: P,
      dirs: U
    } = h;
    if (m != null && us(m, null, _, h, !0), L & 256) {
      g.ctx.deactivate(h);
      return;
    }
    const K = L & 1 && U, Q = !pn(h);
    let w;
    if (Q && (w = O && O.onVnodeBeforeUnmount) && Ge(w, g, h), L & 6)
      Ce(h.component, _, E);
    else {
      if (L & 128) {
        h.suspense.unmount(_, E);
        return;
      }
      K && gt(h, null, g, "beforeUnmount"), L & 64 ? h.type.remove(
        h,
        g,
        _,
        x,
        Qe,
        E
      ) : y && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (M !== Re || P > 0 && P & 64) ? ge(
        y,
        g,
        _,
        !1,
        !0
      ) : (M === Re && P & 384 || !x && L & 16) && ge(F, g, _), E && De(h);
    }
    (Q && (w = O && O.onVnodeUnmounted) || K) && Te(() => {
      w && Ge(w, g, h), K && gt(h, null, g, "unmounted");
    }, _);
  }, De = (h) => {
    const { type: g, el: _, anchor: E, transition: x } = h;
    if (g === Re) {
      Nt(_, E);
      return;
    }
    if (g === Mr) {
      A(h);
      return;
    }
    const M = () => {
      s(_), x && !x.persisted && x.afterLeave && x.afterLeave();
    };
    if (h.shapeFlag & 1 && x && !x.persisted) {
      const { leave: O, delayLeave: m } = x, F = () => O(_, M);
      m ? m(h.el, M, F) : F();
    } else
      M();
  }, Nt = (h, g) => {
    let _;
    for (; h !== g; )
      _ = p(h), s(h), h = _;
    s(g);
  }, Ce = (h, g, _) => {
    const { bum: E, scope: x, update: M, subTree: O, um: m } = h;
    E && jn(E), x.stop(), M && (M.active = !1, ae(O, h, g, _)), m && Te(m, g), Te(() => {
      h.isUnmounted = !0;
    }, g), g && g.pendingBranch && !g.isUnmounted && h.asyncDep && !h.asyncResolved && h.suspenseId === g.pendingId && (g.deps--, g.deps === 0 && g.resolve());
  }, ge = (h, g, _, E = !1, x = !1, M = 0) => {
    for (let O = M; O < h.length; O++)
      ae(h[O], g, _, E, x);
  }, ht = (h) => h.shapeFlag & 6 ? ht(h.component.subTree) : h.shapeFlag & 128 ? h.suspense.next() : p(h.anchor || h.el), nn = (h, g, _) => {
    h == null ? g._vnode && ae(g._vnode, null, null, !0) : b(g._vnode || null, h, g, null, null, null, _), co(), ti(), g._vnode = h;
  }, Qe = {
    p: b,
    um: ae,
    m: ie,
    r: De,
    mt: D,
    mc: $,
    pc: S,
    pbc: z,
    n: ht,
    o: t
  };
  let rn, sn;
  return e && ([rn, sn] = e(
    Qe
  )), {
    render: nn,
    hydrate: rn,
    createApp: Xa(nn, rn)
  };
}
function mt({ effect: t, update: e }, n) {
  t.allowRecurse = e.allowRecurse = n;
}
function yi(t, e, n = !1) {
  const r = t.children, s = e.children;
  if (G(r) && G(s))
    for (let o = 0; o < r.length; o++) {
      const c = r[o];
      let i = s[o];
      i.shapeFlag & 1 && !i.dynamicChildren && ((i.patchFlag <= 0 || i.patchFlag === 32) && (i = s[o] = ct(s[o]), i.el = c.el), n || yi(c, i)), i.type === hr && (i.el = c.el);
    }
}
function iu(t) {
  const e = t.slice(), n = [0];
  let r, s, o, c, i;
  const l = t.length;
  for (r = 0; r < l; r++) {
    const a = t[r];
    if (a !== 0) {
      if (s = n[n.length - 1], t[s] < a) {
        e[r] = s, n.push(r);
        continue;
      }
      for (o = 0, c = n.length - 1; o < c; )
        i = o + c >> 1, t[n[i]] < a ? o = i + 1 : c = i;
      a < t[n[o]] && (o > 0 && (e[r] = n[o - 1]), n[o] = r);
    }
  }
  for (o = n.length, c = n[o - 1]; o-- > 0; )
    n[o] = c, c = e[c];
  return n;
}
const lu = (t) => t.__isTeleport, Re = Symbol.for("v-fgt"), hr = Symbol.for("v-txt"), Le = Symbol.for("v-cmt"), Mr = Symbol.for("v-stc"), gn = [];
let ze = null;
function oe(t = !1) {
  gn.push(ze = t ? null : []);
}
function au() {
  gn.pop(), ze = gn[gn.length - 1] || null;
}
let kn = 1;
function vo(t) {
  kn += t;
}
function ki(t) {
  return t.dynamicChildren = kn > 0 ? ze || Pt : null, au(), kn > 0 && ze && ze.push(t), t;
}
function be(t, e, n, r, s, o) {
  return ki(
    we(
      t,
      e,
      n,
      r,
      s,
      o,
      !0
      /* isBlock */
    )
  );
}
function Se(t, e, n, r, s) {
  return ki(
    de(
      t,
      e,
      n,
      r,
      s,
      !0
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function Qn(t) {
  return t ? t.__v_isVNode === !0 : !1;
}
function yt(t, e) {
  return t.type === e.type && t.key === e.key;
}
const dr = "__vInternal", Ei = ({ key: t }) => t ?? null, Vn = ({
  ref: t,
  ref_key: e,
  ref_for: n
}) => (typeof t == "number" && (t = "" + t), t != null ? _e(t) || ye(t) || ee(t) ? { i: Ee, r: t, k: e, f: !!n } : t : null);
function we(t, e = null, n = null, r = 0, s = null, o = t === Re ? 0 : 1, c = !1, i = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: e,
    key: e && Ei(e),
    ref: e && Vn(e),
    scopeId: si,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: r,
    dynamicProps: s,
    dynamicChildren: null,
    appContext: null,
    ctx: Ee
  };
  return i ? (Is(l, n), o & 128 && t.normalize(l)) : n && (l.shapeFlag |= _e(n) ? 8 : 16), kn > 0 && // avoid a block node from tracking itself
  !c && // has current parent block
  ze && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (l.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  l.patchFlag !== 32 && ze.push(l), l;
}
const de = uu;
function uu(t, e = null, n = null, r = 0, s = null, o = !1) {
  if ((!t || t === Ha) && (t = Le), Qn(t)) {
    const i = pt(
      t,
      e,
      !0
      /* mergeRef: true */
    );
    return n && Is(i, n), kn > 0 && !o && ze && (i.shapeFlag & 6 ? ze[ze.indexOf(t)] = i : ze.push(i)), i.patchFlag |= -2, i;
  }
  if (yu(t) && (t = t.__vccOpts), e) {
    e = fu(e);
    let { class: i, style: l } = e;
    i && !_e(i) && (e.class = Sn(i)), fe(l) && (Kc(l) && !G(l) && (l = me({}, l)), e.style = vs(l));
  }
  const c = _e(t) ? 1 : Sa(t) ? 128 : lu(t) ? 64 : fe(t) ? 4 : ee(t) ? 2 : 0;
  return we(
    t,
    e,
    n,
    r,
    s,
    c,
    o,
    !0
  );
}
function fu(t) {
  return t ? Kc(t) || dr in t ? me({}, t) : t : null;
}
function pt(t, e, n = !1) {
  const { props: r, ref: s, patchFlag: o, children: c } = t, i = e ? pu(r || {}, e) : r;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t.type,
    props: i,
    key: i && Ei(i),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      n && s ? G(s) ? s.concat(Vn(e)) : [s, Vn(e)] : Vn(e)
    ) : s,
    scopeId: t.scopeId,
    slotScopeIds: t.slotScopeIds,
    children: c,
    target: t.target,
    targetAnchor: t.targetAnchor,
    staticCount: t.staticCount,
    shapeFlag: t.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && t.type !== Re ? o === -1 ? 16 : o | 16 : o,
    dynamicProps: t.dynamicProps,
    dynamicChildren: t.dynamicChildren,
    appContext: t.appContext,
    dirs: t.dirs,
    transition: t.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: t.component,
    suspense: t.suspense,
    ssContent: t.ssContent && pt(t.ssContent),
    ssFallback: t.ssFallback && pt(t.ssFallback),
    el: t.el,
    anchor: t.anchor,
    ctx: t.ctx,
    ce: t.ce
  };
}
function Ns(t = " ", e = 0) {
  return de(hr, null, t, e);
}
function mn(t = "", e = !1) {
  return e ? (oe(), Se(Le, null, t)) : de(Le, null, t);
}
function Ze(t) {
  return t == null || typeof t == "boolean" ? de(Le) : G(t) ? de(
    Re,
    null,
    // #3666, avoid reference pollution when reusing vnode
    t.slice()
  ) : typeof t == "object" ? ct(t) : de(hr, null, String(t));
}
function ct(t) {
  return t.el === null && t.patchFlag !== -1 || t.memo ? t : pt(t);
}
function Is(t, e) {
  let n = 0;
  const { shapeFlag: r } = t;
  if (e == null)
    e = null;
  else if (G(e))
    n = 16;
  else if (typeof e == "object")
    if (r & 65) {
      const s = e.default;
      s && (s._c && (s._d = !1), Is(t, s()), s._c && (s._d = !0));
      return;
    } else {
      n = 32;
      const s = e._;
      !s && !(dr in e) ? e._ctx = Ee : s === 3 && Ee && (Ee.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024));
    }
  else
    ee(e) ? (e = { default: e, _ctx: Ee }, n = 32) : (e = String(e), r & 64 ? (n = 16, e = [Ns(e)]) : n = 8);
  t.children = e, t.shapeFlag |= n;
}
function pu(...t) {
  const e = {};
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    for (const s in r)
      if (s === "class")
        e.class !== r.class && (e.class = Sn([e.class, r.class]));
      else if (s === "style")
        e.style = vs([e.style, r.style]);
      else if (or(s)) {
        const o = e[s], c = r[s];
        c && o !== c && !(G(o) && o.includes(c)) && (e[s] = o ? [].concat(o, c) : c);
      } else
        s !== "" && (e[s] = r[s]);
  }
  return e;
}
function Ge(t, e, n, r = null) {
  Fe(t, e, 7, [
    n,
    r
  ]);
}
const hu = gi();
let du = 0;
function gu(t, e, n) {
  const r = t.type, s = (e ? e.appContext : t.appContext) || hu, o = {
    uid: du++,
    vnode: t,
    type: r,
    parent: e,
    appContext: s,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new Ml(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(s.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: _i(r, s),
    emitsOptions: ri(r, s),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: ue,
    // inheritAttrs
    inheritAttrs: r.inheritAttrs,
    // state
    ctx: ue,
    data: ue,
    props: ue,
    attrs: ue,
    slots: ue,
    refs: ue,
    setupState: ue,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return o.ctx = { _: o }, o.root = e ? e.root : o, o.emit = ka.bind(null, o), t.ce && t.ce(o), o;
}
let xe = null;
const mu = () => xe || Ee;
let Fs, It, xo = "__VUE_INSTANCE_SETTERS__";
(It = Qr()[xo]) || (It = Qr()[xo] = []), It.push((t) => xe = t), Fs = (t) => {
  It.length > 1 ? It.forEach((e) => e(t)) : It[0](t);
};
const Kt = (t) => {
  Fs(t), t.scope.on();
}, St = () => {
  xe && xe.scope.off(), Fs(null);
};
function wi(t) {
  return t.vnode.shapeFlag & 4;
}
let En = !1;
function _u(t, e = !1) {
  En = e;
  const { props: n, children: r } = t.vnode, s = wi(t);
  eu(t, n, s, e), ru(t, r);
  const o = s ? bu(t, e) : void 0;
  return En = !1, o;
}
function bu(t, e) {
  const n = t.type;
  t.accessCache = /* @__PURE__ */ Object.create(null), t.proxy = Wc(new Proxy(t.ctx, Va));
  const { setup: r } = n;
  if (r) {
    const s = t.setupContext = r.length > 1 ? xu(t) : null;
    Kt(t), Jt();
    const o = at(
      r,
      t,
      0,
      [t.props, s]
    );
    if (Yt(), St(), qc(o)) {
      if (o.then(St, St), e)
        return o.then((c) => {
          yo(t, c, e);
        }).catch((c) => {
          ar(c, t, 0);
        });
      t.asyncDep = o;
    } else
      yo(t, o, e);
  } else
    Ci(t, e);
}
function yo(t, e, n) {
  ee(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : fe(e) && (t.setupState = Xc(e)), Ci(t, n);
}
let ko;
function Ci(t, e, n) {
  const r = t.type;
  if (!t.render) {
    if (!e && ko && !r.render) {
      const s = r.template || qs(t).template;
      if (s) {
        const { isCustomElement: o, compilerOptions: c } = t.appContext.config, { delimiters: i, compilerOptions: l } = r, a = me(
          me(
            {
              isCustomElement: o,
              delimiters: i
            },
            c
          ),
          l
        );
        r.render = ko(s, a);
      }
    }
    t.render = r.render || Ue;
  }
  Kt(t), Jt(), Ga(t), Yt(), St();
}
function vu(t) {
  return t.attrsProxy || (t.attrsProxy = new Proxy(
    t.attrs,
    {
      get(e, n) {
        return qe(t, "get", "$attrs"), e[n];
      }
    }
  ));
}
function xu(t) {
  const e = (n) => {
    t.exposed = n || {};
  };
  return {
    get attrs() {
      return vu(t);
    },
    slots: t.slots,
    emit: t.emit,
    expose: e
  };
}
function gr(t) {
  if (t.exposed)
    return t.exposeProxy || (t.exposeProxy = new Proxy(Xc(Wc(t.exposed)), {
      get(e, n) {
        if (n in e)
          return e[n];
        if (n in dn)
          return dn[n](t);
      },
      has(e, n) {
        return n in e || n in dn;
      }
    }));
}
function yu(t) {
  return ee(t) && "__vccOpts" in t;
}
const Xt = (t, e) => ma(t, e, En);
function Ai(t, e, n) {
  const r = arguments.length;
  return r === 2 ? fe(e) && !G(e) ? Qn(e) ? de(t, null, [e]) : de(t, e) : de(t, null, e) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && Qn(n) && (n = [n]), de(t, e, n));
}
const ku = Symbol.for("v-scx"), Eu = () => Ht(ku), wu = "3.3.4", Cu = "http://www.w3.org/2000/svg", kt = typeof document < "u" ? document : null, Eo = kt && /* @__PURE__ */ kt.createElement("template"), Au = {
  insert: (t, e, n) => {
    e.insertBefore(t, n || null);
  },
  remove: (t) => {
    const e = t.parentNode;
    e && e.removeChild(t);
  },
  createElement: (t, e, n, r) => {
    const s = e ? kt.createElementNS(Cu, t) : kt.createElement(t, n ? { is: n } : void 0);
    return t === "select" && r && r.multiple != null && s.setAttribute("multiple", r.multiple), s;
  },
  createText: (t) => kt.createTextNode(t),
  createComment: (t) => kt.createComment(t),
  setText: (t, e) => {
    t.nodeValue = e;
  },
  setElementText: (t, e) => {
    t.textContent = e;
  },
  parentNode: (t) => t.parentNode,
  nextSibling: (t) => t.nextSibling,
  querySelector: (t) => kt.querySelector(t),
  setScopeId(t, e) {
    t.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(t, e, n, r, s, o) {
    const c = n ? n.previousSibling : e.lastChild;
    if (s && (s === o || s.nextSibling))
      for (; e.insertBefore(s.cloneNode(!0), n), !(s === o || !(s = s.nextSibling)); )
        ;
    else {
      Eo.innerHTML = r ? `<svg>${t}</svg>` : t;
      const i = Eo.content;
      if (r) {
        const l = i.firstChild;
        for (; l.firstChild; )
          i.appendChild(l.firstChild);
        i.removeChild(l);
      }
      e.insertBefore(i, n);
    }
    return [
      // first
      c ? c.nextSibling : e.firstChild,
      // last
      n ? n.previousSibling : e.lastChild
    ];
  }
};
function Su(t, e, n) {
  const r = t._vtc;
  r && (e = (e ? [e, ...r] : [...r]).join(" ")), e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e;
}
function Du(t, e, n) {
  const r = t.style, s = _e(n);
  if (n && !s) {
    if (e && !_e(e))
      for (const o in e)
        n[o] == null && fs(r, o, "");
    for (const o in n)
      fs(r, o, n[o]);
  } else {
    const o = r.display;
    s ? e !== n && (r.cssText = n) : e && t.removeAttribute("style"), "_vod" in t && (r.display = o);
  }
}
const wo = /\s*!important$/;
function fs(t, e, n) {
  if (G(n))
    n.forEach((r) => fs(t, e, r));
  else if (n == null && (n = ""), e.startsWith("--"))
    t.setProperty(e, n);
  else {
    const r = Tu(t, e);
    wo.test(n) ? t.setProperty(
      qt(r),
      n.replace(wo, ""),
      "important"
    ) : t[r] = n;
  }
}
const Co = ["Webkit", "Moz", "ms"], Nr = {};
function Tu(t, e) {
  const n = Nr[e];
  if (n)
    return n;
  let r = Vt(e);
  if (r !== "filter" && r in t)
    return Nr[e] = r;
  r = Ic(r);
  for (let s = 0; s < Co.length; s++) {
    const o = Co[s] + r;
    if (o in t)
      return Nr[e] = o;
  }
  return e;
}
const Ao = "http://www.w3.org/1999/xlink";
function Ru(t, e, n, r, s) {
  if (r && e.startsWith("xlink:"))
    n == null ? t.removeAttributeNS(Ao, e.slice(6, e.length)) : t.setAttributeNS(Ao, e, n);
  else {
    const o = ql(e);
    n == null || o && !Fc(n) ? t.removeAttribute(e) : t.setAttribute(e, o ? "" : n);
  }
}
function qu(t, e, n, r, s, o, c) {
  if (e === "innerHTML" || e === "textContent") {
    r && c(r, s, o), t[e] = n ?? "";
    return;
  }
  const i = t.tagName;
  if (e === "value" && i !== "PROGRESS" && // custom elements may use _value internally
  !i.includes("-")) {
    t._value = n;
    const a = i === "OPTION" ? t.getAttribute("value") : t.value, u = n ?? "";
    a !== u && (t.value = u), n == null && t.removeAttribute(e);
    return;
  }
  let l = !1;
  if (n === "" || n == null) {
    const a = typeof t[e];
    a === "boolean" ? n = Fc(n) : n == null && a === "string" ? (n = "", l = !0) : a === "number" && (n = 0, l = !0);
  }
  try {
    t[e] = n;
  } catch {
  }
  l && t.removeAttribute(e);
}
function Ot(t, e, n, r) {
  t.addEventListener(e, n, r);
}
function Mu(t, e, n, r) {
  t.removeEventListener(e, n, r);
}
function Nu(t, e, n, r, s = null) {
  const o = t._vei || (t._vei = {}), c = o[e];
  if (r && c)
    c.value = r;
  else {
    const [i, l] = Iu(e);
    if (r) {
      const a = o[e] = Ou(r, s);
      Ot(t, i, a, l);
    } else
      c && (Mu(t, i, c, l), o[e] = void 0);
  }
}
const So = /(?:Once|Passive|Capture)$/;
function Iu(t) {
  let e;
  if (So.test(t)) {
    e = {};
    let r;
    for (; r = t.match(So); )
      t = t.slice(0, t.length - r[0].length), e[r[0].toLowerCase()] = !0;
  }
  return [t[2] === ":" ? t.slice(3) : qt(t.slice(2)), e];
}
let Ir = 0;
const Fu = /* @__PURE__ */ Promise.resolve(), Lu = () => Ir || (Fu.then(() => Ir = 0), Ir = Date.now());
function Ou(t, e) {
  const n = (r) => {
    if (!r._vts)
      r._vts = Date.now();
    else if (r._vts <= n.attached)
      return;
    Fe(
      Pu(r, n.value),
      e,
      5,
      [r]
    );
  };
  return n.value = t, n.attached = Lu(), n;
}
function Pu(t, e) {
  if (G(e)) {
    const n = t.stopImmediatePropagation;
    return t.stopImmediatePropagation = () => {
      n.call(t), t._stopped = !0;
    }, e.map((r) => (s) => !s._stopped && r && r(s));
  } else
    return e;
}
const Do = /^on[a-z]/, Bu = (t, e, n, r, s = !1, o, c, i, l) => {
  e === "class" ? Su(t, r, s) : e === "style" ? Du(t, n, r) : or(e) ? gs(e) || Nu(t, e, n, r, c) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : $u(t, e, r, s)) ? qu(
    t,
    e,
    r,
    o,
    c,
    i,
    l
  ) : (e === "true-value" ? t._trueValue = r : e === "false-value" && (t._falseValue = r), Ru(t, e, r, s));
};
function $u(t, e, n, r) {
  return r ? !!(e === "innerHTML" || e === "textContent" || e in t && Do.test(e) && ee(n)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA" || Do.test(e) && _e(n) ? !1 : e in t;
}
const st = "transition", on = "animation", er = (t, { slots: e }) => Ai(Ma, zu(t), e);
er.displayName = "Transition";
const Si = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
er.props = /* @__PURE__ */ me(
  {},
  li,
  Si
);
const _t = (t, e = []) => {
  G(t) ? t.forEach((n) => n(...e)) : t && t(...e);
}, To = (t) => t ? G(t) ? t.some((e) => e.length > 1) : t.length > 1 : !1;
function zu(t) {
  const e = {};
  for (const B in t)
    B in Si || (e[B] = t[B]);
  if (t.css === !1)
    return e;
  const {
    name: n = "v",
    type: r,
    duration: s,
    enterFromClass: o = `${n}-enter-from`,
    enterActiveClass: c = `${n}-enter-active`,
    enterToClass: i = `${n}-enter-to`,
    appearFromClass: l = o,
    appearActiveClass: a = c,
    appearToClass: u = i,
    leaveFromClass: f = `${n}-leave-from`,
    leaveActiveClass: p = `${n}-leave-active`,
    leaveToClass: d = `${n}-leave-to`
  } = t, k = Uu(s), b = k && k[0], I = k && k[1], {
    onBeforeEnter: T,
    onEnter: C,
    onEnterCancelled: N,
    onLeave: A,
    onLeaveCancelled: j,
    onBeforeAppear: q = T,
    onAppear: W = C,
    onAppearCancelled: $ = N
  } = e, X = (B, re, D) => {
    bt(B, re ? u : i), bt(B, re ? a : c), D && D();
  }, z = (B, re) => {
    B._isLeaving = !1, bt(B, f), bt(B, d), bt(B, p), re && re();
  }, J = (B) => (re, D) => {
    const ne = B ? W : C, V = () => X(re, B, D);
    _t(ne, [re, V]), Ro(() => {
      bt(re, B ? l : o), ot(re, B ? u : i), To(ne) || qo(re, r, b, V);
    });
  };
  return me(e, {
    onBeforeEnter(B) {
      _t(T, [B]), ot(B, o), ot(B, c);
    },
    onBeforeAppear(B) {
      _t(q, [B]), ot(B, l), ot(B, a);
    },
    onEnter: J(!1),
    onAppear: J(!0),
    onLeave(B, re) {
      B._isLeaving = !0;
      const D = () => z(B, re);
      ot(B, f), Vu(), ot(B, p), Ro(() => {
        B._isLeaving && (bt(B, f), ot(B, d), To(A) || qo(B, r, I, D));
      }), _t(A, [B, D]);
    },
    onEnterCancelled(B) {
      X(B, !1), _t(N, [B]);
    },
    onAppearCancelled(B) {
      X(B, !0), _t($, [B]);
    },
    onLeaveCancelled(B) {
      z(B), _t(j, [B]);
    }
  });
}
function Uu(t) {
  if (t == null)
    return null;
  if (fe(t))
    return [Fr(t.enter), Fr(t.leave)];
  {
    const e = Fr(t);
    return [e, e];
  }
}
function Fr(t) {
  return Cl(t);
}
function ot(t, e) {
  e.split(/\s+/).forEach((n) => n && t.classList.add(n)), (t._vtc || (t._vtc = /* @__PURE__ */ new Set())).add(e);
}
function bt(t, e) {
  e.split(/\s+/).forEach((r) => r && t.classList.remove(r));
  const { _vtc: n } = t;
  n && (n.delete(e), n.size || (t._vtc = void 0));
}
function Ro(t) {
  requestAnimationFrame(() => {
    requestAnimationFrame(t);
  });
}
let Hu = 0;
function qo(t, e, n, r) {
  const s = t._endId = ++Hu, o = () => {
    s === t._endId && r();
  };
  if (n)
    return setTimeout(o, n);
  const { type: c, timeout: i, propCount: l } = ju(t, e);
  if (!c)
    return r();
  const a = c + "end";
  let u = 0;
  const f = () => {
    t.removeEventListener(a, p), o();
  }, p = (d) => {
    d.target === t && ++u >= l && f();
  };
  setTimeout(() => {
    u < l && f();
  }, i + 1), t.addEventListener(a, p);
}
function ju(t, e) {
  const n = window.getComputedStyle(t), r = (k) => (n[k] || "").split(", "), s = r(`${st}Delay`), o = r(`${st}Duration`), c = Mo(s, o), i = r(`${on}Delay`), l = r(`${on}Duration`), a = Mo(i, l);
  let u = null, f = 0, p = 0;
  e === st ? c > 0 && (u = st, f = c, p = o.length) : e === on ? a > 0 && (u = on, f = a, p = l.length) : (f = Math.max(c, a), u = f > 0 ? c > a ? st : on : null, p = u ? u === st ? o.length : l.length : 0);
  const d = u === st && /\b(transform|all)(,|$)/.test(
    r(`${st}Property`).toString()
  );
  return {
    type: u,
    timeout: f,
    propCount: p,
    hasTransform: d
  };
}
function Mo(t, e) {
  for (; t.length < e.length; )
    t = t.concat(t);
  return Math.max(...e.map((n, r) => No(n) + No(t[r])));
}
function No(t) {
  return Number(t.slice(0, -1).replace(",", ".")) * 1e3;
}
function Vu() {
  return document.body.offsetHeight;
}
const Io = (t) => {
  const e = t.props["onUpdate:modelValue"] || !1;
  return G(e) ? (n) => jn(e, n) : e;
};
function Gu(t) {
  t.target.composing = !0;
}
function Fo(t) {
  const e = t.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const Zu = {
  created(t, { modifiers: { lazy: e, trim: n, number: r } }, s) {
    t._assign = Io(s);
    const o = r || s.props && s.props.type === "number";
    Ot(t, e ? "change" : "input", (c) => {
      if (c.target.composing)
        return;
      let i = t.value;
      n && (i = i.trim()), o && (i = Xr(i)), t._assign(i);
    }), n && Ot(t, "change", () => {
      t.value = t.value.trim();
    }), e || (Ot(t, "compositionstart", Gu), Ot(t, "compositionend", Fo), Ot(t, "change", Fo));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(t, { value: e }) {
    t.value = e ?? "";
  },
  beforeUpdate(t, { value: e, modifiers: { lazy: n, trim: r, number: s } }, o) {
    if (t._assign = Io(o), t.composing || document.activeElement === t && t.type !== "range" && (n || r && t.value.trim() === e || (s || t.type === "number") && Xr(t.value) === e))
      return;
    const c = e ?? "";
    t.value !== c && (t.value = c);
  }
}, Ku = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, Wu = (t, e) => (n) => {
  if (!("key" in n))
    return;
  const r = qt(n.key);
  if (e.some((s) => s === r || Ku[s] === r))
    return t(n);
}, Ju = {
  beforeMount(t, { value: e }, { transition: n }) {
    t._vod = t.style.display === "none" ? "" : t.style.display, n && e ? n.beforeEnter(t) : cn(t, e);
  },
  mounted(t, { value: e }, { transition: n }) {
    n && e && n.enter(t);
  },
  updated(t, { value: e, oldValue: n }, { transition: r }) {
    !e != !n && (r ? e ? (r.beforeEnter(t), cn(t, !0), r.enter(t)) : r.leave(t, () => {
      cn(t, !1);
    }) : cn(t, e));
  },
  beforeUnmount(t, { value: e }) {
    cn(t, e);
  }
};
function cn(t, e) {
  t.style.display = e ? t._vod : "none";
}
const Yu = /* @__PURE__ */ me({ patchProp: Bu }, Au);
let Lo;
function Xu() {
  return Lo || (Lo = ou(Yu));
}
const Qu = (...t) => {
  const e = Xu().createApp(...t), { mount: n } = e;
  return e.mount = (r) => {
    const s = ef(r);
    if (!s)
      return;
    const o = e._component;
    !ee(o) && !o.render && !o.template && (o.template = s.innerHTML), s.innerHTML = "";
    const c = n(s, !1, s instanceof SVGElement);
    return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), c;
  }, e;
};
function ef(t) {
  return _e(t) ? document.querySelector(t) : t;
}
const Di = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [r, s] of e)
    n[r] = s;
  return n;
}, tf = {}, nf = { class: "chat-button" };
function rf(t, e) {
  return oe(), be("button", nf, [
    hn(t.$slots, "default")
  ]);
}
const sf = /* @__PURE__ */ Di(tf, [["render", rf]]);
function of() {
  const t = /* @__PURE__ */ new Map();
  function e(s, o) {
    const c = t.get(s);
    c && c.splice(c.indexOf(o) >>> 0, 1);
  }
  function n(s, o) {
    let c = t.get(s);
    return c ? c.push(o) : c = [o], t.set(s, c), () => e(s, o);
  }
  function r(s, o) {
    const c = t.get(s);
    c && c.slice().forEach(async (i) => {
      await i(o);
    });
  }
  return {
    on: n,
    off: e,
    emit: r
  };
}
function cf(t) {
  if (!document.querySelector(t)) {
    const n = document.createElement("div");
    t.startsWith("#") && (n.id = t.replace("#", "")), t.startsWith(".") && n.classList.add(t.replace(".", "")), document.body.appendChild(n);
  }
}
const Tt = of(), lf = { class: "chat-layout" }, af = {
  key: 0,
  class: "chat-header"
}, uf = {
  key: 2,
  class: "chat-footer"
}, ff = /* @__PURE__ */ He({
  __name: "Layout",
  setup(t) {
    const e = zt(null);
    function n() {
      const r = e.value;
      r && (r.scrollTop = r.scrollHeight);
    }
    return Dn(() => {
      Tt.on("scrollToBottom", n), window.addEventListener("resize", n);
    }), Rs(() => {
      Tt.off("scrollToBottom", n), window.removeEventListener("resize", n);
    }), (r, s) => (oe(), be("main", lf, [
      r.$slots.header ? (oe(), be("div", af, [
        hn(r.$slots, "header")
      ])) : mn("", !0),
      r.$slots.default ? (oe(), be("div", {
        key: 1,
        class: "chat-body",
        ref_key: "chatBodyRef",
        ref: e
      }, [
        hn(r.$slots, "default")
      ], 512)) : mn("", !0),
      r.$slots.footer ? (oe(), be("div", uf, [
        hn(r.$slots, "footer")
      ])) : mn("", !0)
    ]));
  }
});
const ln = {
  webhookUrl: "http://localhost:5678",
  webhookConfig: {
    method: "POST",
    headers: {}
  },
  target: "#n8n-chat",
  mode: "window",
  defaultLanguage: "en",
  initialMessages: ["Hi there! 👋", "My name is Nathan. How can I assist you today?"],
  i18n: {
    en: {
      title: "Hi there! 👋",
      subtitle: "Start a chat. We're here to help you 24/7.",
      footer: "",
      getStarted: "New Conversation",
      inputPlaceholder: "Type your question.."
    }
  },
  theme: {}
}, pf = "#n8n-chat", hf = "n8n-chat", Oo = `${hf}/sessionId`, Ti = "Chat", Ri = "ChatOptions";
function Ls() {
  return Ht(Ti);
}
function qi() {
  return {
    options: Ht(Ri)
  };
}
function mr() {
  const { options: t } = qi(), e = (t == null ? void 0 : t.defaultLanguage) ?? "en";
  function n(s) {
    var o, c;
    return ((c = (o = t == null ? void 0 : t.i18n) == null ? void 0 : o[e]) == null ? void 0 : c[s]) ?? s;
  }
  function r(s) {
    var o, c;
    return !!((c = (o = t == null ? void 0 : t.i18n) == null ? void 0 : o[e]) != null && c[s]);
  }
  return { t: n, te: r };
}
const df = { class: "chat-get-started" }, gf = /* @__PURE__ */ He({
  __name: "GetStarted",
  setup(t) {
    const { t: e } = mr();
    return (n, r) => (oe(), be("div", df, [
      de(sf, {
        onClick: r[0] || (r[0] = (s) => n.$emit("click:button"))
      }, {
        default: ut(() => [
          Ns(Zn(he(e)("getStarted")), 1)
        ]),
        _: 1
      })
    ]));
  }
});
const mf = {}, _f = { class: "chat-powered-by" }, bf = /* @__PURE__ */ we("a", { href: "https://n8n.io?utm_source=n8n-external&utm_medium=widget-powered-by" }, "n8n", -1);
function vf(t, e) {
  return oe(), be("div", _f, [
    Ns(" Powered by "),
    bf
  ]);
}
const xf = /* @__PURE__ */ Di(mf, [["render", vf]]), yf = { class: "chat-get-started-footer" }, kf = { key: 0 }, Ef = /* @__PURE__ */ He({
  __name: "GetStartedFooter",
  setup(t) {
    const { t: e, te: n } = mr();
    return (r, s) => (oe(), be("div", yf, [
      he(n)("footer") ? (oe(), be("div", kf, Zn(he(e)("footer")), 1)) : mn("", !0),
      de(xf)
    ]));
  }
});
function Mi(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function wf(t) {
  if (t.__esModule)
    return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var s = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, s.get ? s : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
var le = {};
const Cf = "Á", Af = "á", Sf = "Ă", Df = "ă", Tf = "∾", Rf = "∿", qf = "∾̳", Mf = "Â", Nf = "â", If = "´", Ff = "А", Lf = "а", Of = "Æ", Pf = "æ", Bf = "⁡", $f = "𝔄", zf = "𝔞", Uf = "À", Hf = "à", jf = "ℵ", Vf = "ℵ", Gf = "Α", Zf = "α", Kf = "Ā", Wf = "ā", Jf = "⨿", Yf = "&", Xf = "&", Qf = "⩕", ep = "⩓", tp = "∧", np = "⩜", rp = "⩘", sp = "⩚", op = "∠", cp = "⦤", ip = "∠", lp = "⦨", ap = "⦩", up = "⦪", fp = "⦫", pp = "⦬", hp = "⦭", dp = "⦮", gp = "⦯", mp = "∡", _p = "∟", bp = "⊾", vp = "⦝", xp = "∢", yp = "Å", kp = "⍼", Ep = "Ą", wp = "ą", Cp = "𝔸", Ap = "𝕒", Sp = "⩯", Dp = "≈", Tp = "⩰", Rp = "≊", qp = "≋", Mp = "'", Np = "⁡", Ip = "≈", Fp = "≊", Lp = "Å", Op = "å", Pp = "𝒜", Bp = "𝒶", $p = "≔", zp = "*", Up = "≈", Hp = "≍", jp = "Ã", Vp = "ã", Gp = "Ä", Zp = "ä", Kp = "∳", Wp = "⨑", Jp = "≌", Yp = "϶", Xp = "‵", Qp = "∽", eh = "⋍", th = "∖", nh = "⫧", rh = "⊽", sh = "⌅", oh = "⌆", ch = "⌅", ih = "⎵", lh = "⎶", ah = "≌", uh = "Б", fh = "б", ph = "„", hh = "∵", dh = "∵", gh = "∵", mh = "⦰", _h = "϶", bh = "ℬ", vh = "ℬ", xh = "Β", yh = "β", kh = "ℶ", Eh = "≬", wh = "𝔅", Ch = "𝔟", Ah = "⋂", Sh = "◯", Dh = "⋃", Th = "⨀", Rh = "⨁", qh = "⨂", Mh = "⨆", Nh = "★", Ih = "▽", Fh = "△", Lh = "⨄", Oh = "⋁", Ph = "⋀", Bh = "⤍", $h = "⧫", zh = "▪", Uh = "▴", Hh = "▾", jh = "◂", Vh = "▸", Gh = "␣", Zh = "▒", Kh = "░", Wh = "▓", Jh = "█", Yh = "=⃥", Xh = "≡⃥", Qh = "⫭", ed = "⌐", td = "𝔹", nd = "𝕓", rd = "⊥", sd = "⊥", od = "⋈", cd = "⧉", id = "┐", ld = "╕", ad = "╖", ud = "╗", fd = "┌", pd = "╒", hd = "╓", dd = "╔", gd = "─", md = "═", _d = "┬", bd = "╤", vd = "╥", xd = "╦", yd = "┴", kd = "╧", Ed = "╨", wd = "╩", Cd = "⊟", Ad = "⊞", Sd = "⊠", Dd = "┘", Td = "╛", Rd = "╜", qd = "╝", Md = "└", Nd = "╘", Id = "╙", Fd = "╚", Ld = "│", Od = "║", Pd = "┼", Bd = "╪", $d = "╫", zd = "╬", Ud = "┤", Hd = "╡", jd = "╢", Vd = "╣", Gd = "├", Zd = "╞", Kd = "╟", Wd = "╠", Jd = "‵", Yd = "˘", Xd = "˘", Qd = "¦", eg = "𝒷", tg = "ℬ", ng = "⁏", rg = "∽", sg = "⋍", og = "⧅", cg = "\\", ig = "⟈", lg = "•", ag = "•", ug = "≎", fg = "⪮", pg = "≏", hg = "≎", dg = "≏", gg = "Ć", mg = "ć", _g = "⩄", bg = "⩉", vg = "⩋", xg = "∩", yg = "⋒", kg = "⩇", Eg = "⩀", wg = "ⅅ", Cg = "∩︀", Ag = "⁁", Sg = "ˇ", Dg = "ℭ", Tg = "⩍", Rg = "Č", qg = "č", Mg = "Ç", Ng = "ç", Ig = "Ĉ", Fg = "ĉ", Lg = "∰", Og = "⩌", Pg = "⩐", Bg = "Ċ", $g = "ċ", zg = "¸", Ug = "¸", Hg = "⦲", jg = "¢", Vg = "·", Gg = "·", Zg = "𝔠", Kg = "ℭ", Wg = "Ч", Jg = "ч", Yg = "✓", Xg = "✓", Qg = "Χ", em = "χ", tm = "ˆ", nm = "≗", rm = "↺", sm = "↻", om = "⊛", cm = "⊚", im = "⊝", lm = "⊙", am = "®", um = "Ⓢ", fm = "⊖", pm = "⊕", hm = "⊗", dm = "○", gm = "⧃", mm = "≗", _m = "⨐", bm = "⫯", vm = "⧂", xm = "∲", ym = "”", km = "’", Em = "♣", wm = "♣", Cm = ":", Am = "∷", Sm = "⩴", Dm = "≔", Tm = "≔", Rm = ",", qm = "@", Mm = "∁", Nm = "∘", Im = "∁", Fm = "ℂ", Lm = "≅", Om = "⩭", Pm = "≡", Bm = "∮", $m = "∯", zm = "∮", Um = "𝕔", Hm = "ℂ", jm = "∐", Vm = "∐", Gm = "©", Zm = "©", Km = "℗", Wm = "∳", Jm = "↵", Ym = "✗", Xm = "⨯", Qm = "𝒞", e_ = "𝒸", t_ = "⫏", n_ = "⫑", r_ = "⫐", s_ = "⫒", o_ = "⋯", c_ = "⤸", i_ = "⤵", l_ = "⋞", a_ = "⋟", u_ = "↶", f_ = "⤽", p_ = "⩈", h_ = "⩆", d_ = "≍", g_ = "∪", m_ = "⋓", __ = "⩊", b_ = "⊍", v_ = "⩅", x_ = "∪︀", y_ = "↷", k_ = "⤼", E_ = "⋞", w_ = "⋟", C_ = "⋎", A_ = "⋏", S_ = "¤", D_ = "↶", T_ = "↷", R_ = "⋎", q_ = "⋏", M_ = "∲", N_ = "∱", I_ = "⌭", F_ = "†", L_ = "‡", O_ = "ℸ", P_ = "↓", B_ = "↡", $_ = "⇓", z_ = "‐", U_ = "⫤", H_ = "⊣", j_ = "⤏", V_ = "˝", G_ = "Ď", Z_ = "ď", K_ = "Д", W_ = "д", J_ = "‡", Y_ = "⇊", X_ = "ⅅ", Q_ = "ⅆ", eb = "⤑", tb = "⩷", nb = "°", rb = "∇", sb = "Δ", ob = "δ", cb = "⦱", ib = "⥿", lb = "𝔇", ab = "𝔡", ub = "⥥", fb = "⇃", pb = "⇂", hb = "´", db = "˙", gb = "˝", mb = "`", _b = "˜", bb = "⋄", vb = "⋄", xb = "⋄", yb = "♦", kb = "♦", Eb = "¨", wb = "ⅆ", Cb = "ϝ", Ab = "⋲", Sb = "÷", Db = "÷", Tb = "⋇", Rb = "⋇", qb = "Ђ", Mb = "ђ", Nb = "⌞", Ib = "⌍", Fb = "$", Lb = "𝔻", Ob = "𝕕", Pb = "¨", Bb = "˙", $b = "⃜", zb = "≐", Ub = "≑", Hb = "≐", jb = "∸", Vb = "∔", Gb = "⊡", Zb = "⌆", Kb = "∯", Wb = "¨", Jb = "⇓", Yb = "⇐", Xb = "⇔", Qb = "⫤", e0 = "⟸", t0 = "⟺", n0 = "⟹", r0 = "⇒", s0 = "⊨", o0 = "⇑", c0 = "⇕", i0 = "∥", l0 = "⤓", a0 = "↓", u0 = "↓", f0 = "⇓", p0 = "⇵", h0 = "̑", d0 = "⇊", g0 = "⇃", m0 = "⇂", _0 = "⥐", b0 = "⥞", v0 = "⥖", x0 = "↽", y0 = "⥟", k0 = "⥗", E0 = "⇁", w0 = "↧", C0 = "⊤", A0 = "⤐", S0 = "⌟", D0 = "⌌", T0 = "𝒟", R0 = "𝒹", q0 = "Ѕ", M0 = "ѕ", N0 = "⧶", I0 = "Đ", F0 = "đ", L0 = "⋱", O0 = "▿", P0 = "▾", B0 = "⇵", $0 = "⥯", z0 = "⦦", U0 = "Џ", H0 = "џ", j0 = "⟿", V0 = "É", G0 = "é", Z0 = "⩮", K0 = "Ě", W0 = "ě", J0 = "Ê", Y0 = "ê", X0 = "≖", Q0 = "≕", ev = "Э", tv = "э", nv = "⩷", rv = "Ė", sv = "ė", ov = "≑", cv = "ⅇ", iv = "≒", lv = "𝔈", av = "𝔢", uv = "⪚", fv = "È", pv = "è", hv = "⪖", dv = "⪘", gv = "⪙", mv = "∈", _v = "⏧", bv = "ℓ", vv = "⪕", xv = "⪗", yv = "Ē", kv = "ē", Ev = "∅", wv = "∅", Cv = "◻", Av = "∅", Sv = "▫", Dv = " ", Tv = " ", Rv = " ", qv = "Ŋ", Mv = "ŋ", Nv = " ", Iv = "Ę", Fv = "ę", Lv = "𝔼", Ov = "𝕖", Pv = "⋕", Bv = "⧣", $v = "⩱", zv = "ε", Uv = "Ε", Hv = "ε", jv = "ϵ", Vv = "≖", Gv = "≕", Zv = "≂", Kv = "⪖", Wv = "⪕", Jv = "⩵", Yv = "=", Xv = "≂", Qv = "≟", ex = "⇌", tx = "≡", nx = "⩸", rx = "⧥", sx = "⥱", ox = "≓", cx = "ℯ", ix = "ℰ", lx = "≐", ax = "⩳", ux = "≂", fx = "Η", px = "η", hx = "Ð", dx = "ð", gx = "Ë", mx = "ë", _x = "€", bx = "!", vx = "∃", xx = "∃", yx = "ℰ", kx = "ⅇ", Ex = "ⅇ", wx = "≒", Cx = "Ф", Ax = "ф", Sx = "♀", Dx = "ﬃ", Tx = "ﬀ", Rx = "ﬄ", qx = "𝔉", Mx = "𝔣", Nx = "ﬁ", Ix = "◼", Fx = "▪", Lx = "fj", Ox = "♭", Px = "ﬂ", Bx = "▱", $x = "ƒ", zx = "𝔽", Ux = "𝕗", Hx = "∀", jx = "∀", Vx = "⋔", Gx = "⫙", Zx = "ℱ", Kx = "⨍", Wx = "½", Jx = "⅓", Yx = "¼", Xx = "⅕", Qx = "⅙", ey = "⅛", ty = "⅔", ny = "⅖", ry = "¾", sy = "⅗", oy = "⅜", cy = "⅘", iy = "⅚", ly = "⅝", ay = "⅞", uy = "⁄", fy = "⌢", py = "𝒻", hy = "ℱ", dy = "ǵ", gy = "Γ", my = "γ", _y = "Ϝ", by = "ϝ", vy = "⪆", xy = "Ğ", yy = "ğ", ky = "Ģ", Ey = "Ĝ", wy = "ĝ", Cy = "Г", Ay = "г", Sy = "Ġ", Dy = "ġ", Ty = "≥", Ry = "≧", qy = "⪌", My = "⋛", Ny = "≥", Iy = "≧", Fy = "⩾", Ly = "⪩", Oy = "⩾", Py = "⪀", By = "⪂", $y = "⪄", zy = "⋛︀", Uy = "⪔", Hy = "𝔊", jy = "𝔤", Vy = "≫", Gy = "⋙", Zy = "⋙", Ky = "ℷ", Wy = "Ѓ", Jy = "ѓ", Yy = "⪥", Xy = "≷", Qy = "⪒", ek = "⪤", tk = "⪊", nk = "⪊", rk = "⪈", sk = "≩", ok = "⪈", ck = "≩", ik = "⋧", lk = "𝔾", ak = "𝕘", uk = "`", fk = "≥", pk = "⋛", hk = "≧", dk = "⪢", gk = "≷", mk = "⩾", _k = "≳", bk = "𝒢", vk = "ℊ", xk = "≳", yk = "⪎", kk = "⪐", Ek = "⪧", wk = "⩺", Ck = ">", Ak = ">", Sk = "≫", Dk = "⋗", Tk = "⦕", Rk = "⩼", qk = "⪆", Mk = "⥸", Nk = "⋗", Ik = "⋛", Fk = "⪌", Lk = "≷", Ok = "≳", Pk = "≩︀", Bk = "≩︀", $k = "ˇ", zk = " ", Uk = "½", Hk = "ℋ", jk = "Ъ", Vk = "ъ", Gk = "⥈", Zk = "↔", Kk = "⇔", Wk = "↭", Jk = "^", Yk = "ℏ", Xk = "Ĥ", Qk = "ĥ", eE = "♥", tE = "♥", nE = "…", rE = "⊹", sE = "𝔥", oE = "ℌ", cE = "ℋ", iE = "⤥", lE = "⤦", aE = "⇿", uE = "∻", fE = "↩", pE = "↪", hE = "𝕙", dE = "ℍ", gE = "―", mE = "─", _E = "𝒽", bE = "ℋ", vE = "ℏ", xE = "Ħ", yE = "ħ", kE = "≎", EE = "≏", wE = "⁃", CE = "‐", AE = "Í", SE = "í", DE = "⁣", TE = "Î", RE = "î", qE = "И", ME = "и", NE = "İ", IE = "Е", FE = "е", LE = "¡", OE = "⇔", PE = "𝔦", BE = "ℑ", $E = "Ì", zE = "ì", UE = "ⅈ", HE = "⨌", jE = "∭", VE = "⧜", GE = "℩", ZE = "Ĳ", KE = "ĳ", WE = "Ī", JE = "ī", YE = "ℑ", XE = "ⅈ", QE = "ℐ", ew = "ℑ", tw = "ı", nw = "ℑ", rw = "⊷", sw = "Ƶ", ow = "⇒", cw = "℅", iw = "∞", lw = "⧝", aw = "ı", uw = "⊺", fw = "∫", pw = "∬", hw = "ℤ", dw = "∫", gw = "⊺", mw = "⋂", _w = "⨗", bw = "⨼", vw = "⁣", xw = "⁢", yw = "Ё", kw = "ё", Ew = "Į", ww = "į", Cw = "𝕀", Aw = "𝕚", Sw = "Ι", Dw = "ι", Tw = "⨼", Rw = "¿", qw = "𝒾", Mw = "ℐ", Nw = "∈", Iw = "⋵", Fw = "⋹", Lw = "⋴", Ow = "⋳", Pw = "∈", Bw = "⁢", $w = "Ĩ", zw = "ĩ", Uw = "І", Hw = "і", jw = "Ï", Vw = "ï", Gw = "Ĵ", Zw = "ĵ", Kw = "Й", Ww = "й", Jw = "𝔍", Yw = "𝔧", Xw = "ȷ", Qw = "𝕁", eC = "𝕛", tC = "𝒥", nC = "𝒿", rC = "Ј", sC = "ј", oC = "Є", cC = "є", iC = "Κ", lC = "κ", aC = "ϰ", uC = "Ķ", fC = "ķ", pC = "К", hC = "к", dC = "𝔎", gC = "𝔨", mC = "ĸ", _C = "Х", bC = "х", vC = "Ќ", xC = "ќ", yC = "𝕂", kC = "𝕜", EC = "𝒦", wC = "𝓀", CC = "⇚", AC = "Ĺ", SC = "ĺ", DC = "⦴", TC = "ℒ", RC = "Λ", qC = "λ", MC = "⟨", NC = "⟪", IC = "⦑", FC = "⟨", LC = "⪅", OC = "ℒ", PC = "«", BC = "⇤", $C = "⤟", zC = "←", UC = "↞", HC = "⇐", jC = "⤝", VC = "↩", GC = "↫", ZC = "⤹", KC = "⥳", WC = "↢", JC = "⤙", YC = "⤛", XC = "⪫", QC = "⪭", eA = "⪭︀", tA = "⤌", nA = "⤎", rA = "❲", sA = "{", oA = "[", cA = "⦋", iA = "⦏", lA = "⦍", aA = "Ľ", uA = "ľ", fA = "Ļ", pA = "ļ", hA = "⌈", dA = "{", gA = "Л", mA = "л", _A = "⤶", bA = "“", vA = "„", xA = "⥧", yA = "⥋", kA = "↲", EA = "≤", wA = "≦", CA = "⟨", AA = "⇤", SA = "←", DA = "←", TA = "⇐", RA = "⇆", qA = "↢", MA = "⌈", NA = "⟦", IA = "⥡", FA = "⥙", LA = "⇃", OA = "⌊", PA = "↽", BA = "↼", $A = "⇇", zA = "↔", UA = "↔", HA = "⇔", jA = "⇆", VA = "⇋", GA = "↭", ZA = "⥎", KA = "↤", WA = "⊣", JA = "⥚", YA = "⋋", XA = "⧏", QA = "⊲", e1 = "⊴", t1 = "⥑", n1 = "⥠", r1 = "⥘", s1 = "↿", o1 = "⥒", c1 = "↼", i1 = "⪋", l1 = "⋚", a1 = "≤", u1 = "≦", f1 = "⩽", p1 = "⪨", h1 = "⩽", d1 = "⩿", g1 = "⪁", m1 = "⪃", _1 = "⋚︀", b1 = "⪓", v1 = "⪅", x1 = "⋖", y1 = "⋚", k1 = "⪋", E1 = "⋚", w1 = "≦", C1 = "≶", A1 = "≶", S1 = "⪡", D1 = "≲", T1 = "⩽", R1 = "≲", q1 = "⥼", M1 = "⌊", N1 = "𝔏", I1 = "𝔩", F1 = "≶", L1 = "⪑", O1 = "⥢", P1 = "↽", B1 = "↼", $1 = "⥪", z1 = "▄", U1 = "Љ", H1 = "љ", j1 = "⇇", V1 = "≪", G1 = "⋘", Z1 = "⌞", K1 = "⇚", W1 = "⥫", J1 = "◺", Y1 = "Ŀ", X1 = "ŀ", Q1 = "⎰", eS = "⎰", tS = "⪉", nS = "⪉", rS = "⪇", sS = "≨", oS = "⪇", cS = "≨", iS = "⋦", lS = "⟬", aS = "⇽", uS = "⟦", fS = "⟵", pS = "⟵", hS = "⟸", dS = "⟷", gS = "⟷", mS = "⟺", _S = "⟼", bS = "⟶", vS = "⟶", xS = "⟹", yS = "↫", kS = "↬", ES = "⦅", wS = "𝕃", CS = "𝕝", AS = "⨭", SS = "⨴", DS = "∗", TS = "_", RS = "↙", qS = "↘", MS = "◊", NS = "◊", IS = "⧫", FS = "(", LS = "⦓", OS = "⇆", PS = "⌟", BS = "⇋", $S = "⥭", zS = "‎", US = "⊿", HS = "‹", jS = "𝓁", VS = "ℒ", GS = "↰", ZS = "↰", KS = "≲", WS = "⪍", JS = "⪏", YS = "[", XS = "‘", QS = "‚", eD = "Ł", tD = "ł", nD = "⪦", rD = "⩹", sD = "<", oD = "<", cD = "≪", iD = "⋖", lD = "⋋", aD = "⋉", uD = "⥶", fD = "⩻", pD = "◃", hD = "⊴", dD = "◂", gD = "⦖", mD = "⥊", _D = "⥦", bD = "≨︀", vD = "≨︀", xD = "¯", yD = "♂", kD = "✠", ED = "✠", wD = "↦", CD = "↦", AD = "↧", SD = "↤", DD = "↥", TD = "▮", RD = "⨩", qD = "М", MD = "м", ND = "—", ID = "∺", FD = "∡", LD = " ", OD = "ℳ", PD = "𝔐", BD = "𝔪", $D = "℧", zD = "µ", UD = "*", HD = "⫰", jD = "∣", VD = "·", GD = "⊟", ZD = "−", KD = "∸", WD = "⨪", JD = "∓", YD = "⫛", XD = "…", QD = "∓", eT = "⊧", tT = "𝕄", nT = "𝕞", rT = "∓", sT = "𝓂", oT = "ℳ", cT = "∾", iT = "Μ", lT = "μ", aT = "⊸", uT = "⊸", fT = "∇", pT = "Ń", hT = "ń", dT = "∠⃒", gT = "≉", mT = "⩰̸", _T = "≋̸", bT = "ŉ", vT = "≉", xT = "♮", yT = "ℕ", kT = "♮", ET = " ", wT = "≎̸", CT = "≏̸", AT = "⩃", ST = "Ň", DT = "ň", TT = "Ņ", RT = "ņ", qT = "≇", MT = "⩭̸", NT = "⩂", IT = "Н", FT = "н", LT = "–", OT = "⤤", PT = "↗", BT = "⇗", $T = "↗", zT = "≠", UT = "≐̸", HT = "​", jT = "​", VT = "​", GT = "​", ZT = "≢", KT = "⤨", WT = "≂̸", JT = "≫", YT = "≪", XT = `
`, QT = "∄", eR = "∄", tR = "𝔑", nR = "𝔫", rR = "≧̸", sR = "≱", oR = "≱", cR = "≧̸", iR = "⩾̸", lR = "⩾̸", aR = "⋙̸", uR = "≵", fR = "≫⃒", pR = "≯", hR = "≯", dR = "≫̸", gR = "↮", mR = "⇎", _R = "⫲", bR = "∋", vR = "⋼", xR = "⋺", yR = "∋", kR = "Њ", ER = "њ", wR = "↚", CR = "⇍", AR = "‥", SR = "≦̸", DR = "≰", TR = "↚", RR = "⇍", qR = "↮", MR = "⇎", NR = "≰", IR = "≦̸", FR = "⩽̸", LR = "⩽̸", OR = "≮", PR = "⋘̸", BR = "≴", $R = "≪⃒", zR = "≮", UR = "⋪", HR = "⋬", jR = "≪̸", VR = "∤", GR = "⁠", ZR = " ", KR = "𝕟", WR = "ℕ", JR = "⫬", YR = "¬", XR = "≢", QR = "≭", eq = "∦", tq = "∉", nq = "≠", rq = "≂̸", sq = "∄", oq = "≯", cq = "≱", iq = "≧̸", lq = "≫̸", aq = "≹", uq = "⩾̸", fq = "≵", pq = "≎̸", hq = "≏̸", dq = "∉", gq = "⋵̸", mq = "⋹̸", _q = "∉", bq = "⋷", vq = "⋶", xq = "⧏̸", yq = "⋪", kq = "⋬", Eq = "≮", wq = "≰", Cq = "≸", Aq = "≪̸", Sq = "⩽̸", Dq = "≴", Tq = "⪢̸", Rq = "⪡̸", qq = "∌", Mq = "∌", Nq = "⋾", Iq = "⋽", Fq = "⊀", Lq = "⪯̸", Oq = "⋠", Pq = "∌", Bq = "⧐̸", $q = "⋫", zq = "⋭", Uq = "⊏̸", Hq = "⋢", jq = "⊐̸", Vq = "⋣", Gq = "⊂⃒", Zq = "⊈", Kq = "⊁", Wq = "⪰̸", Jq = "⋡", Yq = "≿̸", Xq = "⊃⃒", Qq = "⊉", eM = "≁", tM = "≄", nM = "≇", rM = "≉", sM = "∤", oM = "∦", cM = "∦", iM = "⫽⃥", lM = "∂̸", aM = "⨔", uM = "⊀", fM = "⋠", pM = "⊀", hM = "⪯̸", dM = "⪯̸", gM = "⤳̸", mM = "↛", _M = "⇏", bM = "↝̸", vM = "↛", xM = "⇏", yM = "⋫", kM = "⋭", EM = "⊁", wM = "⋡", CM = "⪰̸", AM = "𝒩", SM = "𝓃", DM = "∤", TM = "∦", RM = "≁", qM = "≄", MM = "≄", NM = "∤", IM = "∦", FM = "⋢", LM = "⋣", OM = "⊄", PM = "⫅̸", BM = "⊈", $M = "⊂⃒", zM = "⊈", UM = "⫅̸", HM = "⊁", jM = "⪰̸", VM = "⊅", GM = "⫆̸", ZM = "⊉", KM = "⊃⃒", WM = "⊉", JM = "⫆̸", YM = "≹", XM = "Ñ", QM = "ñ", eN = "≸", tN = "⋪", nN = "⋬", rN = "⋫", sN = "⋭", oN = "Ν", cN = "ν", iN = "#", lN = "№", aN = " ", uN = "≍⃒", fN = "⊬", pN = "⊭", hN = "⊮", dN = "⊯", gN = "≥⃒", mN = ">⃒", _N = "⤄", bN = "⧞", vN = "⤂", xN = "≤⃒", yN = "<⃒", kN = "⊴⃒", EN = "⤃", wN = "⊵⃒", CN = "∼⃒", AN = "⤣", SN = "↖", DN = "⇖", TN = "↖", RN = "⤧", qN = "Ó", MN = "ó", NN = "⊛", IN = "Ô", FN = "ô", LN = "⊚", ON = "О", PN = "о", BN = "⊝", $N = "Ő", zN = "ő", UN = "⨸", HN = "⊙", jN = "⦼", VN = "Œ", GN = "œ", ZN = "⦿", KN = "𝔒", WN = "𝔬", JN = "˛", YN = "Ò", XN = "ò", QN = "⧁", eI = "⦵", tI = "Ω", nI = "∮", rI = "↺", sI = "⦾", oI = "⦻", cI = "‾", iI = "⧀", lI = "Ō", aI = "ō", uI = "Ω", fI = "ω", pI = "Ο", hI = "ο", dI = "⦶", gI = "⊖", mI = "𝕆", _I = "𝕠", bI = "⦷", vI = "“", xI = "‘", yI = "⦹", kI = "⊕", EI = "↻", wI = "⩔", CI = "∨", AI = "⩝", SI = "ℴ", DI = "ℴ", TI = "ª", RI = "º", qI = "⊶", MI = "⩖", NI = "⩗", II = "⩛", FI = "Ⓢ", LI = "𝒪", OI = "ℴ", PI = "Ø", BI = "ø", $I = "⊘", zI = "Õ", UI = "õ", HI = "⨶", jI = "⨷", VI = "⊗", GI = "Ö", ZI = "ö", KI = "⌽", WI = "‾", JI = "⏞", YI = "⎴", XI = "⏜", QI = "¶", eF = "∥", tF = "∥", nF = "⫳", rF = "⫽", sF = "∂", oF = "∂", cF = "П", iF = "п", lF = "%", aF = ".", uF = "‰", fF = "⊥", pF = "‱", hF = "𝔓", dF = "𝔭", gF = "Φ", mF = "φ", _F = "ϕ", bF = "ℳ", vF = "☎", xF = "Π", yF = "π", kF = "⋔", EF = "ϖ", wF = "ℏ", CF = "ℎ", AF = "ℏ", SF = "⨣", DF = "⊞", TF = "⨢", RF = "+", qF = "∔", MF = "⨥", NF = "⩲", IF = "±", FF = "±", LF = "⨦", OF = "⨧", PF = "±", BF = "ℌ", $F = "⨕", zF = "𝕡", UF = "ℙ", HF = "£", jF = "⪷", VF = "⪻", GF = "≺", ZF = "≼", KF = "⪷", WF = "≺", JF = "≼", YF = "≺", XF = "⪯", QF = "≼", eL = "≾", tL = "⪯", nL = "⪹", rL = "⪵", sL = "⋨", oL = "⪯", cL = "⪳", iL = "≾", lL = "′", aL = "″", uL = "ℙ", fL = "⪹", pL = "⪵", hL = "⋨", dL = "∏", gL = "∏", mL = "⌮", _L = "⌒", bL = "⌓", vL = "∝", xL = "∝", yL = "∷", kL = "∝", EL = "≾", wL = "⊰", CL = "𝒫", AL = "𝓅", SL = "Ψ", DL = "ψ", TL = " ", RL = "𝔔", qL = "𝔮", ML = "⨌", NL = "𝕢", IL = "ℚ", FL = "⁗", LL = "𝒬", OL = "𝓆", PL = "ℍ", BL = "⨖", $L = "?", zL = "≟", UL = '"', HL = '"', jL = "⇛", VL = "∽̱", GL = "Ŕ", ZL = "ŕ", KL = "√", WL = "⦳", JL = "⟩", YL = "⟫", XL = "⦒", QL = "⦥", eO = "⟩", tO = "»", nO = "⥵", rO = "⇥", sO = "⤠", oO = "⤳", cO = "→", iO = "↠", lO = "⇒", aO = "⤞", uO = "↪", fO = "↬", pO = "⥅", hO = "⥴", dO = "⤖", gO = "↣", mO = "↝", _O = "⤚", bO = "⤜", vO = "∶", xO = "ℚ", yO = "⤍", kO = "⤏", EO = "⤐", wO = "❳", CO = "}", AO = "]", SO = "⦌", DO = "⦎", TO = "⦐", RO = "Ř", qO = "ř", MO = "Ŗ", NO = "ŗ", IO = "⌉", FO = "}", LO = "Р", OO = "р", PO = "⤷", BO = "⥩", $O = "”", zO = "”", UO = "↳", HO = "ℜ", jO = "ℛ", VO = "ℜ", GO = "ℝ", ZO = "ℜ", KO = "▭", WO = "®", JO = "®", YO = "∋", XO = "⇋", QO = "⥯", eP = "⥽", tP = "⌋", nP = "𝔯", rP = "ℜ", sP = "⥤", oP = "⇁", cP = "⇀", iP = "⥬", lP = "Ρ", aP = "ρ", uP = "ϱ", fP = "⟩", pP = "⇥", hP = "→", dP = "→", gP = "⇒", mP = "⇄", _P = "↣", bP = "⌉", vP = "⟧", xP = "⥝", yP = "⥕", kP = "⇂", EP = "⌋", wP = "⇁", CP = "⇀", AP = "⇄", SP = "⇌", DP = "⇉", TP = "↝", RP = "↦", qP = "⊢", MP = "⥛", NP = "⋌", IP = "⧐", FP = "⊳", LP = "⊵", OP = "⥏", PP = "⥜", BP = "⥔", $P = "↾", zP = "⥓", UP = "⇀", HP = "˚", jP = "≓", VP = "⇄", GP = "⇌", ZP = "‏", KP = "⎱", WP = "⎱", JP = "⫮", YP = "⟭", XP = "⇾", QP = "⟧", eB = "⦆", tB = "𝕣", nB = "ℝ", rB = "⨮", sB = "⨵", oB = "⥰", cB = ")", iB = "⦔", lB = "⨒", aB = "⇉", uB = "⇛", fB = "›", pB = "𝓇", hB = "ℛ", dB = "↱", gB = "↱", mB = "]", _B = "’", bB = "’", vB = "⋌", xB = "⋊", yB = "▹", kB = "⊵", EB = "▸", wB = "⧎", CB = "⧴", AB = "⥨", SB = "℞", DB = "Ś", TB = "ś", RB = "‚", qB = "⪸", MB = "Š", NB = "š", IB = "⪼", FB = "≻", LB = "≽", OB = "⪰", PB = "⪴", BB = "Ş", $B = "ş", zB = "Ŝ", UB = "ŝ", HB = "⪺", jB = "⪶", VB = "⋩", GB = "⨓", ZB = "≿", KB = "С", WB = "с", JB = "⊡", YB = "⋅", XB = "⩦", QB = "⤥", e2 = "↘", t2 = "⇘", n2 = "↘", r2 = "§", s2 = ";", o2 = "⤩", c2 = "∖", i2 = "∖", l2 = "✶", a2 = "𝔖", u2 = "𝔰", f2 = "⌢", p2 = "♯", h2 = "Щ", d2 = "щ", g2 = "Ш", m2 = "ш", _2 = "↓", b2 = "←", v2 = "∣", x2 = "∥", y2 = "→", k2 = "↑", E2 = "­", w2 = "Σ", C2 = "σ", A2 = "ς", S2 = "ς", D2 = "∼", T2 = "⩪", R2 = "≃", q2 = "≃", M2 = "⪞", N2 = "⪠", I2 = "⪝", F2 = "⪟", L2 = "≆", O2 = "⨤", P2 = "⥲", B2 = "←", $2 = "∘", z2 = "∖", U2 = "⨳", H2 = "⧤", j2 = "∣", V2 = "⌣", G2 = "⪪", Z2 = "⪬", K2 = "⪬︀", W2 = "Ь", J2 = "ь", Y2 = "⌿", X2 = "⧄", Q2 = "/", e$ = "𝕊", t$ = "𝕤", n$ = "♠", r$ = "♠", s$ = "∥", o$ = "⊓", c$ = "⊓︀", i$ = "⊔", l$ = "⊔︀", a$ = "√", u$ = "⊏", f$ = "⊑", p$ = "⊏", h$ = "⊑", d$ = "⊐", g$ = "⊒", m$ = "⊐", _$ = "⊒", b$ = "□", v$ = "□", x$ = "⊓", y$ = "⊏", k$ = "⊑", E$ = "⊐", w$ = "⊒", C$ = "⊔", A$ = "▪", S$ = "□", D$ = "▪", T$ = "→", R$ = "𝒮", q$ = "𝓈", M$ = "∖", N$ = "⌣", I$ = "⋆", F$ = "⋆", L$ = "☆", O$ = "★", P$ = "ϵ", B$ = "ϕ", $$ = "¯", z$ = "⊂", U$ = "⋐", H$ = "⪽", j$ = "⫅", V$ = "⊆", G$ = "⫃", Z$ = "⫁", K$ = "⫋", W$ = "⊊", J$ = "⪿", Y$ = "⥹", X$ = "⊂", Q$ = "⋐", ez = "⊆", tz = "⫅", nz = "⊆", rz = "⊊", sz = "⫋", oz = "⫇", cz = "⫕", iz = "⫓", lz = "⪸", az = "≻", uz = "≽", fz = "≻", pz = "⪰", hz = "≽", dz = "≿", gz = "⪰", mz = "⪺", _z = "⪶", bz = "⋩", vz = "≿", xz = "∋", yz = "∑", kz = "∑", Ez = "♪", wz = "¹", Cz = "²", Az = "³", Sz = "⊃", Dz = "⋑", Tz = "⪾", Rz = "⫘", qz = "⫆", Mz = "⊇", Nz = "⫄", Iz = "⊃", Fz = "⊇", Lz = "⟉", Oz = "⫗", Pz = "⥻", Bz = "⫂", $z = "⫌", zz = "⊋", Uz = "⫀", Hz = "⊃", jz = "⋑", Vz = "⊇", Gz = "⫆", Zz = "⊋", Kz = "⫌", Wz = "⫈", Jz = "⫔", Yz = "⫖", Xz = "⤦", Qz = "↙", eU = "⇙", tU = "↙", nU = "⤪", rU = "ß", sU = "	", oU = "⌖", cU = "Τ", iU = "τ", lU = "⎴", aU = "Ť", uU = "ť", fU = "Ţ", pU = "ţ", hU = "Т", dU = "т", gU = "⃛", mU = "⌕", _U = "𝔗", bU = "𝔱", vU = "∴", xU = "∴", yU = "∴", kU = "Θ", EU = "θ", wU = "ϑ", CU = "ϑ", AU = "≈", SU = "∼", DU = "  ", TU = " ", RU = " ", qU = "≈", MU = "∼", NU = "Þ", IU = "þ", FU = "˜", LU = "∼", OU = "≃", PU = "≅", BU = "≈", $U = "⨱", zU = "⊠", UU = "×", HU = "⨰", jU = "∭", VU = "⤨", GU = "⌶", ZU = "⫱", KU = "⊤", WU = "𝕋", JU = "𝕥", YU = "⫚", XU = "⤩", QU = "‴", e3 = "™", t3 = "™", n3 = "▵", r3 = "▿", s3 = "◃", o3 = "⊴", c3 = "≜", i3 = "▹", l3 = "⊵", a3 = "◬", u3 = "≜", f3 = "⨺", p3 = "⃛", h3 = "⨹", d3 = "⧍", g3 = "⨻", m3 = "⏢", _3 = "𝒯", b3 = "𝓉", v3 = "Ц", x3 = "ц", y3 = "Ћ", k3 = "ћ", E3 = "Ŧ", w3 = "ŧ", C3 = "≬", A3 = "↞", S3 = "↠", D3 = "Ú", T3 = "ú", R3 = "↑", q3 = "↟", M3 = "⇑", N3 = "⥉", I3 = "Ў", F3 = "ў", L3 = "Ŭ", O3 = "ŭ", P3 = "Û", B3 = "û", $3 = "У", z3 = "у", U3 = "⇅", H3 = "Ű", j3 = "ű", V3 = "⥮", G3 = "⥾", Z3 = "𝔘", K3 = "𝔲", W3 = "Ù", J3 = "ù", Y3 = "⥣", X3 = "↿", Q3 = "↾", eH = "▀", tH = "⌜", nH = "⌜", rH = "⌏", sH = "◸", oH = "Ū", cH = "ū", iH = "¨", lH = "_", aH = "⏟", uH = "⎵", fH = "⏝", pH = "⋃", hH = "⊎", dH = "Ų", gH = "ų", mH = "𝕌", _H = "𝕦", bH = "⤒", vH = "↑", xH = "↑", yH = "⇑", kH = "⇅", EH = "↕", wH = "↕", CH = "⇕", AH = "⥮", SH = "↿", DH = "↾", TH = "⊎", RH = "↖", qH = "↗", MH = "υ", NH = "ϒ", IH = "ϒ", FH = "Υ", LH = "υ", OH = "↥", PH = "⊥", BH = "⇈", $H = "⌝", zH = "⌝", UH = "⌎", HH = "Ů", jH = "ů", VH = "◹", GH = "𝒰", ZH = "𝓊", KH = "⋰", WH = "Ũ", JH = "ũ", YH = "▵", XH = "▴", QH = "⇈", e6 = "Ü", t6 = "ü", n6 = "⦧", r6 = "⦜", s6 = "ϵ", o6 = "ϰ", c6 = "∅", i6 = "ϕ", l6 = "ϖ", a6 = "∝", u6 = "↕", f6 = "⇕", p6 = "ϱ", h6 = "ς", d6 = "⊊︀", g6 = "⫋︀", m6 = "⊋︀", _6 = "⫌︀", b6 = "ϑ", v6 = "⊲", x6 = "⊳", y6 = "⫨", k6 = "⫫", E6 = "⫩", w6 = "В", C6 = "в", A6 = "⊢", S6 = "⊨", D6 = "⊩", T6 = "⊫", R6 = "⫦", q6 = "⊻", M6 = "∨", N6 = "⋁", I6 = "≚", F6 = "⋮", L6 = "|", O6 = "‖", P6 = "|", B6 = "‖", $6 = "∣", z6 = "|", U6 = "❘", H6 = "≀", j6 = " ", V6 = "𝔙", G6 = "𝔳", Z6 = "⊲", K6 = "⊂⃒", W6 = "⊃⃒", J6 = "𝕍", Y6 = "𝕧", X6 = "∝", Q6 = "⊳", e8 = "𝒱", t8 = "𝓋", n8 = "⫋︀", r8 = "⊊︀", s8 = "⫌︀", o8 = "⊋︀", c8 = "⊪", i8 = "⦚", l8 = "Ŵ", a8 = "ŵ", u8 = "⩟", f8 = "∧", p8 = "⋀", h8 = "≙", d8 = "℘", g8 = "𝔚", m8 = "𝔴", _8 = "𝕎", b8 = "𝕨", v8 = "℘", x8 = "≀", y8 = "≀", k8 = "𝒲", E8 = "𝓌", w8 = "⋂", C8 = "◯", A8 = "⋃", S8 = "▽", D8 = "𝔛", T8 = "𝔵", R8 = "⟷", q8 = "⟺", M8 = "Ξ", N8 = "ξ", I8 = "⟵", F8 = "⟸", L8 = "⟼", O8 = "⋻", P8 = "⨀", B8 = "𝕏", $8 = "𝕩", z8 = "⨁", U8 = "⨂", H8 = "⟶", j8 = "⟹", V8 = "𝒳", G8 = "𝓍", Z8 = "⨆", K8 = "⨄", W8 = "△", J8 = "⋁", Y8 = "⋀", X8 = "Ý", Q8 = "ý", ej = "Я", tj = "я", nj = "Ŷ", rj = "ŷ", sj = "Ы", oj = "ы", cj = "¥", ij = "𝔜", lj = "𝔶", aj = "Ї", uj = "ї", fj = "𝕐", pj = "𝕪", hj = "𝒴", dj = "𝓎", gj = "Ю", mj = "ю", _j = "ÿ", bj = "Ÿ", vj = "Ź", xj = "ź", yj = "Ž", kj = "ž", Ej = "З", wj = "з", Cj = "Ż", Aj = "ż", Sj = "ℨ", Dj = "​", Tj = "Ζ", Rj = "ζ", qj = "𝔷", Mj = "ℨ", Nj = "Ж", Ij = "ж", Fj = "⇝", Lj = "𝕫", Oj = "ℤ", Pj = "𝒵", Bj = "𝓏", $j = "‍", zj = "‌", Uj = {
  Aacute: Cf,
  aacute: Af,
  Abreve: Sf,
  abreve: Df,
  ac: Tf,
  acd: Rf,
  acE: qf,
  Acirc: Mf,
  acirc: Nf,
  acute: If,
  Acy: Ff,
  acy: Lf,
  AElig: Of,
  aelig: Pf,
  af: Bf,
  Afr: $f,
  afr: zf,
  Agrave: Uf,
  agrave: Hf,
  alefsym: jf,
  aleph: Vf,
  Alpha: Gf,
  alpha: Zf,
  Amacr: Kf,
  amacr: Wf,
  amalg: Jf,
  amp: Yf,
  AMP: Xf,
  andand: Qf,
  And: ep,
  and: tp,
  andd: np,
  andslope: rp,
  andv: sp,
  ang: op,
  ange: cp,
  angle: ip,
  angmsdaa: lp,
  angmsdab: ap,
  angmsdac: up,
  angmsdad: fp,
  angmsdae: pp,
  angmsdaf: hp,
  angmsdag: dp,
  angmsdah: gp,
  angmsd: mp,
  angrt: _p,
  angrtvb: bp,
  angrtvbd: vp,
  angsph: xp,
  angst: yp,
  angzarr: kp,
  Aogon: Ep,
  aogon: wp,
  Aopf: Cp,
  aopf: Ap,
  apacir: Sp,
  ap: Dp,
  apE: Tp,
  ape: Rp,
  apid: qp,
  apos: Mp,
  ApplyFunction: Np,
  approx: Ip,
  approxeq: Fp,
  Aring: Lp,
  aring: Op,
  Ascr: Pp,
  ascr: Bp,
  Assign: $p,
  ast: zp,
  asymp: Up,
  asympeq: Hp,
  Atilde: jp,
  atilde: Vp,
  Auml: Gp,
  auml: Zp,
  awconint: Kp,
  awint: Wp,
  backcong: Jp,
  backepsilon: Yp,
  backprime: Xp,
  backsim: Qp,
  backsimeq: eh,
  Backslash: th,
  Barv: nh,
  barvee: rh,
  barwed: sh,
  Barwed: oh,
  barwedge: ch,
  bbrk: ih,
  bbrktbrk: lh,
  bcong: ah,
  Bcy: uh,
  bcy: fh,
  bdquo: ph,
  becaus: hh,
  because: dh,
  Because: gh,
  bemptyv: mh,
  bepsi: _h,
  bernou: bh,
  Bernoullis: vh,
  Beta: xh,
  beta: yh,
  beth: kh,
  between: Eh,
  Bfr: wh,
  bfr: Ch,
  bigcap: Ah,
  bigcirc: Sh,
  bigcup: Dh,
  bigodot: Th,
  bigoplus: Rh,
  bigotimes: qh,
  bigsqcup: Mh,
  bigstar: Nh,
  bigtriangledown: Ih,
  bigtriangleup: Fh,
  biguplus: Lh,
  bigvee: Oh,
  bigwedge: Ph,
  bkarow: Bh,
  blacklozenge: $h,
  blacksquare: zh,
  blacktriangle: Uh,
  blacktriangledown: Hh,
  blacktriangleleft: jh,
  blacktriangleright: Vh,
  blank: Gh,
  blk12: Zh,
  blk14: Kh,
  blk34: Wh,
  block: Jh,
  bne: Yh,
  bnequiv: Xh,
  bNot: Qh,
  bnot: ed,
  Bopf: td,
  bopf: nd,
  bot: rd,
  bottom: sd,
  bowtie: od,
  boxbox: cd,
  boxdl: id,
  boxdL: ld,
  boxDl: ad,
  boxDL: ud,
  boxdr: fd,
  boxdR: pd,
  boxDr: hd,
  boxDR: dd,
  boxh: gd,
  boxH: md,
  boxhd: _d,
  boxHd: bd,
  boxhD: vd,
  boxHD: xd,
  boxhu: yd,
  boxHu: kd,
  boxhU: Ed,
  boxHU: wd,
  boxminus: Cd,
  boxplus: Ad,
  boxtimes: Sd,
  boxul: Dd,
  boxuL: Td,
  boxUl: Rd,
  boxUL: qd,
  boxur: Md,
  boxuR: Nd,
  boxUr: Id,
  boxUR: Fd,
  boxv: Ld,
  boxV: Od,
  boxvh: Pd,
  boxvH: Bd,
  boxVh: $d,
  boxVH: zd,
  boxvl: Ud,
  boxvL: Hd,
  boxVl: jd,
  boxVL: Vd,
  boxvr: Gd,
  boxvR: Zd,
  boxVr: Kd,
  boxVR: Wd,
  bprime: Jd,
  breve: Yd,
  Breve: Xd,
  brvbar: Qd,
  bscr: eg,
  Bscr: tg,
  bsemi: ng,
  bsim: rg,
  bsime: sg,
  bsolb: og,
  bsol: cg,
  bsolhsub: ig,
  bull: lg,
  bullet: ag,
  bump: ug,
  bumpE: fg,
  bumpe: pg,
  Bumpeq: hg,
  bumpeq: dg,
  Cacute: gg,
  cacute: mg,
  capand: _g,
  capbrcup: bg,
  capcap: vg,
  cap: xg,
  Cap: yg,
  capcup: kg,
  capdot: Eg,
  CapitalDifferentialD: wg,
  caps: Cg,
  caret: Ag,
  caron: Sg,
  Cayleys: Dg,
  ccaps: Tg,
  Ccaron: Rg,
  ccaron: qg,
  Ccedil: Mg,
  ccedil: Ng,
  Ccirc: Ig,
  ccirc: Fg,
  Cconint: Lg,
  ccups: Og,
  ccupssm: Pg,
  Cdot: Bg,
  cdot: $g,
  cedil: zg,
  Cedilla: Ug,
  cemptyv: Hg,
  cent: jg,
  centerdot: Vg,
  CenterDot: Gg,
  cfr: Zg,
  Cfr: Kg,
  CHcy: Wg,
  chcy: Jg,
  check: Yg,
  checkmark: Xg,
  Chi: Qg,
  chi: em,
  circ: tm,
  circeq: nm,
  circlearrowleft: rm,
  circlearrowright: sm,
  circledast: om,
  circledcirc: cm,
  circleddash: im,
  CircleDot: lm,
  circledR: am,
  circledS: um,
  CircleMinus: fm,
  CirclePlus: pm,
  CircleTimes: hm,
  cir: dm,
  cirE: gm,
  cire: mm,
  cirfnint: _m,
  cirmid: bm,
  cirscir: vm,
  ClockwiseContourIntegral: xm,
  CloseCurlyDoubleQuote: ym,
  CloseCurlyQuote: km,
  clubs: Em,
  clubsuit: wm,
  colon: Cm,
  Colon: Am,
  Colone: Sm,
  colone: Dm,
  coloneq: Tm,
  comma: Rm,
  commat: qm,
  comp: Mm,
  compfn: Nm,
  complement: Im,
  complexes: Fm,
  cong: Lm,
  congdot: Om,
  Congruent: Pm,
  conint: Bm,
  Conint: $m,
  ContourIntegral: zm,
  copf: Um,
  Copf: Hm,
  coprod: jm,
  Coproduct: Vm,
  copy: Gm,
  COPY: Zm,
  copysr: Km,
  CounterClockwiseContourIntegral: Wm,
  crarr: Jm,
  cross: Ym,
  Cross: Xm,
  Cscr: Qm,
  cscr: e_,
  csub: t_,
  csube: n_,
  csup: r_,
  csupe: s_,
  ctdot: o_,
  cudarrl: c_,
  cudarrr: i_,
  cuepr: l_,
  cuesc: a_,
  cularr: u_,
  cularrp: f_,
  cupbrcap: p_,
  cupcap: h_,
  CupCap: d_,
  cup: g_,
  Cup: m_,
  cupcup: __,
  cupdot: b_,
  cupor: v_,
  cups: x_,
  curarr: y_,
  curarrm: k_,
  curlyeqprec: E_,
  curlyeqsucc: w_,
  curlyvee: C_,
  curlywedge: A_,
  curren: S_,
  curvearrowleft: D_,
  curvearrowright: T_,
  cuvee: R_,
  cuwed: q_,
  cwconint: M_,
  cwint: N_,
  cylcty: I_,
  dagger: F_,
  Dagger: L_,
  daleth: O_,
  darr: P_,
  Darr: B_,
  dArr: $_,
  dash: z_,
  Dashv: U_,
  dashv: H_,
  dbkarow: j_,
  dblac: V_,
  Dcaron: G_,
  dcaron: Z_,
  Dcy: K_,
  dcy: W_,
  ddagger: J_,
  ddarr: Y_,
  DD: X_,
  dd: Q_,
  DDotrahd: eb,
  ddotseq: tb,
  deg: nb,
  Del: rb,
  Delta: sb,
  delta: ob,
  demptyv: cb,
  dfisht: ib,
  Dfr: lb,
  dfr: ab,
  dHar: ub,
  dharl: fb,
  dharr: pb,
  DiacriticalAcute: hb,
  DiacriticalDot: db,
  DiacriticalDoubleAcute: gb,
  DiacriticalGrave: mb,
  DiacriticalTilde: _b,
  diam: bb,
  diamond: vb,
  Diamond: xb,
  diamondsuit: yb,
  diams: kb,
  die: Eb,
  DifferentialD: wb,
  digamma: Cb,
  disin: Ab,
  div: Sb,
  divide: Db,
  divideontimes: Tb,
  divonx: Rb,
  DJcy: qb,
  djcy: Mb,
  dlcorn: Nb,
  dlcrop: Ib,
  dollar: Fb,
  Dopf: Lb,
  dopf: Ob,
  Dot: Pb,
  dot: Bb,
  DotDot: $b,
  doteq: zb,
  doteqdot: Ub,
  DotEqual: Hb,
  dotminus: jb,
  dotplus: Vb,
  dotsquare: Gb,
  doublebarwedge: Zb,
  DoubleContourIntegral: Kb,
  DoubleDot: Wb,
  DoubleDownArrow: Jb,
  DoubleLeftArrow: Yb,
  DoubleLeftRightArrow: Xb,
  DoubleLeftTee: Qb,
  DoubleLongLeftArrow: e0,
  DoubleLongLeftRightArrow: t0,
  DoubleLongRightArrow: n0,
  DoubleRightArrow: r0,
  DoubleRightTee: s0,
  DoubleUpArrow: o0,
  DoubleUpDownArrow: c0,
  DoubleVerticalBar: i0,
  DownArrowBar: l0,
  downarrow: a0,
  DownArrow: u0,
  Downarrow: f0,
  DownArrowUpArrow: p0,
  DownBreve: h0,
  downdownarrows: d0,
  downharpoonleft: g0,
  downharpoonright: m0,
  DownLeftRightVector: _0,
  DownLeftTeeVector: b0,
  DownLeftVectorBar: v0,
  DownLeftVector: x0,
  DownRightTeeVector: y0,
  DownRightVectorBar: k0,
  DownRightVector: E0,
  DownTeeArrow: w0,
  DownTee: C0,
  drbkarow: A0,
  drcorn: S0,
  drcrop: D0,
  Dscr: T0,
  dscr: R0,
  DScy: q0,
  dscy: M0,
  dsol: N0,
  Dstrok: I0,
  dstrok: F0,
  dtdot: L0,
  dtri: O0,
  dtrif: P0,
  duarr: B0,
  duhar: $0,
  dwangle: z0,
  DZcy: U0,
  dzcy: H0,
  dzigrarr: j0,
  Eacute: V0,
  eacute: G0,
  easter: Z0,
  Ecaron: K0,
  ecaron: W0,
  Ecirc: J0,
  ecirc: Y0,
  ecir: X0,
  ecolon: Q0,
  Ecy: ev,
  ecy: tv,
  eDDot: nv,
  Edot: rv,
  edot: sv,
  eDot: ov,
  ee: cv,
  efDot: iv,
  Efr: lv,
  efr: av,
  eg: uv,
  Egrave: fv,
  egrave: pv,
  egs: hv,
  egsdot: dv,
  el: gv,
  Element: mv,
  elinters: _v,
  ell: bv,
  els: vv,
  elsdot: xv,
  Emacr: yv,
  emacr: kv,
  empty: Ev,
  emptyset: wv,
  EmptySmallSquare: Cv,
  emptyv: Av,
  EmptyVerySmallSquare: Sv,
  emsp13: Dv,
  emsp14: Tv,
  emsp: Rv,
  ENG: qv,
  eng: Mv,
  ensp: Nv,
  Eogon: Iv,
  eogon: Fv,
  Eopf: Lv,
  eopf: Ov,
  epar: Pv,
  eparsl: Bv,
  eplus: $v,
  epsi: zv,
  Epsilon: Uv,
  epsilon: Hv,
  epsiv: jv,
  eqcirc: Vv,
  eqcolon: Gv,
  eqsim: Zv,
  eqslantgtr: Kv,
  eqslantless: Wv,
  Equal: Jv,
  equals: Yv,
  EqualTilde: Xv,
  equest: Qv,
  Equilibrium: ex,
  equiv: tx,
  equivDD: nx,
  eqvparsl: rx,
  erarr: sx,
  erDot: ox,
  escr: cx,
  Escr: ix,
  esdot: lx,
  Esim: ax,
  esim: ux,
  Eta: fx,
  eta: px,
  ETH: hx,
  eth: dx,
  Euml: gx,
  euml: mx,
  euro: _x,
  excl: bx,
  exist: vx,
  Exists: xx,
  expectation: yx,
  exponentiale: kx,
  ExponentialE: Ex,
  fallingdotseq: wx,
  Fcy: Cx,
  fcy: Ax,
  female: Sx,
  ffilig: Dx,
  fflig: Tx,
  ffllig: Rx,
  Ffr: qx,
  ffr: Mx,
  filig: Nx,
  FilledSmallSquare: Ix,
  FilledVerySmallSquare: Fx,
  fjlig: Lx,
  flat: Ox,
  fllig: Px,
  fltns: Bx,
  fnof: $x,
  Fopf: zx,
  fopf: Ux,
  forall: Hx,
  ForAll: jx,
  fork: Vx,
  forkv: Gx,
  Fouriertrf: Zx,
  fpartint: Kx,
  frac12: Wx,
  frac13: Jx,
  frac14: Yx,
  frac15: Xx,
  frac16: Qx,
  frac18: ey,
  frac23: ty,
  frac25: ny,
  frac34: ry,
  frac35: sy,
  frac38: oy,
  frac45: cy,
  frac56: iy,
  frac58: ly,
  frac78: ay,
  frasl: uy,
  frown: fy,
  fscr: py,
  Fscr: hy,
  gacute: dy,
  Gamma: gy,
  gamma: my,
  Gammad: _y,
  gammad: by,
  gap: vy,
  Gbreve: xy,
  gbreve: yy,
  Gcedil: ky,
  Gcirc: Ey,
  gcirc: wy,
  Gcy: Cy,
  gcy: Ay,
  Gdot: Sy,
  gdot: Dy,
  ge: Ty,
  gE: Ry,
  gEl: qy,
  gel: My,
  geq: Ny,
  geqq: Iy,
  geqslant: Fy,
  gescc: Ly,
  ges: Oy,
  gesdot: Py,
  gesdoto: By,
  gesdotol: $y,
  gesl: zy,
  gesles: Uy,
  Gfr: Hy,
  gfr: jy,
  gg: Vy,
  Gg: Gy,
  ggg: Zy,
  gimel: Ky,
  GJcy: Wy,
  gjcy: Jy,
  gla: Yy,
  gl: Xy,
  glE: Qy,
  glj: ek,
  gnap: tk,
  gnapprox: nk,
  gne: rk,
  gnE: sk,
  gneq: ok,
  gneqq: ck,
  gnsim: ik,
  Gopf: lk,
  gopf: ak,
  grave: uk,
  GreaterEqual: fk,
  GreaterEqualLess: pk,
  GreaterFullEqual: hk,
  GreaterGreater: dk,
  GreaterLess: gk,
  GreaterSlantEqual: mk,
  GreaterTilde: _k,
  Gscr: bk,
  gscr: vk,
  gsim: xk,
  gsime: yk,
  gsiml: kk,
  gtcc: Ek,
  gtcir: wk,
  gt: Ck,
  GT: Ak,
  Gt: Sk,
  gtdot: Dk,
  gtlPar: Tk,
  gtquest: Rk,
  gtrapprox: qk,
  gtrarr: Mk,
  gtrdot: Nk,
  gtreqless: Ik,
  gtreqqless: Fk,
  gtrless: Lk,
  gtrsim: Ok,
  gvertneqq: Pk,
  gvnE: Bk,
  Hacek: $k,
  hairsp: zk,
  half: Uk,
  hamilt: Hk,
  HARDcy: jk,
  hardcy: Vk,
  harrcir: Gk,
  harr: Zk,
  hArr: Kk,
  harrw: Wk,
  Hat: Jk,
  hbar: Yk,
  Hcirc: Xk,
  hcirc: Qk,
  hearts: eE,
  heartsuit: tE,
  hellip: nE,
  hercon: rE,
  hfr: sE,
  Hfr: oE,
  HilbertSpace: cE,
  hksearow: iE,
  hkswarow: lE,
  hoarr: aE,
  homtht: uE,
  hookleftarrow: fE,
  hookrightarrow: pE,
  hopf: hE,
  Hopf: dE,
  horbar: gE,
  HorizontalLine: mE,
  hscr: _E,
  Hscr: bE,
  hslash: vE,
  Hstrok: xE,
  hstrok: yE,
  HumpDownHump: kE,
  HumpEqual: EE,
  hybull: wE,
  hyphen: CE,
  Iacute: AE,
  iacute: SE,
  ic: DE,
  Icirc: TE,
  icirc: RE,
  Icy: qE,
  icy: ME,
  Idot: NE,
  IEcy: IE,
  iecy: FE,
  iexcl: LE,
  iff: OE,
  ifr: PE,
  Ifr: BE,
  Igrave: $E,
  igrave: zE,
  ii: UE,
  iiiint: HE,
  iiint: jE,
  iinfin: VE,
  iiota: GE,
  IJlig: ZE,
  ijlig: KE,
  Imacr: WE,
  imacr: JE,
  image: YE,
  ImaginaryI: XE,
  imagline: QE,
  imagpart: ew,
  imath: tw,
  Im: nw,
  imof: rw,
  imped: sw,
  Implies: ow,
  incare: cw,
  in: "∈",
  infin: iw,
  infintie: lw,
  inodot: aw,
  intcal: uw,
  int: fw,
  Int: pw,
  integers: hw,
  Integral: dw,
  intercal: gw,
  Intersection: mw,
  intlarhk: _w,
  intprod: bw,
  InvisibleComma: vw,
  InvisibleTimes: xw,
  IOcy: yw,
  iocy: kw,
  Iogon: Ew,
  iogon: ww,
  Iopf: Cw,
  iopf: Aw,
  Iota: Sw,
  iota: Dw,
  iprod: Tw,
  iquest: Rw,
  iscr: qw,
  Iscr: Mw,
  isin: Nw,
  isindot: Iw,
  isinE: Fw,
  isins: Lw,
  isinsv: Ow,
  isinv: Pw,
  it: Bw,
  Itilde: $w,
  itilde: zw,
  Iukcy: Uw,
  iukcy: Hw,
  Iuml: jw,
  iuml: Vw,
  Jcirc: Gw,
  jcirc: Zw,
  Jcy: Kw,
  jcy: Ww,
  Jfr: Jw,
  jfr: Yw,
  jmath: Xw,
  Jopf: Qw,
  jopf: eC,
  Jscr: tC,
  jscr: nC,
  Jsercy: rC,
  jsercy: sC,
  Jukcy: oC,
  jukcy: cC,
  Kappa: iC,
  kappa: lC,
  kappav: aC,
  Kcedil: uC,
  kcedil: fC,
  Kcy: pC,
  kcy: hC,
  Kfr: dC,
  kfr: gC,
  kgreen: mC,
  KHcy: _C,
  khcy: bC,
  KJcy: vC,
  kjcy: xC,
  Kopf: yC,
  kopf: kC,
  Kscr: EC,
  kscr: wC,
  lAarr: CC,
  Lacute: AC,
  lacute: SC,
  laemptyv: DC,
  lagran: TC,
  Lambda: RC,
  lambda: qC,
  lang: MC,
  Lang: NC,
  langd: IC,
  langle: FC,
  lap: LC,
  Laplacetrf: OC,
  laquo: PC,
  larrb: BC,
  larrbfs: $C,
  larr: zC,
  Larr: UC,
  lArr: HC,
  larrfs: jC,
  larrhk: VC,
  larrlp: GC,
  larrpl: ZC,
  larrsim: KC,
  larrtl: WC,
  latail: JC,
  lAtail: YC,
  lat: XC,
  late: QC,
  lates: eA,
  lbarr: tA,
  lBarr: nA,
  lbbrk: rA,
  lbrace: sA,
  lbrack: oA,
  lbrke: cA,
  lbrksld: iA,
  lbrkslu: lA,
  Lcaron: aA,
  lcaron: uA,
  Lcedil: fA,
  lcedil: pA,
  lceil: hA,
  lcub: dA,
  Lcy: gA,
  lcy: mA,
  ldca: _A,
  ldquo: bA,
  ldquor: vA,
  ldrdhar: xA,
  ldrushar: yA,
  ldsh: kA,
  le: EA,
  lE: wA,
  LeftAngleBracket: CA,
  LeftArrowBar: AA,
  leftarrow: SA,
  LeftArrow: DA,
  Leftarrow: TA,
  LeftArrowRightArrow: RA,
  leftarrowtail: qA,
  LeftCeiling: MA,
  LeftDoubleBracket: NA,
  LeftDownTeeVector: IA,
  LeftDownVectorBar: FA,
  LeftDownVector: LA,
  LeftFloor: OA,
  leftharpoondown: PA,
  leftharpoonup: BA,
  leftleftarrows: $A,
  leftrightarrow: zA,
  LeftRightArrow: UA,
  Leftrightarrow: HA,
  leftrightarrows: jA,
  leftrightharpoons: VA,
  leftrightsquigarrow: GA,
  LeftRightVector: ZA,
  LeftTeeArrow: KA,
  LeftTee: WA,
  LeftTeeVector: JA,
  leftthreetimes: YA,
  LeftTriangleBar: XA,
  LeftTriangle: QA,
  LeftTriangleEqual: e1,
  LeftUpDownVector: t1,
  LeftUpTeeVector: n1,
  LeftUpVectorBar: r1,
  LeftUpVector: s1,
  LeftVectorBar: o1,
  LeftVector: c1,
  lEg: i1,
  leg: l1,
  leq: a1,
  leqq: u1,
  leqslant: f1,
  lescc: p1,
  les: h1,
  lesdot: d1,
  lesdoto: g1,
  lesdotor: m1,
  lesg: _1,
  lesges: b1,
  lessapprox: v1,
  lessdot: x1,
  lesseqgtr: y1,
  lesseqqgtr: k1,
  LessEqualGreater: E1,
  LessFullEqual: w1,
  LessGreater: C1,
  lessgtr: A1,
  LessLess: S1,
  lesssim: D1,
  LessSlantEqual: T1,
  LessTilde: R1,
  lfisht: q1,
  lfloor: M1,
  Lfr: N1,
  lfr: I1,
  lg: F1,
  lgE: L1,
  lHar: O1,
  lhard: P1,
  lharu: B1,
  lharul: $1,
  lhblk: z1,
  LJcy: U1,
  ljcy: H1,
  llarr: j1,
  ll: V1,
  Ll: G1,
  llcorner: Z1,
  Lleftarrow: K1,
  llhard: W1,
  lltri: J1,
  Lmidot: Y1,
  lmidot: X1,
  lmoustache: Q1,
  lmoust: eS,
  lnap: tS,
  lnapprox: nS,
  lne: rS,
  lnE: sS,
  lneq: oS,
  lneqq: cS,
  lnsim: iS,
  loang: lS,
  loarr: aS,
  lobrk: uS,
  longleftarrow: fS,
  LongLeftArrow: pS,
  Longleftarrow: hS,
  longleftrightarrow: dS,
  LongLeftRightArrow: gS,
  Longleftrightarrow: mS,
  longmapsto: _S,
  longrightarrow: bS,
  LongRightArrow: vS,
  Longrightarrow: xS,
  looparrowleft: yS,
  looparrowright: kS,
  lopar: ES,
  Lopf: wS,
  lopf: CS,
  loplus: AS,
  lotimes: SS,
  lowast: DS,
  lowbar: TS,
  LowerLeftArrow: RS,
  LowerRightArrow: qS,
  loz: MS,
  lozenge: NS,
  lozf: IS,
  lpar: FS,
  lparlt: LS,
  lrarr: OS,
  lrcorner: PS,
  lrhar: BS,
  lrhard: $S,
  lrm: zS,
  lrtri: US,
  lsaquo: HS,
  lscr: jS,
  Lscr: VS,
  lsh: GS,
  Lsh: ZS,
  lsim: KS,
  lsime: WS,
  lsimg: JS,
  lsqb: YS,
  lsquo: XS,
  lsquor: QS,
  Lstrok: eD,
  lstrok: tD,
  ltcc: nD,
  ltcir: rD,
  lt: sD,
  LT: oD,
  Lt: cD,
  ltdot: iD,
  lthree: lD,
  ltimes: aD,
  ltlarr: uD,
  ltquest: fD,
  ltri: pD,
  ltrie: hD,
  ltrif: dD,
  ltrPar: gD,
  lurdshar: mD,
  luruhar: _D,
  lvertneqq: bD,
  lvnE: vD,
  macr: xD,
  male: yD,
  malt: kD,
  maltese: ED,
  Map: "⤅",
  map: wD,
  mapsto: CD,
  mapstodown: AD,
  mapstoleft: SD,
  mapstoup: DD,
  marker: TD,
  mcomma: RD,
  Mcy: qD,
  mcy: MD,
  mdash: ND,
  mDDot: ID,
  measuredangle: FD,
  MediumSpace: LD,
  Mellintrf: OD,
  Mfr: PD,
  mfr: BD,
  mho: $D,
  micro: zD,
  midast: UD,
  midcir: HD,
  mid: jD,
  middot: VD,
  minusb: GD,
  minus: ZD,
  minusd: KD,
  minusdu: WD,
  MinusPlus: JD,
  mlcp: YD,
  mldr: XD,
  mnplus: QD,
  models: eT,
  Mopf: tT,
  mopf: nT,
  mp: rT,
  mscr: sT,
  Mscr: oT,
  mstpos: cT,
  Mu: iT,
  mu: lT,
  multimap: aT,
  mumap: uT,
  nabla: fT,
  Nacute: pT,
  nacute: hT,
  nang: dT,
  nap: gT,
  napE: mT,
  napid: _T,
  napos: bT,
  napprox: vT,
  natural: xT,
  naturals: yT,
  natur: kT,
  nbsp: ET,
  nbump: wT,
  nbumpe: CT,
  ncap: AT,
  Ncaron: ST,
  ncaron: DT,
  Ncedil: TT,
  ncedil: RT,
  ncong: qT,
  ncongdot: MT,
  ncup: NT,
  Ncy: IT,
  ncy: FT,
  ndash: LT,
  nearhk: OT,
  nearr: PT,
  neArr: BT,
  nearrow: $T,
  ne: zT,
  nedot: UT,
  NegativeMediumSpace: HT,
  NegativeThickSpace: jT,
  NegativeThinSpace: VT,
  NegativeVeryThinSpace: GT,
  nequiv: ZT,
  nesear: KT,
  nesim: WT,
  NestedGreaterGreater: JT,
  NestedLessLess: YT,
  NewLine: XT,
  nexist: QT,
  nexists: eR,
  Nfr: tR,
  nfr: nR,
  ngE: rR,
  nge: sR,
  ngeq: oR,
  ngeqq: cR,
  ngeqslant: iR,
  nges: lR,
  nGg: aR,
  ngsim: uR,
  nGt: fR,
  ngt: pR,
  ngtr: hR,
  nGtv: dR,
  nharr: gR,
  nhArr: mR,
  nhpar: _R,
  ni: bR,
  nis: vR,
  nisd: xR,
  niv: yR,
  NJcy: kR,
  njcy: ER,
  nlarr: wR,
  nlArr: CR,
  nldr: AR,
  nlE: SR,
  nle: DR,
  nleftarrow: TR,
  nLeftarrow: RR,
  nleftrightarrow: qR,
  nLeftrightarrow: MR,
  nleq: NR,
  nleqq: IR,
  nleqslant: FR,
  nles: LR,
  nless: OR,
  nLl: PR,
  nlsim: BR,
  nLt: $R,
  nlt: zR,
  nltri: UR,
  nltrie: HR,
  nLtv: jR,
  nmid: VR,
  NoBreak: GR,
  NonBreakingSpace: ZR,
  nopf: KR,
  Nopf: WR,
  Not: JR,
  not: YR,
  NotCongruent: XR,
  NotCupCap: QR,
  NotDoubleVerticalBar: eq,
  NotElement: tq,
  NotEqual: nq,
  NotEqualTilde: rq,
  NotExists: sq,
  NotGreater: oq,
  NotGreaterEqual: cq,
  NotGreaterFullEqual: iq,
  NotGreaterGreater: lq,
  NotGreaterLess: aq,
  NotGreaterSlantEqual: uq,
  NotGreaterTilde: fq,
  NotHumpDownHump: pq,
  NotHumpEqual: hq,
  notin: dq,
  notindot: gq,
  notinE: mq,
  notinva: _q,
  notinvb: bq,
  notinvc: vq,
  NotLeftTriangleBar: xq,
  NotLeftTriangle: yq,
  NotLeftTriangleEqual: kq,
  NotLess: Eq,
  NotLessEqual: wq,
  NotLessGreater: Cq,
  NotLessLess: Aq,
  NotLessSlantEqual: Sq,
  NotLessTilde: Dq,
  NotNestedGreaterGreater: Tq,
  NotNestedLessLess: Rq,
  notni: qq,
  notniva: Mq,
  notnivb: Nq,
  notnivc: Iq,
  NotPrecedes: Fq,
  NotPrecedesEqual: Lq,
  NotPrecedesSlantEqual: Oq,
  NotReverseElement: Pq,
  NotRightTriangleBar: Bq,
  NotRightTriangle: $q,
  NotRightTriangleEqual: zq,
  NotSquareSubset: Uq,
  NotSquareSubsetEqual: Hq,
  NotSquareSuperset: jq,
  NotSquareSupersetEqual: Vq,
  NotSubset: Gq,
  NotSubsetEqual: Zq,
  NotSucceeds: Kq,
  NotSucceedsEqual: Wq,
  NotSucceedsSlantEqual: Jq,
  NotSucceedsTilde: Yq,
  NotSuperset: Xq,
  NotSupersetEqual: Qq,
  NotTilde: eM,
  NotTildeEqual: tM,
  NotTildeFullEqual: nM,
  NotTildeTilde: rM,
  NotVerticalBar: sM,
  nparallel: oM,
  npar: cM,
  nparsl: iM,
  npart: lM,
  npolint: aM,
  npr: uM,
  nprcue: fM,
  nprec: pM,
  npreceq: hM,
  npre: dM,
  nrarrc: gM,
  nrarr: mM,
  nrArr: _M,
  nrarrw: bM,
  nrightarrow: vM,
  nRightarrow: xM,
  nrtri: yM,
  nrtrie: kM,
  nsc: EM,
  nsccue: wM,
  nsce: CM,
  Nscr: AM,
  nscr: SM,
  nshortmid: DM,
  nshortparallel: TM,
  nsim: RM,
  nsime: qM,
  nsimeq: MM,
  nsmid: NM,
  nspar: IM,
  nsqsube: FM,
  nsqsupe: LM,
  nsub: OM,
  nsubE: PM,
  nsube: BM,
  nsubset: $M,
  nsubseteq: zM,
  nsubseteqq: UM,
  nsucc: HM,
  nsucceq: jM,
  nsup: VM,
  nsupE: GM,
  nsupe: ZM,
  nsupset: KM,
  nsupseteq: WM,
  nsupseteqq: JM,
  ntgl: YM,
  Ntilde: XM,
  ntilde: QM,
  ntlg: eN,
  ntriangleleft: tN,
  ntrianglelefteq: nN,
  ntriangleright: rN,
  ntrianglerighteq: sN,
  Nu: oN,
  nu: cN,
  num: iN,
  numero: lN,
  numsp: aN,
  nvap: uN,
  nvdash: fN,
  nvDash: pN,
  nVdash: hN,
  nVDash: dN,
  nvge: gN,
  nvgt: mN,
  nvHarr: _N,
  nvinfin: bN,
  nvlArr: vN,
  nvle: xN,
  nvlt: yN,
  nvltrie: kN,
  nvrArr: EN,
  nvrtrie: wN,
  nvsim: CN,
  nwarhk: AN,
  nwarr: SN,
  nwArr: DN,
  nwarrow: TN,
  nwnear: RN,
  Oacute: qN,
  oacute: MN,
  oast: NN,
  Ocirc: IN,
  ocirc: FN,
  ocir: LN,
  Ocy: ON,
  ocy: PN,
  odash: BN,
  Odblac: $N,
  odblac: zN,
  odiv: UN,
  odot: HN,
  odsold: jN,
  OElig: VN,
  oelig: GN,
  ofcir: ZN,
  Ofr: KN,
  ofr: WN,
  ogon: JN,
  Ograve: YN,
  ograve: XN,
  ogt: QN,
  ohbar: eI,
  ohm: tI,
  oint: nI,
  olarr: rI,
  olcir: sI,
  olcross: oI,
  oline: cI,
  olt: iI,
  Omacr: lI,
  omacr: aI,
  Omega: uI,
  omega: fI,
  Omicron: pI,
  omicron: hI,
  omid: dI,
  ominus: gI,
  Oopf: mI,
  oopf: _I,
  opar: bI,
  OpenCurlyDoubleQuote: vI,
  OpenCurlyQuote: xI,
  operp: yI,
  oplus: kI,
  orarr: EI,
  Or: wI,
  or: CI,
  ord: AI,
  order: SI,
  orderof: DI,
  ordf: TI,
  ordm: RI,
  origof: qI,
  oror: MI,
  orslope: NI,
  orv: II,
  oS: FI,
  Oscr: LI,
  oscr: OI,
  Oslash: PI,
  oslash: BI,
  osol: $I,
  Otilde: zI,
  otilde: UI,
  otimesas: HI,
  Otimes: jI,
  otimes: VI,
  Ouml: GI,
  ouml: ZI,
  ovbar: KI,
  OverBar: WI,
  OverBrace: JI,
  OverBracket: YI,
  OverParenthesis: XI,
  para: QI,
  parallel: eF,
  par: tF,
  parsim: nF,
  parsl: rF,
  part: sF,
  PartialD: oF,
  Pcy: cF,
  pcy: iF,
  percnt: lF,
  period: aF,
  permil: uF,
  perp: fF,
  pertenk: pF,
  Pfr: hF,
  pfr: dF,
  Phi: gF,
  phi: mF,
  phiv: _F,
  phmmat: bF,
  phone: vF,
  Pi: xF,
  pi: yF,
  pitchfork: kF,
  piv: EF,
  planck: wF,
  planckh: CF,
  plankv: AF,
  plusacir: SF,
  plusb: DF,
  pluscir: TF,
  plus: RF,
  plusdo: qF,
  plusdu: MF,
  pluse: NF,
  PlusMinus: IF,
  plusmn: FF,
  plussim: LF,
  plustwo: OF,
  pm: PF,
  Poincareplane: BF,
  pointint: $F,
  popf: zF,
  Popf: UF,
  pound: HF,
  prap: jF,
  Pr: VF,
  pr: GF,
  prcue: ZF,
  precapprox: KF,
  prec: WF,
  preccurlyeq: JF,
  Precedes: YF,
  PrecedesEqual: XF,
  PrecedesSlantEqual: QF,
  PrecedesTilde: eL,
  preceq: tL,
  precnapprox: nL,
  precneqq: rL,
  precnsim: sL,
  pre: oL,
  prE: cL,
  precsim: iL,
  prime: lL,
  Prime: aL,
  primes: uL,
  prnap: fL,
  prnE: pL,
  prnsim: hL,
  prod: dL,
  Product: gL,
  profalar: mL,
  profline: _L,
  profsurf: bL,
  prop: vL,
  Proportional: xL,
  Proportion: yL,
  propto: kL,
  prsim: EL,
  prurel: wL,
  Pscr: CL,
  pscr: AL,
  Psi: SL,
  psi: DL,
  puncsp: TL,
  Qfr: RL,
  qfr: qL,
  qint: ML,
  qopf: NL,
  Qopf: IL,
  qprime: FL,
  Qscr: LL,
  qscr: OL,
  quaternions: PL,
  quatint: BL,
  quest: $L,
  questeq: zL,
  quot: UL,
  QUOT: HL,
  rAarr: jL,
  race: VL,
  Racute: GL,
  racute: ZL,
  radic: KL,
  raemptyv: WL,
  rang: JL,
  Rang: YL,
  rangd: XL,
  range: QL,
  rangle: eO,
  raquo: tO,
  rarrap: nO,
  rarrb: rO,
  rarrbfs: sO,
  rarrc: oO,
  rarr: cO,
  Rarr: iO,
  rArr: lO,
  rarrfs: aO,
  rarrhk: uO,
  rarrlp: fO,
  rarrpl: pO,
  rarrsim: hO,
  Rarrtl: dO,
  rarrtl: gO,
  rarrw: mO,
  ratail: _O,
  rAtail: bO,
  ratio: vO,
  rationals: xO,
  rbarr: yO,
  rBarr: kO,
  RBarr: EO,
  rbbrk: wO,
  rbrace: CO,
  rbrack: AO,
  rbrke: SO,
  rbrksld: DO,
  rbrkslu: TO,
  Rcaron: RO,
  rcaron: qO,
  Rcedil: MO,
  rcedil: NO,
  rceil: IO,
  rcub: FO,
  Rcy: LO,
  rcy: OO,
  rdca: PO,
  rdldhar: BO,
  rdquo: $O,
  rdquor: zO,
  rdsh: UO,
  real: HO,
  realine: jO,
  realpart: VO,
  reals: GO,
  Re: ZO,
  rect: KO,
  reg: WO,
  REG: JO,
  ReverseElement: YO,
  ReverseEquilibrium: XO,
  ReverseUpEquilibrium: QO,
  rfisht: eP,
  rfloor: tP,
  rfr: nP,
  Rfr: rP,
  rHar: sP,
  rhard: oP,
  rharu: cP,
  rharul: iP,
  Rho: lP,
  rho: aP,
  rhov: uP,
  RightAngleBracket: fP,
  RightArrowBar: pP,
  rightarrow: hP,
  RightArrow: dP,
  Rightarrow: gP,
  RightArrowLeftArrow: mP,
  rightarrowtail: _P,
  RightCeiling: bP,
  RightDoubleBracket: vP,
  RightDownTeeVector: xP,
  RightDownVectorBar: yP,
  RightDownVector: kP,
  RightFloor: EP,
  rightharpoondown: wP,
  rightharpoonup: CP,
  rightleftarrows: AP,
  rightleftharpoons: SP,
  rightrightarrows: DP,
  rightsquigarrow: TP,
  RightTeeArrow: RP,
  RightTee: qP,
  RightTeeVector: MP,
  rightthreetimes: NP,
  RightTriangleBar: IP,
  RightTriangle: FP,
  RightTriangleEqual: LP,
  RightUpDownVector: OP,
  RightUpTeeVector: PP,
  RightUpVectorBar: BP,
  RightUpVector: $P,
  RightVectorBar: zP,
  RightVector: UP,
  ring: HP,
  risingdotseq: jP,
  rlarr: VP,
  rlhar: GP,
  rlm: ZP,
  rmoustache: KP,
  rmoust: WP,
  rnmid: JP,
  roang: YP,
  roarr: XP,
  robrk: QP,
  ropar: eB,
  ropf: tB,
  Ropf: nB,
  roplus: rB,
  rotimes: sB,
  RoundImplies: oB,
  rpar: cB,
  rpargt: iB,
  rppolint: lB,
  rrarr: aB,
  Rrightarrow: uB,
  rsaquo: fB,
  rscr: pB,
  Rscr: hB,
  rsh: dB,
  Rsh: gB,
  rsqb: mB,
  rsquo: _B,
  rsquor: bB,
  rthree: vB,
  rtimes: xB,
  rtri: yB,
  rtrie: kB,
  rtrif: EB,
  rtriltri: wB,
  RuleDelayed: CB,
  ruluhar: AB,
  rx: SB,
  Sacute: DB,
  sacute: TB,
  sbquo: RB,
  scap: qB,
  Scaron: MB,
  scaron: NB,
  Sc: IB,
  sc: FB,
  sccue: LB,
  sce: OB,
  scE: PB,
  Scedil: BB,
  scedil: $B,
  Scirc: zB,
  scirc: UB,
  scnap: HB,
  scnE: jB,
  scnsim: VB,
  scpolint: GB,
  scsim: ZB,
  Scy: KB,
  scy: WB,
  sdotb: JB,
  sdot: YB,
  sdote: XB,
  searhk: QB,
  searr: e2,
  seArr: t2,
  searrow: n2,
  sect: r2,
  semi: s2,
  seswar: o2,
  setminus: c2,
  setmn: i2,
  sext: l2,
  Sfr: a2,
  sfr: u2,
  sfrown: f2,
  sharp: p2,
  SHCHcy: h2,
  shchcy: d2,
  SHcy: g2,
  shcy: m2,
  ShortDownArrow: _2,
  ShortLeftArrow: b2,
  shortmid: v2,
  shortparallel: x2,
  ShortRightArrow: y2,
  ShortUpArrow: k2,
  shy: E2,
  Sigma: w2,
  sigma: C2,
  sigmaf: A2,
  sigmav: S2,
  sim: D2,
  simdot: T2,
  sime: R2,
  simeq: q2,
  simg: M2,
  simgE: N2,
  siml: I2,
  simlE: F2,
  simne: L2,
  simplus: O2,
  simrarr: P2,
  slarr: B2,
  SmallCircle: $2,
  smallsetminus: z2,
  smashp: U2,
  smeparsl: H2,
  smid: j2,
  smile: V2,
  smt: G2,
  smte: Z2,
  smtes: K2,
  SOFTcy: W2,
  softcy: J2,
  solbar: Y2,
  solb: X2,
  sol: Q2,
  Sopf: e$,
  sopf: t$,
  spades: n$,
  spadesuit: r$,
  spar: s$,
  sqcap: o$,
  sqcaps: c$,
  sqcup: i$,
  sqcups: l$,
  Sqrt: a$,
  sqsub: u$,
  sqsube: f$,
  sqsubset: p$,
  sqsubseteq: h$,
  sqsup: d$,
  sqsupe: g$,
  sqsupset: m$,
  sqsupseteq: _$,
  square: b$,
  Square: v$,
  SquareIntersection: x$,
  SquareSubset: y$,
  SquareSubsetEqual: k$,
  SquareSuperset: E$,
  SquareSupersetEqual: w$,
  SquareUnion: C$,
  squarf: A$,
  squ: S$,
  squf: D$,
  srarr: T$,
  Sscr: R$,
  sscr: q$,
  ssetmn: M$,
  ssmile: N$,
  sstarf: I$,
  Star: F$,
  star: L$,
  starf: O$,
  straightepsilon: P$,
  straightphi: B$,
  strns: $$,
  sub: z$,
  Sub: U$,
  subdot: H$,
  subE: j$,
  sube: V$,
  subedot: G$,
  submult: Z$,
  subnE: K$,
  subne: W$,
  subplus: J$,
  subrarr: Y$,
  subset: X$,
  Subset: Q$,
  subseteq: ez,
  subseteqq: tz,
  SubsetEqual: nz,
  subsetneq: rz,
  subsetneqq: sz,
  subsim: oz,
  subsub: cz,
  subsup: iz,
  succapprox: lz,
  succ: az,
  succcurlyeq: uz,
  Succeeds: fz,
  SucceedsEqual: pz,
  SucceedsSlantEqual: hz,
  SucceedsTilde: dz,
  succeq: gz,
  succnapprox: mz,
  succneqq: _z,
  succnsim: bz,
  succsim: vz,
  SuchThat: xz,
  sum: yz,
  Sum: kz,
  sung: Ez,
  sup1: wz,
  sup2: Cz,
  sup3: Az,
  sup: Sz,
  Sup: Dz,
  supdot: Tz,
  supdsub: Rz,
  supE: qz,
  supe: Mz,
  supedot: Nz,
  Superset: Iz,
  SupersetEqual: Fz,
  suphsol: Lz,
  suphsub: Oz,
  suplarr: Pz,
  supmult: Bz,
  supnE: $z,
  supne: zz,
  supplus: Uz,
  supset: Hz,
  Supset: jz,
  supseteq: Vz,
  supseteqq: Gz,
  supsetneq: Zz,
  supsetneqq: Kz,
  supsim: Wz,
  supsub: Jz,
  supsup: Yz,
  swarhk: Xz,
  swarr: Qz,
  swArr: eU,
  swarrow: tU,
  swnwar: nU,
  szlig: rU,
  Tab: sU,
  target: oU,
  Tau: cU,
  tau: iU,
  tbrk: lU,
  Tcaron: aU,
  tcaron: uU,
  Tcedil: fU,
  tcedil: pU,
  Tcy: hU,
  tcy: dU,
  tdot: gU,
  telrec: mU,
  Tfr: _U,
  tfr: bU,
  there4: vU,
  therefore: xU,
  Therefore: yU,
  Theta: kU,
  theta: EU,
  thetasym: wU,
  thetav: CU,
  thickapprox: AU,
  thicksim: SU,
  ThickSpace: DU,
  ThinSpace: TU,
  thinsp: RU,
  thkap: qU,
  thksim: MU,
  THORN: NU,
  thorn: IU,
  tilde: FU,
  Tilde: LU,
  TildeEqual: OU,
  TildeFullEqual: PU,
  TildeTilde: BU,
  timesbar: $U,
  timesb: zU,
  times: UU,
  timesd: HU,
  tint: jU,
  toea: VU,
  topbot: GU,
  topcir: ZU,
  top: KU,
  Topf: WU,
  topf: JU,
  topfork: YU,
  tosa: XU,
  tprime: QU,
  trade: e3,
  TRADE: t3,
  triangle: n3,
  triangledown: r3,
  triangleleft: s3,
  trianglelefteq: o3,
  triangleq: c3,
  triangleright: i3,
  trianglerighteq: l3,
  tridot: a3,
  trie: u3,
  triminus: f3,
  TripleDot: p3,
  triplus: h3,
  trisb: d3,
  tritime: g3,
  trpezium: m3,
  Tscr: _3,
  tscr: b3,
  TScy: v3,
  tscy: x3,
  TSHcy: y3,
  tshcy: k3,
  Tstrok: E3,
  tstrok: w3,
  twixt: C3,
  twoheadleftarrow: A3,
  twoheadrightarrow: S3,
  Uacute: D3,
  uacute: T3,
  uarr: R3,
  Uarr: q3,
  uArr: M3,
  Uarrocir: N3,
  Ubrcy: I3,
  ubrcy: F3,
  Ubreve: L3,
  ubreve: O3,
  Ucirc: P3,
  ucirc: B3,
  Ucy: $3,
  ucy: z3,
  udarr: U3,
  Udblac: H3,
  udblac: j3,
  udhar: V3,
  ufisht: G3,
  Ufr: Z3,
  ufr: K3,
  Ugrave: W3,
  ugrave: J3,
  uHar: Y3,
  uharl: X3,
  uharr: Q3,
  uhblk: eH,
  ulcorn: tH,
  ulcorner: nH,
  ulcrop: rH,
  ultri: sH,
  Umacr: oH,
  umacr: cH,
  uml: iH,
  UnderBar: lH,
  UnderBrace: aH,
  UnderBracket: uH,
  UnderParenthesis: fH,
  Union: pH,
  UnionPlus: hH,
  Uogon: dH,
  uogon: gH,
  Uopf: mH,
  uopf: _H,
  UpArrowBar: bH,
  uparrow: vH,
  UpArrow: xH,
  Uparrow: yH,
  UpArrowDownArrow: kH,
  updownarrow: EH,
  UpDownArrow: wH,
  Updownarrow: CH,
  UpEquilibrium: AH,
  upharpoonleft: SH,
  upharpoonright: DH,
  uplus: TH,
  UpperLeftArrow: RH,
  UpperRightArrow: qH,
  upsi: MH,
  Upsi: NH,
  upsih: IH,
  Upsilon: FH,
  upsilon: LH,
  UpTeeArrow: OH,
  UpTee: PH,
  upuparrows: BH,
  urcorn: $H,
  urcorner: zH,
  urcrop: UH,
  Uring: HH,
  uring: jH,
  urtri: VH,
  Uscr: GH,
  uscr: ZH,
  utdot: KH,
  Utilde: WH,
  utilde: JH,
  utri: YH,
  utrif: XH,
  uuarr: QH,
  Uuml: e6,
  uuml: t6,
  uwangle: n6,
  vangrt: r6,
  varepsilon: s6,
  varkappa: o6,
  varnothing: c6,
  varphi: i6,
  varpi: l6,
  varpropto: a6,
  varr: u6,
  vArr: f6,
  varrho: p6,
  varsigma: h6,
  varsubsetneq: d6,
  varsubsetneqq: g6,
  varsupsetneq: m6,
  varsupsetneqq: _6,
  vartheta: b6,
  vartriangleleft: v6,
  vartriangleright: x6,
  vBar: y6,
  Vbar: k6,
  vBarv: E6,
  Vcy: w6,
  vcy: C6,
  vdash: A6,
  vDash: S6,
  Vdash: D6,
  VDash: T6,
  Vdashl: R6,
  veebar: q6,
  vee: M6,
  Vee: N6,
  veeeq: I6,
  vellip: F6,
  verbar: L6,
  Verbar: O6,
  vert: P6,
  Vert: B6,
  VerticalBar: $6,
  VerticalLine: z6,
  VerticalSeparator: U6,
  VerticalTilde: H6,
  VeryThinSpace: j6,
  Vfr: V6,
  vfr: G6,
  vltri: Z6,
  vnsub: K6,
  vnsup: W6,
  Vopf: J6,
  vopf: Y6,
  vprop: X6,
  vrtri: Q6,
  Vscr: e8,
  vscr: t8,
  vsubnE: n8,
  vsubne: r8,
  vsupnE: s8,
  vsupne: o8,
  Vvdash: c8,
  vzigzag: i8,
  Wcirc: l8,
  wcirc: a8,
  wedbar: u8,
  wedge: f8,
  Wedge: p8,
  wedgeq: h8,
  weierp: d8,
  Wfr: g8,
  wfr: m8,
  Wopf: _8,
  wopf: b8,
  wp: v8,
  wr: x8,
  wreath: y8,
  Wscr: k8,
  wscr: E8,
  xcap: w8,
  xcirc: C8,
  xcup: A8,
  xdtri: S8,
  Xfr: D8,
  xfr: T8,
  xharr: R8,
  xhArr: q8,
  Xi: M8,
  xi: N8,
  xlarr: I8,
  xlArr: F8,
  xmap: L8,
  xnis: O8,
  xodot: P8,
  Xopf: B8,
  xopf: $8,
  xoplus: z8,
  xotime: U8,
  xrarr: H8,
  xrArr: j8,
  Xscr: V8,
  xscr: G8,
  xsqcup: Z8,
  xuplus: K8,
  xutri: W8,
  xvee: J8,
  xwedge: Y8,
  Yacute: X8,
  yacute: Q8,
  YAcy: ej,
  yacy: tj,
  Ycirc: nj,
  ycirc: rj,
  Ycy: sj,
  ycy: oj,
  yen: cj,
  Yfr: ij,
  yfr: lj,
  YIcy: aj,
  yicy: uj,
  Yopf: fj,
  yopf: pj,
  Yscr: hj,
  yscr: dj,
  YUcy: gj,
  yucy: mj,
  yuml: _j,
  Yuml: bj,
  Zacute: vj,
  zacute: xj,
  Zcaron: yj,
  zcaron: kj,
  Zcy: Ej,
  zcy: wj,
  Zdot: Cj,
  zdot: Aj,
  zeetrf: Sj,
  ZeroWidthSpace: Dj,
  Zeta: Tj,
  zeta: Rj,
  zfr: qj,
  Zfr: Mj,
  ZHcy: Nj,
  zhcy: Ij,
  zigrarr: Fj,
  zopf: Lj,
  Zopf: Oj,
  Zscr: Pj,
  zscr: Bj,
  zwj: $j,
  zwnj: zj
};
var Ni = Uj, Os = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, Qt = {}, Po = {};
function Hj(t) {
  var e, n, r = Po[t];
  if (r)
    return r;
  for (r = Po[t] = [], e = 0; e < 128; e++)
    n = String.fromCharCode(e), /^[0-9a-z]$/i.test(n) ? r.push(n) : r.push("%" + ("0" + e.toString(16).toUpperCase()).slice(-2));
  for (e = 0; e < t.length; e++)
    r[t.charCodeAt(e)] = t[e];
  return r;
}
function _r(t, e, n) {
  var r, s, o, c, i, l = "";
  for (typeof e != "string" && (n = e, e = _r.defaultChars), typeof n > "u" && (n = !0), i = Hj(e), r = 0, s = t.length; r < s; r++) {
    if (o = t.charCodeAt(r), n && o === 37 && r + 2 < s && /^[0-9a-f]{2}$/i.test(t.slice(r + 1, r + 3))) {
      l += t.slice(r, r + 3), r += 2;
      continue;
    }
    if (o < 128) {
      l += i[o];
      continue;
    }
    if (o >= 55296 && o <= 57343) {
      if (o >= 55296 && o <= 56319 && r + 1 < s && (c = t.charCodeAt(r + 1), c >= 56320 && c <= 57343)) {
        l += encodeURIComponent(t[r] + t[r + 1]), r++;
        continue;
      }
      l += "%EF%BF%BD";
      continue;
    }
    l += encodeURIComponent(t[r]);
  }
  return l;
}
_r.defaultChars = ";/?:@&=+$,-_.!~*'()#";
_r.componentChars = "-_.!~*'()";
var jj = _r, Bo = {};
function Vj(t) {
  var e, n, r = Bo[t];
  if (r)
    return r;
  for (r = Bo[t] = [], e = 0; e < 128; e++)
    n = String.fromCharCode(e), r.push(n);
  for (e = 0; e < t.length; e++)
    n = t.charCodeAt(e), r[n] = "%" + ("0" + n.toString(16).toUpperCase()).slice(-2);
  return r;
}
function br(t, e) {
  var n;
  return typeof e != "string" && (e = br.defaultChars), n = Vj(e), t.replace(/(%[a-f0-9]{2})+/gi, function(r) {
    var s, o, c, i, l, a, u, f = "";
    for (s = 0, o = r.length; s < o; s += 3) {
      if (c = parseInt(r.slice(s + 1, s + 3), 16), c < 128) {
        f += n[c];
        continue;
      }
      if ((c & 224) === 192 && s + 3 < o && (i = parseInt(r.slice(s + 4, s + 6), 16), (i & 192) === 128)) {
        u = c << 6 & 1984 | i & 63, u < 128 ? f += "��" : f += String.fromCharCode(u), s += 3;
        continue;
      }
      if ((c & 240) === 224 && s + 6 < o && (i = parseInt(r.slice(s + 4, s + 6), 16), l = parseInt(r.slice(s + 7, s + 9), 16), (i & 192) === 128 && (l & 192) === 128)) {
        u = c << 12 & 61440 | i << 6 & 4032 | l & 63, u < 2048 || u >= 55296 && u <= 57343 ? f += "���" : f += String.fromCharCode(u), s += 6;
        continue;
      }
      if ((c & 248) === 240 && s + 9 < o && (i = parseInt(r.slice(s + 4, s + 6), 16), l = parseInt(r.slice(s + 7, s + 9), 16), a = parseInt(r.slice(s + 10, s + 12), 16), (i & 192) === 128 && (l & 192) === 128 && (a & 192) === 128)) {
        u = c << 18 & 1835008 | i << 12 & 258048 | l << 6 & 4032 | a & 63, u < 65536 || u > 1114111 ? f += "����" : (u -= 65536, f += String.fromCharCode(55296 + (u >> 10), 56320 + (u & 1023))), s += 9;
        continue;
      }
      f += "�";
    }
    return f;
  });
}
br.defaultChars = ";/?:@&=+$,#";
br.componentChars = "";
var Gj = br, Zj = function(e) {
  var n = "";
  return n += e.protocol || "", n += e.slashes ? "//" : "", n += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? n += "[" + e.hostname + "]" : n += e.hostname || "", n += e.port ? ":" + e.port : "", n += e.pathname || "", n += e.search || "", n += e.hash || "", n;
};
function tr() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
var Kj = /^([a-z0-9.+-]+:)/i, Wj = /:[0-9]*$/, Jj = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, Yj = ["<", ">", '"', "`", " ", "\r", `
`, "	"], Xj = ["{", "}", "|", "\\", "^", "`"].concat(Yj), Qj = ["'"].concat(Xj), $o = ["%", "/", "?", ";", "#"].concat(Qj), zo = ["/", "?", "#"], e4 = 255, Uo = /^[+a-z0-9A-Z_-]{0,63}$/, t4 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, Ho = {
  javascript: !0,
  "javascript:": !0
}, jo = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function n4(t, e) {
  if (t && t instanceof tr)
    return t;
  var n = new tr();
  return n.parse(t, e), n;
}
tr.prototype.parse = function(t, e) {
  var n, r, s, o, c, i = t;
  if (i = i.trim(), !e && t.split("#").length === 1) {
    var l = Jj.exec(i);
    if (l)
      return this.pathname = l[1], l[2] && (this.search = l[2]), this;
  }
  var a = Kj.exec(i);
  if (a && (a = a[0], s = a.toLowerCase(), this.protocol = a, i = i.substr(a.length)), (e || a || i.match(/^\/\/[^@\/]+@[^@\/]+/)) && (c = i.substr(0, 2) === "//", c && !(a && Ho[a]) && (i = i.substr(2), this.slashes = !0)), !Ho[a] && (c || a && !jo[a])) {
    var u = -1;
    for (n = 0; n < zo.length; n++)
      o = i.indexOf(zo[n]), o !== -1 && (u === -1 || o < u) && (u = o);
    var f, p;
    for (u === -1 ? p = i.lastIndexOf("@") : p = i.lastIndexOf("@", u), p !== -1 && (f = i.slice(0, p), i = i.slice(p + 1), this.auth = f), u = -1, n = 0; n < $o.length; n++)
      o = i.indexOf($o[n]), o !== -1 && (u === -1 || o < u) && (u = o);
    u === -1 && (u = i.length), i[u - 1] === ":" && u--;
    var d = i.slice(0, u);
    i = i.slice(u), this.parseHost(d), this.hostname = this.hostname || "";
    var k = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!k) {
      var b = this.hostname.split(/\./);
      for (n = 0, r = b.length; n < r; n++) {
        var I = b[n];
        if (I && !I.match(Uo)) {
          for (var T = "", C = 0, N = I.length; C < N; C++)
            I.charCodeAt(C) > 127 ? T += "x" : T += I[C];
          if (!T.match(Uo)) {
            var A = b.slice(0, n), j = b.slice(n + 1), q = I.match(t4);
            q && (A.push(q[1]), j.unshift(q[2])), j.length && (i = j.join(".") + i), this.hostname = A.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > e4 && (this.hostname = ""), k && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  var W = i.indexOf("#");
  W !== -1 && (this.hash = i.substr(W), i = i.slice(0, W));
  var $ = i.indexOf("?");
  return $ !== -1 && (this.search = i.substr($), i = i.slice(0, $)), i && (this.pathname = i), jo[s] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
tr.prototype.parseHost = function(t) {
  var e = Wj.exec(t);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t);
};
var r4 = n4;
Qt.encode = jj;
Qt.decode = Gj;
Qt.format = Zj;
Qt.parse = r4;
var vt = {}, Lr, Vo;
function Ii() {
  return Vo || (Vo = 1, Lr = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), Lr;
}
var Or, Go;
function Fi() {
  return Go || (Go = 1, Or = /[\0-\x1F\x7F-\x9F]/), Or;
}
var Pr, Zo;
function s4() {
  return Zo || (Zo = 1, Pr = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/), Pr;
}
var Br, Ko;
function Li() {
  return Ko || (Ko = 1, Br = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/), Br;
}
var Wo;
function o4() {
  return Wo || (Wo = 1, vt.Any = Ii(), vt.Cc = Fi(), vt.Cf = s4(), vt.P = Os, vt.Z = Li()), vt;
}
(function(t) {
  function e(D) {
    return Object.prototype.toString.call(D);
  }
  function n(D) {
    return e(D) === "[object String]";
  }
  var r = Object.prototype.hasOwnProperty;
  function s(D, ne) {
    return r.call(D, ne);
  }
  function o(D) {
    var ne = Array.prototype.slice.call(arguments, 1);
    return ne.forEach(function(V) {
      if (V) {
        if (typeof V != "object")
          throw new TypeError(V + "must be object");
        Object.keys(V).forEach(function(v) {
          D[v] = V[v];
        });
      }
    }), D;
  }
  function c(D, ne, V) {
    return [].concat(D.slice(0, ne), V, D.slice(ne + 1));
  }
  function i(D) {
    return !(D >= 55296 && D <= 57343 || D >= 64976 && D <= 65007 || (D & 65535) === 65535 || (D & 65535) === 65534 || D >= 0 && D <= 8 || D === 11 || D >= 14 && D <= 31 || D >= 127 && D <= 159 || D > 1114111);
  }
  function l(D) {
    if (D > 65535) {
      D -= 65536;
      var ne = 55296 + (D >> 10), V = 56320 + (D & 1023);
      return String.fromCharCode(ne, V);
    }
    return String.fromCharCode(D);
  }
  var a = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g, u = /&([a-z#][a-z0-9]{1,31});/gi, f = new RegExp(a.source + "|" + u.source, "gi"), p = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i, d = Ni;
  function k(D, ne) {
    var V = 0;
    return s(d, ne) ? d[ne] : ne.charCodeAt(0) === 35 && p.test(ne) && (V = ne[1].toLowerCase() === "x" ? parseInt(ne.slice(2), 16) : parseInt(ne.slice(1), 10), i(V)) ? l(V) : D;
  }
  function b(D) {
    return D.indexOf("\\") < 0 ? D : D.replace(a, "$1");
  }
  function I(D) {
    return D.indexOf("\\") < 0 && D.indexOf("&") < 0 ? D : D.replace(f, function(ne, V, v) {
      return V || k(ne, v);
    });
  }
  var T = /[&<>"]/, C = /[&<>"]/g, N = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function A(D) {
    return N[D];
  }
  function j(D) {
    return T.test(D) ? D.replace(C, A) : D;
  }
  var q = /[.?*+^$[\]\\(){}|-]/g;
  function W(D) {
    return D.replace(q, "\\$&");
  }
  function $(D) {
    switch (D) {
      case 9:
      case 32:
        return !0;
    }
    return !1;
  }
  function X(D) {
    if (D >= 8192 && D <= 8202)
      return !0;
    switch (D) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return !0;
    }
    return !1;
  }
  var z = Os;
  function J(D) {
    return z.test(D);
  }
  function B(D) {
    switch (D) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return !0;
      default:
        return !1;
    }
  }
  function re(D) {
    return D = D.trim().replace(/\s+/g, " "), "ẞ".toLowerCase() === "Ṿ" && (D = D.replace(/ẞ/g, "ß")), D.toLowerCase().toUpperCase();
  }
  t.lib = {}, t.lib.mdurl = Qt, t.lib.ucmicro = o4(), t.assign = o, t.isString = n, t.has = s, t.unescapeMd = b, t.unescapeAll = I, t.isValidEntityCode = i, t.fromCodePoint = l, t.escapeHtml = j, t.arrayReplaceAt = c, t.isSpace = $, t.isWhiteSpace = X, t.isMdAsciiPunct = B, t.isPunctChar = J, t.escapeRE = W, t.normalizeReference = re;
})(le);
var vr = {}, c4 = function(e, n, r) {
  var s, o, c, i, l = -1, a = e.posMax, u = e.pos;
  for (e.pos = n + 1, s = 1; e.pos < a; ) {
    if (c = e.src.charCodeAt(e.pos), c === 93 && (s--, s === 0)) {
      o = !0;
      break;
    }
    if (i = e.pos, e.md.inline.skipToken(e), c === 91) {
      if (i === e.pos - 1)
        s++;
      else if (r)
        return e.pos = u, -1;
    }
  }
  return o && (l = e.pos), e.pos = u, l;
}, Jo = le.unescapeAll, i4 = function(e, n, r) {
  var s, o, c = 0, i = n, l = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (e.charCodeAt(n) === 60) {
    for (n++; n < r; ) {
      if (s = e.charCodeAt(n), s === 10 || s === 60)
        return l;
      if (s === 62)
        return l.pos = n + 1, l.str = Jo(e.slice(i + 1, n)), l.ok = !0, l;
      if (s === 92 && n + 1 < r) {
        n += 2;
        continue;
      }
      n++;
    }
    return l;
  }
  for (o = 0; n < r && (s = e.charCodeAt(n), !(s === 32 || s < 32 || s === 127)); ) {
    if (s === 92 && n + 1 < r) {
      if (e.charCodeAt(n + 1) === 32)
        break;
      n += 2;
      continue;
    }
    if (s === 40 && (o++, o > 32))
      return l;
    if (s === 41) {
      if (o === 0)
        break;
      o--;
    }
    n++;
  }
  return i === n || o !== 0 || (l.str = Jo(e.slice(i, n)), l.lines = c, l.pos = n, l.ok = !0), l;
}, l4 = le.unescapeAll, a4 = function(e, n, r) {
  var s, o, c = 0, i = n, l = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (n >= r || (o = e.charCodeAt(n), o !== 34 && o !== 39 && o !== 40))
    return l;
  for (n++, o === 40 && (o = 41); n < r; ) {
    if (s = e.charCodeAt(n), s === o)
      return l.pos = n + 1, l.lines = c, l.str = l4(e.slice(i + 1, n)), l.ok = !0, l;
    if (s === 40 && o === 41)
      return l;
    s === 10 ? c++ : s === 92 && n + 1 < r && (n++, e.charCodeAt(n) === 10 && c++), n++;
  }
  return l;
};
vr.parseLinkLabel = c4;
vr.parseLinkDestination = i4;
vr.parseLinkTitle = a4;
var u4 = le.assign, f4 = le.unescapeAll, Rt = le.escapeHtml, Ye = {};
Ye.code_inline = function(t, e, n, r, s) {
  var o = t[e];
  return "<code" + s.renderAttrs(o) + ">" + Rt(t[e].content) + "</code>";
};
Ye.code_block = function(t, e, n, r, s) {
  var o = t[e];
  return "<pre" + s.renderAttrs(o) + "><code>" + Rt(t[e].content) + `</code></pre>
`;
};
Ye.fence = function(t, e, n, r, s) {
  var o = t[e], c = o.info ? f4(o.info).trim() : "", i = "", l = "", a, u, f, p, d;
  return c && (f = c.split(/(\s+)/g), i = f[0], l = f.slice(2).join("")), n.highlight ? a = n.highlight(o.content, i, l) || Rt(o.content) : a = Rt(o.content), a.indexOf("<pre") === 0 ? a + `
` : c ? (u = o.attrIndex("class"), p = o.attrs ? o.attrs.slice() : [], u < 0 ? p.push(["class", n.langPrefix + i]) : (p[u] = p[u].slice(), p[u][1] += " " + n.langPrefix + i), d = {
    attrs: p
  }, "<pre><code" + s.renderAttrs(d) + ">" + a + `</code></pre>
`) : "<pre><code" + s.renderAttrs(o) + ">" + a + `</code></pre>
`;
};
Ye.image = function(t, e, n, r, s) {
  var o = t[e];
  return o.attrs[o.attrIndex("alt")][1] = s.renderInlineAsText(o.children, n, r), s.renderToken(t, e, n);
};
Ye.hardbreak = function(t, e, n) {
  return n.xhtmlOut ? `<br />
` : `<br>
`;
};
Ye.softbreak = function(t, e, n) {
  return n.breaks ? n.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
Ye.text = function(t, e) {
  return Rt(t[e].content);
};
Ye.html_block = function(t, e) {
  return t[e].content;
};
Ye.html_inline = function(t, e) {
  return t[e].content;
};
function en() {
  this.rules = u4({}, Ye);
}
en.prototype.renderAttrs = function(e) {
  var n, r, s;
  if (!e.attrs)
    return "";
  for (s = "", n = 0, r = e.attrs.length; n < r; n++)
    s += " " + Rt(e.attrs[n][0]) + '="' + Rt(e.attrs[n][1]) + '"';
  return s;
};
en.prototype.renderToken = function(e, n, r) {
  var s, o = "", c = !1, i = e[n];
  return i.hidden ? "" : (i.block && i.nesting !== -1 && n && e[n - 1].hidden && (o += `
`), o += (i.nesting === -1 ? "</" : "<") + i.tag, o += this.renderAttrs(i), i.nesting === 0 && r.xhtmlOut && (o += " /"), i.block && (c = !0, i.nesting === 1 && n + 1 < e.length && (s = e[n + 1], (s.type === "inline" || s.hidden || s.nesting === -1 && s.tag === i.tag) && (c = !1))), o += c ? `>
` : ">", o);
};
en.prototype.renderInline = function(t, e, n) {
  for (var r, s = "", o = this.rules, c = 0, i = t.length; c < i; c++)
    r = t[c].type, typeof o[r] < "u" ? s += o[r](t, c, e, n, this) : s += this.renderToken(t, c, e);
  return s;
};
en.prototype.renderInlineAsText = function(t, e, n) {
  for (var r = "", s = 0, o = t.length; s < o; s++)
    t[s].type === "text" ? r += t[s].content : t[s].type === "image" ? r += this.renderInlineAsText(t[s].children, e, n) : t[s].type === "softbreak" && (r += `
`);
  return r;
};
en.prototype.render = function(t, e, n) {
  var r, s, o, c = "", i = this.rules;
  for (r = 0, s = t.length; r < s; r++)
    o = t[r].type, o === "inline" ? c += this.renderInline(t[r].children, e, n) : typeof i[o] < "u" ? c += i[t[r].type](t, r, e, n, this) : c += this.renderToken(t, r, e, n);
  return c;
};
var p4 = en;
function je() {
  this.__rules__ = [], this.__cache__ = null;
}
je.prototype.__find__ = function(t) {
  for (var e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === t)
      return e;
  return -1;
};
je.prototype.__compile__ = function() {
  var t = this, e = [""];
  t.__rules__.forEach(function(n) {
    n.enabled && n.alt.forEach(function(r) {
      e.indexOf(r) < 0 && e.push(r);
    });
  }), t.__cache__ = {}, e.forEach(function(n) {
    t.__cache__[n] = [], t.__rules__.forEach(function(r) {
      r.enabled && (n && r.alt.indexOf(n) < 0 || t.__cache__[n].push(r.fn));
    });
  });
};
je.prototype.at = function(t, e, n) {
  var r = this.__find__(t), s = n || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__[r].fn = e, this.__rules__[r].alt = s.alt || [], this.__cache__ = null;
};
je.prototype.before = function(t, e, n, r) {
  var s = this.__find__(t), o = r || {};
  if (s === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__.splice(s, 0, {
    name: e,
    enabled: !0,
    fn: n,
    alt: o.alt || []
  }), this.__cache__ = null;
};
je.prototype.after = function(t, e, n, r) {
  var s = this.__find__(t), o = r || {};
  if (s === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__.splice(s + 1, 0, {
    name: e,
    enabled: !0,
    fn: n,
    alt: o.alt || []
  }), this.__cache__ = null;
};
je.prototype.push = function(t, e, n) {
  var r = n || {};
  this.__rules__.push({
    name: t,
    enabled: !0,
    fn: e,
    alt: r.alt || []
  }), this.__cache__ = null;
};
je.prototype.enable = function(t, e) {
  Array.isArray(t) || (t = [t]);
  var n = [];
  return t.forEach(function(r) {
    var s = this.__find__(r);
    if (s < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[s].enabled = !0, n.push(r);
  }, this), this.__cache__ = null, n;
};
je.prototype.enableOnly = function(t, e) {
  Array.isArray(t) || (t = [t]), this.__rules__.forEach(function(n) {
    n.enabled = !1;
  }), this.enable(t, e);
};
je.prototype.disable = function(t, e) {
  Array.isArray(t) || (t = [t]);
  var n = [];
  return t.forEach(function(r) {
    var s = this.__find__(r);
    if (s < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[s].enabled = !1, n.push(r);
  }, this), this.__cache__ = null, n;
};
je.prototype.getRules = function(t) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[t] || [];
};
var Ps = je, h4 = /\r\n?|\n/g, d4 = /\0/g, g4 = function(e) {
  var n;
  n = e.src.replace(h4, `
`), n = n.replace(d4, "�"), e.src = n;
}, m4 = function(e) {
  var n;
  e.inlineMode ? (n = new e.Token("inline", "", 0), n.content = e.src, n.map = [0, 1], n.children = [], e.tokens.push(n)) : e.md.block.parse(e.src, e.md, e.env, e.tokens);
}, _4 = function(e) {
  var n = e.tokens, r, s, o;
  for (s = 0, o = n.length; s < o; s++)
    r = n[s], r.type === "inline" && e.md.inline.parse(r.content, e.md, e.env, r.children);
}, b4 = le.arrayReplaceAt;
function v4(t) {
  return /^<a[>\s]/i.test(t);
}
function x4(t) {
  return /^<\/a\s*>/i.test(t);
}
var y4 = function(e) {
  var n, r, s, o, c, i, l, a, u, f, p, d, k, b, I, T, C = e.tokens, N;
  if (e.md.options.linkify) {
    for (r = 0, s = C.length; r < s; r++)
      if (!(C[r].type !== "inline" || !e.md.linkify.pretest(C[r].content)))
        for (o = C[r].children, k = 0, n = o.length - 1; n >= 0; n--) {
          if (i = o[n], i.type === "link_close") {
            for (n--; o[n].level !== i.level && o[n].type !== "link_open"; )
              n--;
            continue;
          }
          if (i.type === "html_inline" && (v4(i.content) && k > 0 && k--, x4(i.content) && k++), !(k > 0) && i.type === "text" && e.md.linkify.test(i.content)) {
            for (u = i.content, N = e.md.linkify.match(u), l = [], d = i.level, p = 0, a = 0; a < N.length; a++)
              b = N[a].url, I = e.md.normalizeLink(b), e.md.validateLink(I) && (T = N[a].text, N[a].schema ? N[a].schema === "mailto:" && !/^mailto:/i.test(T) ? T = e.md.normalizeLinkText("mailto:" + T).replace(/^mailto:/, "") : T = e.md.normalizeLinkText(T) : T = e.md.normalizeLinkText("http://" + T).replace(/^http:\/\//, ""), f = N[a].index, f > p && (c = new e.Token("text", "", 0), c.content = u.slice(p, f), c.level = d, l.push(c)), c = new e.Token("link_open", "a", 1), c.attrs = [["href", I]], c.level = d++, c.markup = "linkify", c.info = "auto", l.push(c), c = new e.Token("text", "", 0), c.content = T, c.level = d, l.push(c), c = new e.Token("link_close", "a", -1), c.level = --d, c.markup = "linkify", c.info = "auto", l.push(c), p = N[a].lastIndex);
            p < u.length && (c = new e.Token("text", "", 0), c.content = u.slice(p), c.level = d, l.push(c)), C[r].children = o = b4(o, n, l);
          }
        }
  }
}, Oi = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, k4 = /\((c|tm|r|p)\)/i, E4 = /\((c|tm|r|p)\)/ig, w4 = {
  c: "©",
  r: "®",
  p: "§",
  tm: "™"
};
function C4(t, e) {
  return w4[e.toLowerCase()];
}
function A4(t) {
  var e, n, r = 0;
  for (e = t.length - 1; e >= 0; e--)
    n = t[e], n.type === "text" && !r && (n.content = n.content.replace(E4, C4)), n.type === "link_open" && n.info === "auto" && r--, n.type === "link_close" && n.info === "auto" && r++;
}
function S4(t) {
  var e, n, r = 0;
  for (e = t.length - 1; e >= 0; e--)
    n = t[e], n.type === "text" && !r && Oi.test(n.content) && (n.content = n.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–")), n.type === "link_open" && n.info === "auto" && r--, n.type === "link_close" && n.info === "auto" && r++;
}
var D4 = function(e) {
  var n;
  if (e.md.options.typographer)
    for (n = e.tokens.length - 1; n >= 0; n--)
      e.tokens[n].type === "inline" && (k4.test(e.tokens[n].content) && A4(e.tokens[n].children), Oi.test(e.tokens[n].content) && S4(e.tokens[n].children));
}, Yo = le.isWhiteSpace, Xo = le.isPunctChar, Qo = le.isMdAsciiPunct, T4 = /['"]/, ec = /['"]/g, tc = "’";
function Pn(t, e, n) {
  return t.substr(0, e) + n + t.substr(e + 1);
}
function R4(t, e) {
  var n, r, s, o, c, i, l, a, u, f, p, d, k, b, I, T, C, N, A, j, q;
  for (A = [], n = 0; n < t.length; n++) {
    for (r = t[n], l = t[n].level, C = A.length - 1; C >= 0 && !(A[C].level <= l); C--)
      ;
    if (A.length = C + 1, r.type === "text") {
      s = r.content, c = 0, i = s.length;
      e:
        for (; c < i && (ec.lastIndex = c, o = ec.exec(s), !!o); ) {
          if (I = T = !0, c = o.index + 1, N = o[0] === "'", u = 32, o.index - 1 >= 0)
            u = s.charCodeAt(o.index - 1);
          else
            for (C = n - 1; C >= 0 && !(t[C].type === "softbreak" || t[C].type === "hardbreak"); C--)
              if (t[C].content) {
                u = t[C].content.charCodeAt(t[C].content.length - 1);
                break;
              }
          if (f = 32, c < i)
            f = s.charCodeAt(c);
          else
            for (C = n + 1; C < t.length && !(t[C].type === "softbreak" || t[C].type === "hardbreak"); C++)
              if (t[C].content) {
                f = t[C].content.charCodeAt(0);
                break;
              }
          if (p = Qo(u) || Xo(String.fromCharCode(u)), d = Qo(f) || Xo(String.fromCharCode(f)), k = Yo(u), b = Yo(f), b ? I = !1 : d && (k || p || (I = !1)), k ? T = !1 : p && (b || d || (T = !1)), f === 34 && o[0] === '"' && u >= 48 && u <= 57 && (T = I = !1), I && T && (I = p, T = d), !I && !T) {
            N && (r.content = Pn(r.content, o.index, tc));
            continue;
          }
          if (T) {
            for (C = A.length - 1; C >= 0 && (a = A[C], !(A[C].level < l)); C--)
              if (a.single === N && A[C].level === l) {
                a = A[C], N ? (j = e.md.options.quotes[2], q = e.md.options.quotes[3]) : (j = e.md.options.quotes[0], q = e.md.options.quotes[1]), r.content = Pn(r.content, o.index, q), t[a.token].content = Pn(
                  t[a.token].content,
                  a.pos,
                  j
                ), c += q.length - 1, a.token === n && (c += j.length - 1), s = r.content, i = s.length, A.length = C;
                continue e;
              }
          }
          I ? A.push({
            token: n,
            pos: o.index,
            single: N,
            level: l
          }) : T && N && (r.content = Pn(r.content, o.index, tc));
        }
    }
  }
}
var q4 = function(e) {
  var n;
  if (e.md.options.typographer)
    for (n = e.tokens.length - 1; n >= 0; n--)
      e.tokens[n].type !== "inline" || !T4.test(e.tokens[n].content) || R4(e.tokens[n].children, e);
};
function tn(t, e, n) {
  this.type = t, this.tag = e, this.attrs = null, this.map = null, this.nesting = n, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
tn.prototype.attrIndex = function(e) {
  var n, r, s;
  if (!this.attrs)
    return -1;
  for (n = this.attrs, r = 0, s = n.length; r < s; r++)
    if (n[r][0] === e)
      return r;
  return -1;
};
tn.prototype.attrPush = function(e) {
  this.attrs ? this.attrs.push(e) : this.attrs = [e];
};
tn.prototype.attrSet = function(e, n) {
  var r = this.attrIndex(e), s = [e, n];
  r < 0 ? this.attrPush(s) : this.attrs[r] = s;
};
tn.prototype.attrGet = function(e) {
  var n = this.attrIndex(e), r = null;
  return n >= 0 && (r = this.attrs[n][1]), r;
};
tn.prototype.attrJoin = function(e, n) {
  var r = this.attrIndex(e);
  r < 0 ? this.attrPush([e, n]) : this.attrs[r][1] = this.attrs[r][1] + " " + n;
};
var Bs = tn, M4 = Bs;
function Pi(t, e, n) {
  this.src = t, this.env = n, this.tokens = [], this.inlineMode = !1, this.md = e;
}
Pi.prototype.Token = M4;
var N4 = Pi, I4 = Ps, $r = [
  ["normalize", g4],
  ["block", m4],
  ["inline", _4],
  ["linkify", y4],
  ["replacements", D4],
  ["smartquotes", q4]
];
function $s() {
  this.ruler = new I4();
  for (var t = 0; t < $r.length; t++)
    this.ruler.push($r[t][0], $r[t][1]);
}
$s.prototype.process = function(t) {
  var e, n, r;
  for (r = this.ruler.getRules(""), e = 0, n = r.length; e < n; e++)
    r[e](t);
};
$s.prototype.State = N4;
var F4 = $s, zr = le.isSpace;
function Ur(t, e) {
  var n = t.bMarks[e] + t.tShift[e], r = t.eMarks[e];
  return t.src.substr(n, r - n);
}
function nc(t) {
  var e = [], n = 0, r = t.length, s, o = !1, c = 0, i = "";
  for (s = t.charCodeAt(n); n < r; )
    s === 124 && (o ? (i += t.substring(c, n - 1), c = n) : (e.push(i + t.substring(c, n)), i = "", c = n + 1)), o = s === 92, n++, s = t.charCodeAt(n);
  return e.push(i + t.substring(c)), e;
}
var L4 = function(e, n, r, s) {
  var o, c, i, l, a, u, f, p, d, k, b, I, T, C, N, A, j, q;
  if (n + 2 > r || (u = n + 1, e.sCount[u] < e.blkIndent) || e.sCount[u] - e.blkIndent >= 4 || (i = e.bMarks[u] + e.tShift[u], i >= e.eMarks[u]) || (j = e.src.charCodeAt(i++), j !== 124 && j !== 45 && j !== 58) || i >= e.eMarks[u] || (q = e.src.charCodeAt(i++), q !== 124 && q !== 45 && q !== 58 && !zr(q)) || j === 45 && zr(q))
    return !1;
  for (; i < e.eMarks[u]; ) {
    if (o = e.src.charCodeAt(i), o !== 124 && o !== 45 && o !== 58 && !zr(o))
      return !1;
    i++;
  }
  for (c = Ur(e, n + 1), f = c.split("|"), k = [], l = 0; l < f.length; l++) {
    if (b = f[l].trim(), !b) {
      if (l === 0 || l === f.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(b))
      return !1;
    b.charCodeAt(b.length - 1) === 58 ? k.push(b.charCodeAt(0) === 58 ? "center" : "right") : b.charCodeAt(0) === 58 ? k.push("left") : k.push("");
  }
  if (c = Ur(e, n).trim(), c.indexOf("|") === -1 || e.sCount[n] - e.blkIndent >= 4 || (f = nc(c), f.length && f[0] === "" && f.shift(), f.length && f[f.length - 1] === "" && f.pop(), p = f.length, p === 0 || p !== k.length))
    return !1;
  if (s)
    return !0;
  for (C = e.parentType, e.parentType = "table", A = e.md.block.ruler.getRules("blockquote"), d = e.push("table_open", "table", 1), d.map = I = [n, 0], d = e.push("thead_open", "thead", 1), d.map = [n, n + 1], d = e.push("tr_open", "tr", 1), d.map = [n, n + 1], l = 0; l < f.length; l++)
    d = e.push("th_open", "th", 1), k[l] && (d.attrs = [["style", "text-align:" + k[l]]]), d = e.push("inline", "", 0), d.content = f[l].trim(), d.children = [], d = e.push("th_close", "th", -1);
  for (d = e.push("tr_close", "tr", -1), d = e.push("thead_close", "thead", -1), u = n + 2; u < r && !(e.sCount[u] < e.blkIndent); u++) {
    for (N = !1, l = 0, a = A.length; l < a; l++)
      if (A[l](e, u, r, !0)) {
        N = !0;
        break;
      }
    if (N || (c = Ur(e, u).trim(), !c) || e.sCount[u] - e.blkIndent >= 4)
      break;
    for (f = nc(c), f.length && f[0] === "" && f.shift(), f.length && f[f.length - 1] === "" && f.pop(), u === n + 2 && (d = e.push("tbody_open", "tbody", 1), d.map = T = [n + 2, 0]), d = e.push("tr_open", "tr", 1), d.map = [u, u + 1], l = 0; l < p; l++)
      d = e.push("td_open", "td", 1), k[l] && (d.attrs = [["style", "text-align:" + k[l]]]), d = e.push("inline", "", 0), d.content = f[l] ? f[l].trim() : "", d.children = [], d = e.push("td_close", "td", -1);
    d = e.push("tr_close", "tr", -1);
  }
  return T && (d = e.push("tbody_close", "tbody", -1), T[1] = u), d = e.push("table_close", "table", -1), I[1] = u, e.parentType = C, e.line = u, !0;
}, O4 = function(e, n, r) {
  var s, o, c;
  if (e.sCount[n] - e.blkIndent < 4)
    return !1;
  for (o = s = n + 1; s < r; ) {
    if (e.isEmpty(s)) {
      s++;
      continue;
    }
    if (e.sCount[s] - e.blkIndent >= 4) {
      s++, o = s;
      continue;
    }
    break;
  }
  return e.line = o, c = e.push("code_block", "code", 0), c.content = e.getLines(n, o, 4 + e.blkIndent, !1) + `
`, c.map = [n, e.line], !0;
}, P4 = function(e, n, r, s) {
  var o, c, i, l, a, u, f, p = !1, d = e.bMarks[n] + e.tShift[n], k = e.eMarks[n];
  if (e.sCount[n] - e.blkIndent >= 4 || d + 3 > k || (o = e.src.charCodeAt(d), o !== 126 && o !== 96) || (a = d, d = e.skipChars(d, o), c = d - a, c < 3) || (f = e.src.slice(a, d), i = e.src.slice(d, k), o === 96 && i.indexOf(String.fromCharCode(o)) >= 0))
    return !1;
  if (s)
    return !0;
  for (l = n; l++, !(l >= r || (d = a = e.bMarks[l] + e.tShift[l], k = e.eMarks[l], d < k && e.sCount[l] < e.blkIndent)); )
    if (e.src.charCodeAt(d) === o && !(e.sCount[l] - e.blkIndent >= 4) && (d = e.skipChars(d, o), !(d - a < c) && (d = e.skipSpaces(d), !(d < k)))) {
      p = !0;
      break;
    }
  return c = e.sCount[n], e.line = l + (p ? 1 : 0), u = e.push("fence", "code", 0), u.info = i, u.content = e.getLines(n + 1, l, c, !0), u.markup = f, u.map = [n, e.line], !0;
}, rc = le.isSpace, B4 = function(e, n, r, s) {
  var o, c, i, l, a, u, f, p, d, k, b, I, T, C, N, A, j, q, W, $, X = e.lineMax, z = e.bMarks[n] + e.tShift[n], J = e.eMarks[n];
  if (e.sCount[n] - e.blkIndent >= 4 || e.src.charCodeAt(z++) !== 62)
    return !1;
  if (s)
    return !0;
  for (l = d = e.sCount[n] + 1, e.src.charCodeAt(z) === 32 ? (z++, l++, d++, o = !1, A = !0) : e.src.charCodeAt(z) === 9 ? (A = !0, (e.bsCount[n] + d) % 4 === 3 ? (z++, l++, d++, o = !1) : o = !0) : A = !1, k = [e.bMarks[n]], e.bMarks[n] = z; z < J && (c = e.src.charCodeAt(z), rc(c)); ) {
    c === 9 ? d += 4 - (d + e.bsCount[n] + (o ? 1 : 0)) % 4 : d++;
    z++;
  }
  for (b = [e.bsCount[n]], e.bsCount[n] = e.sCount[n] + 1 + (A ? 1 : 0), u = z >= J, C = [e.sCount[n]], e.sCount[n] = d - l, N = [e.tShift[n]], e.tShift[n] = z - e.bMarks[n], q = e.md.block.ruler.getRules("blockquote"), T = e.parentType, e.parentType = "blockquote", p = n + 1; p < r && ($ = e.sCount[p] < e.blkIndent, z = e.bMarks[p] + e.tShift[p], J = e.eMarks[p], !(z >= J)); p++) {
    if (e.src.charCodeAt(z++) === 62 && !$) {
      for (l = d = e.sCount[p] + 1, e.src.charCodeAt(z) === 32 ? (z++, l++, d++, o = !1, A = !0) : e.src.charCodeAt(z) === 9 ? (A = !0, (e.bsCount[p] + d) % 4 === 3 ? (z++, l++, d++, o = !1) : o = !0) : A = !1, k.push(e.bMarks[p]), e.bMarks[p] = z; z < J && (c = e.src.charCodeAt(z), rc(c)); ) {
        c === 9 ? d += 4 - (d + e.bsCount[p] + (o ? 1 : 0)) % 4 : d++;
        z++;
      }
      u = z >= J, b.push(e.bsCount[p]), e.bsCount[p] = e.sCount[p] + 1 + (A ? 1 : 0), C.push(e.sCount[p]), e.sCount[p] = d - l, N.push(e.tShift[p]), e.tShift[p] = z - e.bMarks[p];
      continue;
    }
    if (u)
      break;
    for (j = !1, i = 0, a = q.length; i < a; i++)
      if (q[i](e, p, r, !0)) {
        j = !0;
        break;
      }
    if (j) {
      e.lineMax = p, e.blkIndent !== 0 && (k.push(e.bMarks[p]), b.push(e.bsCount[p]), N.push(e.tShift[p]), C.push(e.sCount[p]), e.sCount[p] -= e.blkIndent);
      break;
    }
    k.push(e.bMarks[p]), b.push(e.bsCount[p]), N.push(e.tShift[p]), C.push(e.sCount[p]), e.sCount[p] = -1;
  }
  for (I = e.blkIndent, e.blkIndent = 0, W = e.push("blockquote_open", "blockquote", 1), W.markup = ">", W.map = f = [n, 0], e.md.block.tokenize(e, n, p), W = e.push("blockquote_close", "blockquote", -1), W.markup = ">", e.lineMax = X, e.parentType = T, f[1] = e.line, i = 0; i < N.length; i++)
    e.bMarks[i + n] = k[i], e.tShift[i + n] = N[i], e.sCount[i + n] = C[i], e.bsCount[i + n] = b[i];
  return e.blkIndent = I, !0;
}, $4 = le.isSpace, z4 = function(e, n, r, s) {
  var o, c, i, l, a = e.bMarks[n] + e.tShift[n], u = e.eMarks[n];
  if (e.sCount[n] - e.blkIndent >= 4 || (o = e.src.charCodeAt(a++), o !== 42 && o !== 45 && o !== 95))
    return !1;
  for (c = 1; a < u; ) {
    if (i = e.src.charCodeAt(a++), i !== o && !$4(i))
      return !1;
    i === o && c++;
  }
  return c < 3 ? !1 : (s || (e.line = n + 1, l = e.push("hr", "hr", 0), l.map = [n, e.line], l.markup = Array(c + 1).join(String.fromCharCode(o))), !0);
}, Bi = le.isSpace;
function sc(t, e) {
  var n, r, s, o;
  return r = t.bMarks[e] + t.tShift[e], s = t.eMarks[e], n = t.src.charCodeAt(r++), n !== 42 && n !== 45 && n !== 43 || r < s && (o = t.src.charCodeAt(r), !Bi(o)) ? -1 : r;
}
function oc(t, e) {
  var n, r = t.bMarks[e] + t.tShift[e], s = r, o = t.eMarks[e];
  if (s + 1 >= o || (n = t.src.charCodeAt(s++), n < 48 || n > 57))
    return -1;
  for (; ; ) {
    if (s >= o)
      return -1;
    if (n = t.src.charCodeAt(s++), n >= 48 && n <= 57) {
      if (s - r >= 10)
        return -1;
      continue;
    }
    if (n === 41 || n === 46)
      break;
    return -1;
  }
  return s < o && (n = t.src.charCodeAt(s), !Bi(n)) ? -1 : s;
}
function U4(t, e) {
  var n, r, s = t.level + 2;
  for (n = e + 2, r = t.tokens.length - 2; n < r; n++)
    t.tokens[n].level === s && t.tokens[n].type === "paragraph_open" && (t.tokens[n + 2].hidden = !0, t.tokens[n].hidden = !0, n += 2);
}
var H4 = function(e, n, r, s) {
  var o, c, i, l, a, u, f, p, d, k, b, I, T, C, N, A, j, q, W, $, X, z, J, B, re, D, ne, V, v = !1, S = !0;
  if (e.sCount[n] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[n] - e.listIndent >= 4 && e.sCount[n] < e.blkIndent)
    return !1;
  if (s && e.parentType === "paragraph" && e.sCount[n] >= e.blkIndent && (v = !0), (J = oc(e, n)) >= 0) {
    if (f = !0, re = e.bMarks[n] + e.tShift[n], T = Number(e.src.slice(re, J - 1)), v && T !== 1)
      return !1;
  } else if ((J = sc(e, n)) >= 0)
    f = !1;
  else
    return !1;
  if (v && e.skipSpaces(J) >= e.eMarks[n])
    return !1;
  if (I = e.src.charCodeAt(J - 1), s)
    return !0;
  for (b = e.tokens.length, f ? (V = e.push("ordered_list_open", "ol", 1), T !== 1 && (V.attrs = [["start", T]])) : V = e.push("bullet_list_open", "ul", 1), V.map = k = [n, 0], V.markup = String.fromCharCode(I), N = n, B = !1, ne = e.md.block.ruler.getRules("list"), q = e.parentType, e.parentType = "list"; N < r; ) {
    for (z = J, C = e.eMarks[N], u = A = e.sCount[N] + J - (e.bMarks[n] + e.tShift[n]); z < C; ) {
      if (o = e.src.charCodeAt(z), o === 9)
        A += 4 - (A + e.bsCount[N]) % 4;
      else if (o === 32)
        A++;
      else
        break;
      z++;
    }
    if (c = z, c >= C ? a = 1 : a = A - u, a > 4 && (a = 1), l = u + a, V = e.push("list_item_open", "li", 1), V.markup = String.fromCharCode(I), V.map = p = [n, 0], f && (V.info = e.src.slice(re, J - 1)), X = e.tight, $ = e.tShift[n], W = e.sCount[n], j = e.listIndent, e.listIndent = e.blkIndent, e.blkIndent = l, e.tight = !0, e.tShift[n] = c - e.bMarks[n], e.sCount[n] = A, c >= C && e.isEmpty(n + 1) ? e.line = Math.min(e.line + 2, r) : e.md.block.tokenize(e, n, r, !0), (!e.tight || B) && (S = !1), B = e.line - n > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = j, e.tShift[n] = $, e.sCount[n] = W, e.tight = X, V = e.push("list_item_close", "li", -1), V.markup = String.fromCharCode(I), N = n = e.line, p[1] = N, c = e.bMarks[n], N >= r || e.sCount[N] < e.blkIndent || e.sCount[n] - e.blkIndent >= 4)
      break;
    for (D = !1, i = 0, d = ne.length; i < d; i++)
      if (ne[i](e, N, r, !0)) {
        D = !0;
        break;
      }
    if (D)
      break;
    if (f) {
      if (J = oc(e, N), J < 0)
        break;
      re = e.bMarks[N] + e.tShift[N];
    } else if (J = sc(e, N), J < 0)
      break;
    if (I !== e.src.charCodeAt(J - 1))
      break;
  }
  return f ? V = e.push("ordered_list_close", "ol", -1) : V = e.push("bullet_list_close", "ul", -1), V.markup = String.fromCharCode(I), k[1] = N, e.line = N, e.parentType = q, S && U4(e, b), !0;
}, j4 = le.normalizeReference, Bn = le.isSpace, V4 = function(e, n, r, s) {
  var o, c, i, l, a, u, f, p, d, k, b, I, T, C, N, A, j = 0, q = e.bMarks[n] + e.tShift[n], W = e.eMarks[n], $ = n + 1;
  if (e.sCount[n] - e.blkIndent >= 4 || e.src.charCodeAt(q) !== 91)
    return !1;
  for (; ++q < W; )
    if (e.src.charCodeAt(q) === 93 && e.src.charCodeAt(q - 1) !== 92) {
      if (q + 1 === W || e.src.charCodeAt(q + 1) !== 58)
        return !1;
      break;
    }
  for (l = e.lineMax, N = e.md.block.ruler.getRules("reference"), k = e.parentType, e.parentType = "reference"; $ < l && !e.isEmpty($); $++)
    if (!(e.sCount[$] - e.blkIndent > 3) && !(e.sCount[$] < 0)) {
      for (C = !1, u = 0, f = N.length; u < f; u++)
        if (N[u](e, $, l, !0)) {
          C = !0;
          break;
        }
      if (C)
        break;
    }
  for (T = e.getLines(n, $, e.blkIndent, !1).trim(), W = T.length, q = 1; q < W; q++) {
    if (o = T.charCodeAt(q), o === 91)
      return !1;
    if (o === 93) {
      d = q;
      break;
    } else
      o === 10 ? j++ : o === 92 && (q++, q < W && T.charCodeAt(q) === 10 && j++);
  }
  if (d < 0 || T.charCodeAt(d + 1) !== 58)
    return !1;
  for (q = d + 2; q < W; q++)
    if (o = T.charCodeAt(q), o === 10)
      j++;
    else if (!Bn(o))
      break;
  if (b = e.md.helpers.parseLinkDestination(T, q, W), !b.ok || (a = e.md.normalizeLink(b.str), !e.md.validateLink(a)))
    return !1;
  for (q = b.pos, j += b.lines, c = q, i = j, I = q; q < W; q++)
    if (o = T.charCodeAt(q), o === 10)
      j++;
    else if (!Bn(o))
      break;
  for (b = e.md.helpers.parseLinkTitle(T, q, W), q < W && I !== q && b.ok ? (A = b.str, q = b.pos, j += b.lines) : (A = "", q = c, j = i); q < W && (o = T.charCodeAt(q), !!Bn(o)); )
    q++;
  if (q < W && T.charCodeAt(q) !== 10 && A)
    for (A = "", q = c, j = i; q < W && (o = T.charCodeAt(q), !!Bn(o)); )
      q++;
  return q < W && T.charCodeAt(q) !== 10 || (p = j4(T.slice(1, d)), !p) ? !1 : (s || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[p] > "u" && (e.env.references[p] = { title: A, href: a }), e.parentType = k, e.line = n + j + 1), !0);
}, G4 = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], xr = {}, Z4 = "[a-zA-Z_:][a-zA-Z0-9:._-]*", K4 = "[^\"'=<>`\\x00-\\x20]+", W4 = "'[^']*'", J4 = '"[^"]*"', Y4 = "(?:" + K4 + "|" + W4 + "|" + J4 + ")", X4 = "(?:\\s+" + Z4 + "(?:\\s*=\\s*" + Y4 + ")?)", $i = "<[A-Za-z][A-Za-z0-9\\-]*" + X4 + "*\\s*\\/?>", zi = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", Q4 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", eV = "<[?][\\s\\S]*?[?]>", tV = "<![A-Z]+\\s+[^>]*>", nV = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", rV = new RegExp("^(?:" + $i + "|" + zi + "|" + Q4 + "|" + eV + "|" + tV + "|" + nV + ")"), sV = new RegExp("^(?:" + $i + "|" + zi + ")");
xr.HTML_TAG_RE = rV;
xr.HTML_OPEN_CLOSE_TAG_RE = sV;
var oV = G4, cV = xr.HTML_OPEN_CLOSE_TAG_RE, Ft = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + oV.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(cV.source + "\\s*$"), /^$/, !1]
], iV = function(e, n, r, s) {
  var o, c, i, l, a = e.bMarks[n] + e.tShift[n], u = e.eMarks[n];
  if (e.sCount[n] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(a) !== 60)
    return !1;
  for (l = e.src.slice(a, u), o = 0; o < Ft.length && !Ft[o][0].test(l); o++)
    ;
  if (o === Ft.length)
    return !1;
  if (s)
    return Ft[o][2];
  if (c = n + 1, !Ft[o][1].test(l)) {
    for (; c < r && !(e.sCount[c] < e.blkIndent); c++)
      if (a = e.bMarks[c] + e.tShift[c], u = e.eMarks[c], l = e.src.slice(a, u), Ft[o][1].test(l)) {
        l.length !== 0 && c++;
        break;
      }
  }
  return e.line = c, i = e.push("html_block", "", 0), i.map = [n, c], i.content = e.getLines(n, c, e.blkIndent, !0), !0;
}, cc = le.isSpace, lV = function(e, n, r, s) {
  var o, c, i, l, a = e.bMarks[n] + e.tShift[n], u = e.eMarks[n];
  if (e.sCount[n] - e.blkIndent >= 4 || (o = e.src.charCodeAt(a), o !== 35 || a >= u))
    return !1;
  for (c = 1, o = e.src.charCodeAt(++a); o === 35 && a < u && c <= 6; )
    c++, o = e.src.charCodeAt(++a);
  return c > 6 || a < u && !cc(o) ? !1 : (s || (u = e.skipSpacesBack(u, a), i = e.skipCharsBack(u, 35, a), i > a && cc(e.src.charCodeAt(i - 1)) && (u = i), e.line = n + 1, l = e.push("heading_open", "h" + String(c), 1), l.markup = "########".slice(0, c), l.map = [n, e.line], l = e.push("inline", "", 0), l.content = e.src.slice(a, u).trim(), l.map = [n, e.line], l.children = [], l = e.push("heading_close", "h" + String(c), -1), l.markup = "########".slice(0, c)), !0);
}, aV = function(e, n, r) {
  var s, o, c, i, l, a, u, f, p, d = n + 1, k, b = e.md.block.ruler.getRules("paragraph");
  if (e.sCount[n] - e.blkIndent >= 4)
    return !1;
  for (k = e.parentType, e.parentType = "paragraph"; d < r && !e.isEmpty(d); d++)
    if (!(e.sCount[d] - e.blkIndent > 3)) {
      if (e.sCount[d] >= e.blkIndent && (a = e.bMarks[d] + e.tShift[d], u = e.eMarks[d], a < u && (p = e.src.charCodeAt(a), (p === 45 || p === 61) && (a = e.skipChars(a, p), a = e.skipSpaces(a), a >= u)))) {
        f = p === 61 ? 1 : 2;
        break;
      }
      if (!(e.sCount[d] < 0)) {
        for (o = !1, c = 0, i = b.length; c < i; c++)
          if (b[c](e, d, r, !0)) {
            o = !0;
            break;
          }
        if (o)
          break;
      }
    }
  return f ? (s = e.getLines(n, d, e.blkIndent, !1).trim(), e.line = d + 1, l = e.push("heading_open", "h" + String(f), 1), l.markup = String.fromCharCode(p), l.map = [n, e.line], l = e.push("inline", "", 0), l.content = s, l.map = [n, e.line - 1], l.children = [], l = e.push("heading_close", "h" + String(f), -1), l.markup = String.fromCharCode(p), e.parentType = k, !0) : !1;
}, uV = function(e, n) {
  var r, s, o, c, i, l, a = n + 1, u = e.md.block.ruler.getRules("paragraph"), f = e.lineMax;
  for (l = e.parentType, e.parentType = "paragraph"; a < f && !e.isEmpty(a); a++)
    if (!(e.sCount[a] - e.blkIndent > 3) && !(e.sCount[a] < 0)) {
      for (s = !1, o = 0, c = u.length; o < c; o++)
        if (u[o](e, a, f, !0)) {
          s = !0;
          break;
        }
      if (s)
        break;
    }
  return r = e.getLines(n, a, e.blkIndent, !1).trim(), e.line = a, i = e.push("paragraph_open", "p", 1), i.map = [n, e.line], i = e.push("inline", "", 0), i.content = r, i.map = [n, e.line], i.children = [], i = e.push("paragraph_close", "p", -1), e.parentType = l, !0;
}, Ui = Bs, yr = le.isSpace;
function Xe(t, e, n, r) {
  var s, o, c, i, l, a, u, f;
  for (this.src = t, this.md = e, this.env = n, this.tokens = r, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", o = this.src, f = !1, c = i = a = u = 0, l = o.length; i < l; i++) {
    if (s = o.charCodeAt(i), !f)
      if (yr(s)) {
        a++, s === 9 ? u += 4 - u % 4 : u++;
        continue;
      } else
        f = !0;
    (s === 10 || i === l - 1) && (s !== 10 && i++, this.bMarks.push(c), this.eMarks.push(i), this.tShift.push(a), this.sCount.push(u), this.bsCount.push(0), f = !1, a = 0, u = 0, c = i + 1);
  }
  this.bMarks.push(o.length), this.eMarks.push(o.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
Xe.prototype.push = function(t, e, n) {
  var r = new Ui(t, e, n);
  return r.block = !0, n < 0 && this.level--, r.level = this.level, n > 0 && this.level++, this.tokens.push(r), r;
};
Xe.prototype.isEmpty = function(e) {
  return this.bMarks[e] + this.tShift[e] >= this.eMarks[e];
};
Xe.prototype.skipEmptyLines = function(e) {
  for (var n = this.lineMax; e < n && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]); e++)
    ;
  return e;
};
Xe.prototype.skipSpaces = function(e) {
  for (var n, r = this.src.length; e < r && (n = this.src.charCodeAt(e), !!yr(n)); e++)
    ;
  return e;
};
Xe.prototype.skipSpacesBack = function(e, n) {
  if (e <= n)
    return e;
  for (; e > n; )
    if (!yr(this.src.charCodeAt(--e)))
      return e + 1;
  return e;
};
Xe.prototype.skipChars = function(e, n) {
  for (var r = this.src.length; e < r && this.src.charCodeAt(e) === n; e++)
    ;
  return e;
};
Xe.prototype.skipCharsBack = function(e, n, r) {
  if (e <= r)
    return e;
  for (; e > r; )
    if (n !== this.src.charCodeAt(--e))
      return e + 1;
  return e;
};
Xe.prototype.getLines = function(e, n, r, s) {
  var o, c, i, l, a, u, f, p = e;
  if (e >= n)
    return "";
  for (u = new Array(n - e), o = 0; p < n; p++, o++) {
    for (c = 0, f = l = this.bMarks[p], p + 1 < n || s ? a = this.eMarks[p] + 1 : a = this.eMarks[p]; l < a && c < r; ) {
      if (i = this.src.charCodeAt(l), yr(i))
        i === 9 ? c += 4 - (c + this.bsCount[p]) % 4 : c++;
      else if (l - f < this.tShift[p])
        c++;
      else
        break;
      l++;
    }
    c > r ? u[o] = new Array(c - r + 1).join(" ") + this.src.slice(l, a) : u[o] = this.src.slice(l, a);
  }
  return u.join("");
};
Xe.prototype.Token = Ui;
var fV = Xe, pV = Ps, $n = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", L4, ["paragraph", "reference"]],
  ["code", O4],
  ["fence", P4, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", B4, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", z4, ["paragraph", "reference", "blockquote", "list"]],
  ["list", H4, ["paragraph", "reference", "blockquote"]],
  ["reference", V4],
  ["html_block", iV, ["paragraph", "reference", "blockquote"]],
  ["heading", lV, ["paragraph", "reference", "blockquote"]],
  ["lheading", aV],
  ["paragraph", uV]
];
function kr() {
  this.ruler = new pV();
  for (var t = 0; t < $n.length; t++)
    this.ruler.push($n[t][0], $n[t][1], { alt: ($n[t][2] || []).slice() });
}
kr.prototype.tokenize = function(t, e, n) {
  for (var r, s, o = this.ruler.getRules(""), c = o.length, i = e, l = !1, a = t.md.options.maxNesting; i < n && (t.line = i = t.skipEmptyLines(i), !(i >= n || t.sCount[i] < t.blkIndent)); ) {
    if (t.level >= a) {
      t.line = n;
      break;
    }
    for (s = 0; s < c && (r = o[s](t, i, n, !1), !r); s++)
      ;
    t.tight = !l, t.isEmpty(t.line - 1) && (l = !0), i = t.line, i < n && t.isEmpty(i) && (l = !0, i++, t.line = i);
  }
};
kr.prototype.parse = function(t, e, n, r) {
  var s;
  t && (s = new this.State(t, e, n, r), this.tokenize(s, s.line, s.lineMax));
};
kr.prototype.State = fV;
var hV = kr;
function dV(t) {
  switch (t) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
var gV = function(e, n) {
  for (var r = e.pos; r < e.posMax && !dV(e.src.charCodeAt(r)); )
    r++;
  return r === e.pos ? !1 : (n || (e.pending += e.src.slice(e.pos, r)), e.pos = r, !0);
}, mV = le.isSpace, _V = function(e, n) {
  var r, s, o, c = e.pos;
  if (e.src.charCodeAt(c) !== 10)
    return !1;
  if (r = e.pending.length - 1, s = e.posMax, !n)
    if (r >= 0 && e.pending.charCodeAt(r) === 32)
      if (r >= 1 && e.pending.charCodeAt(r - 1) === 32) {
        for (o = r - 1; o >= 1 && e.pending.charCodeAt(o - 1) === 32; )
          o--;
        e.pending = e.pending.slice(0, o), e.push("hardbreak", "br", 0);
      } else
        e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0);
    else
      e.push("softbreak", "br", 0);
  for (c++; c < s && mV(e.src.charCodeAt(c)); )
    c++;
  return e.pos = c, !0;
}, bV = le.isSpace, zs = [];
for (var ic = 0; ic < 256; ic++)
  zs.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(t) {
  zs[t.charCodeAt(0)] = 1;
});
var vV = function(e, n) {
  var r, s = e.pos, o = e.posMax;
  if (e.src.charCodeAt(s) !== 92)
    return !1;
  if (s++, s < o) {
    if (r = e.src.charCodeAt(s), r < 256 && zs[r] !== 0)
      return n || (e.pending += e.src[s]), e.pos += 2, !0;
    if (r === 10) {
      for (n || e.push("hardbreak", "br", 0), s++; s < o && (r = e.src.charCodeAt(s), !!bV(r)); )
        s++;
      return e.pos = s, !0;
    }
  }
  return n || (e.pending += "\\"), e.pos++, !0;
}, xV = function(e, n) {
  var r, s, o, c, i, l, a, u, f = e.pos, p = e.src.charCodeAt(f);
  if (p !== 96)
    return !1;
  for (r = f, f++, s = e.posMax; f < s && e.src.charCodeAt(f) === 96; )
    f++;
  if (o = e.src.slice(r, f), a = o.length, e.backticksScanned && (e.backticks[a] || 0) <= r)
    return n || (e.pending += o), e.pos += a, !0;
  for (i = l = f; (i = e.src.indexOf("`", l)) !== -1; ) {
    for (l = i + 1; l < s && e.src.charCodeAt(l) === 96; )
      l++;
    if (u = l - i, u === a)
      return n || (c = e.push("code_inline", "code", 0), c.markup = o, c.content = e.src.slice(f, i).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), e.pos = l, !0;
    e.backticks[u] = i;
  }
  return e.backticksScanned = !0, n || (e.pending += o), e.pos += a, !0;
}, Er = {};
Er.tokenize = function(e, n) {
  var r, s, o, c, i, l = e.pos, a = e.src.charCodeAt(l);
  if (n || a !== 126 || (s = e.scanDelims(e.pos, !0), c = s.length, i = String.fromCharCode(a), c < 2))
    return !1;
  for (c % 2 && (o = e.push("text", "", 0), o.content = i, c--), r = 0; r < c; r += 2)
    o = e.push("text", "", 0), o.content = i + i, e.delimiters.push({
      marker: a,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: e.tokens.length - 1,
      end: -1,
      open: s.can_open,
      close: s.can_close
    });
  return e.pos += s.length, !0;
};
function lc(t, e) {
  var n, r, s, o, c, i = [], l = e.length;
  for (n = 0; n < l; n++)
    s = e[n], s.marker === 126 && s.end !== -1 && (o = e[s.end], c = t.tokens[s.token], c.type = "s_open", c.tag = "s", c.nesting = 1, c.markup = "~~", c.content = "", c = t.tokens[o.token], c.type = "s_close", c.tag = "s", c.nesting = -1, c.markup = "~~", c.content = "", t.tokens[o.token - 1].type === "text" && t.tokens[o.token - 1].content === "~" && i.push(o.token - 1));
  for (; i.length; ) {
    for (n = i.pop(), r = n + 1; r < t.tokens.length && t.tokens[r].type === "s_close"; )
      r++;
    r--, n !== r && (c = t.tokens[r], t.tokens[r] = t.tokens[n], t.tokens[n] = c);
  }
}
Er.postProcess = function(e) {
  var n, r = e.tokens_meta, s = e.tokens_meta.length;
  for (lc(e, e.delimiters), n = 0; n < s; n++)
    r[n] && r[n].delimiters && lc(e, r[n].delimiters);
};
var wr = {};
wr.tokenize = function(e, n) {
  var r, s, o, c = e.pos, i = e.src.charCodeAt(c);
  if (n || i !== 95 && i !== 42)
    return !1;
  for (s = e.scanDelims(e.pos, i === 42), r = 0; r < s.length; r++)
    o = e.push("text", "", 0), o.content = String.fromCharCode(i), e.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: i,
      // Total length of these series of delimiters.
      //
      length: s.length,
      // A position of the token this delimiter corresponds to.
      //
      token: e.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: s.can_open,
      close: s.can_close
    });
  return e.pos += s.length, !0;
};
function ac(t, e) {
  var n, r, s, o, c, i, l = e.length;
  for (n = l - 1; n >= 0; n--)
    r = e[n], !(r.marker !== 95 && r.marker !== 42) && r.end !== -1 && (s = e[r.end], i = n > 0 && e[n - 1].end === r.end + 1 && // check that first two markers match and adjacent
    e[n - 1].marker === r.marker && e[n - 1].token === r.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    e[r.end + 1].token === s.token + 1, c = String.fromCharCode(r.marker), o = t.tokens[r.token], o.type = i ? "strong_open" : "em_open", o.tag = i ? "strong" : "em", o.nesting = 1, o.markup = i ? c + c : c, o.content = "", o = t.tokens[s.token], o.type = i ? "strong_close" : "em_close", o.tag = i ? "strong" : "em", o.nesting = -1, o.markup = i ? c + c : c, o.content = "", i && (t.tokens[e[n - 1].token].content = "", t.tokens[e[r.end + 1].token].content = "", n--));
}
wr.postProcess = function(e) {
  var n, r = e.tokens_meta, s = e.tokens_meta.length;
  for (ac(e, e.delimiters), n = 0; n < s; n++)
    r[n] && r[n].delimiters && ac(e, r[n].delimiters);
};
var yV = le.normalizeReference, Hr = le.isSpace, kV = function(e, n) {
  var r, s, o, c, i, l, a, u, f, p = "", d = "", k = e.pos, b = e.posMax, I = e.pos, T = !0;
  if (e.src.charCodeAt(e.pos) !== 91 || (i = e.pos + 1, c = e.md.helpers.parseLinkLabel(e, e.pos, !0), c < 0))
    return !1;
  if (l = c + 1, l < b && e.src.charCodeAt(l) === 40) {
    for (T = !1, l++; l < b && (s = e.src.charCodeAt(l), !(!Hr(s) && s !== 10)); l++)
      ;
    if (l >= b)
      return !1;
    if (I = l, a = e.md.helpers.parseLinkDestination(e.src, l, e.posMax), a.ok) {
      for (p = e.md.normalizeLink(a.str), e.md.validateLink(p) ? l = a.pos : p = "", I = l; l < b && (s = e.src.charCodeAt(l), !(!Hr(s) && s !== 10)); l++)
        ;
      if (a = e.md.helpers.parseLinkTitle(e.src, l, e.posMax), l < b && I !== l && a.ok)
        for (d = a.str, l = a.pos; l < b && (s = e.src.charCodeAt(l), !(!Hr(s) && s !== 10)); l++)
          ;
    }
    (l >= b || e.src.charCodeAt(l) !== 41) && (T = !0), l++;
  }
  if (T) {
    if (typeof e.env.references > "u")
      return !1;
    if (l < b && e.src.charCodeAt(l) === 91 ? (I = l + 1, l = e.md.helpers.parseLinkLabel(e, l), l >= 0 ? o = e.src.slice(I, l++) : l = c + 1) : l = c + 1, o || (o = e.src.slice(i, c)), u = e.env.references[yV(o)], !u)
      return e.pos = k, !1;
    p = u.href, d = u.title;
  }
  return n || (e.pos = i, e.posMax = c, f = e.push("link_open", "a", 1), f.attrs = r = [["href", p]], d && r.push(["title", d]), e.md.inline.tokenize(e), f = e.push("link_close", "a", -1)), e.pos = l, e.posMax = b, !0;
}, EV = le.normalizeReference, jr = le.isSpace, wV = function(e, n) {
  var r, s, o, c, i, l, a, u, f, p, d, k, b, I = "", T = e.pos, C = e.posMax;
  if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91 || (l = e.pos + 2, i = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1), i < 0))
    return !1;
  if (a = i + 1, a < C && e.src.charCodeAt(a) === 40) {
    for (a++; a < C && (s = e.src.charCodeAt(a), !(!jr(s) && s !== 10)); a++)
      ;
    if (a >= C)
      return !1;
    for (b = a, f = e.md.helpers.parseLinkDestination(e.src, a, e.posMax), f.ok && (I = e.md.normalizeLink(f.str), e.md.validateLink(I) ? a = f.pos : I = ""), b = a; a < C && (s = e.src.charCodeAt(a), !(!jr(s) && s !== 10)); a++)
      ;
    if (f = e.md.helpers.parseLinkTitle(e.src, a, e.posMax), a < C && b !== a && f.ok)
      for (p = f.str, a = f.pos; a < C && (s = e.src.charCodeAt(a), !(!jr(s) && s !== 10)); a++)
        ;
    else
      p = "";
    if (a >= C || e.src.charCodeAt(a) !== 41)
      return e.pos = T, !1;
    a++;
  } else {
    if (typeof e.env.references > "u")
      return !1;
    if (a < C && e.src.charCodeAt(a) === 91 ? (b = a + 1, a = e.md.helpers.parseLinkLabel(e, a), a >= 0 ? c = e.src.slice(b, a++) : a = i + 1) : a = i + 1, c || (c = e.src.slice(l, i)), u = e.env.references[EV(c)], !u)
      return e.pos = T, !1;
    I = u.href, p = u.title;
  }
  return n || (o = e.src.slice(l, i), e.md.inline.parse(
    o,
    e.md,
    e.env,
    k = []
  ), d = e.push("image", "img", 0), d.attrs = r = [["src", I], ["alt", ""]], d.children = k, d.content = o, p && r.push(["title", p])), e.pos = a, e.posMax = C, !0;
}, CV = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, AV = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/, SV = function(e, n) {
  var r, s, o, c, i, l, a = e.pos;
  if (e.src.charCodeAt(a) !== 60)
    return !1;
  for (i = e.pos, l = e.posMax; ; ) {
    if (++a >= l || (c = e.src.charCodeAt(a), c === 60))
      return !1;
    if (c === 62)
      break;
  }
  return r = e.src.slice(i + 1, a), AV.test(r) ? (s = e.md.normalizeLink(r), e.md.validateLink(s) ? (n || (o = e.push("link_open", "a", 1), o.attrs = [["href", s]], o.markup = "autolink", o.info = "auto", o = e.push("text", "", 0), o.content = e.md.normalizeLinkText(r), o = e.push("link_close", "a", -1), o.markup = "autolink", o.info = "auto"), e.pos += r.length + 2, !0) : !1) : CV.test(r) ? (s = e.md.normalizeLink("mailto:" + r), e.md.validateLink(s) ? (n || (o = e.push("link_open", "a", 1), o.attrs = [["href", s]], o.markup = "autolink", o.info = "auto", o = e.push("text", "", 0), o.content = e.md.normalizeLinkText(r), o = e.push("link_close", "a", -1), o.markup = "autolink", o.info = "auto"), e.pos += r.length + 2, !0) : !1) : !1;
}, DV = xr.HTML_TAG_RE;
function TV(t) {
  var e = t | 32;
  return e >= 97 && e <= 122;
}
var RV = function(e, n) {
  var r, s, o, c, i = e.pos;
  return !e.md.options.html || (o = e.posMax, e.src.charCodeAt(i) !== 60 || i + 2 >= o) || (r = e.src.charCodeAt(i + 1), r !== 33 && r !== 63 && r !== 47 && !TV(r)) || (s = e.src.slice(i).match(DV), !s) ? !1 : (n || (c = e.push("html_inline", "", 0), c.content = e.src.slice(i, i + s[0].length)), e.pos += s[0].length, !0);
}, uc = Ni, qV = le.has, MV = le.isValidEntityCode, fc = le.fromCodePoint, NV = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, IV = /^&([a-z][a-z0-9]{1,31});/i, FV = function(e, n) {
  var r, s, o, c = e.pos, i = e.posMax;
  if (e.src.charCodeAt(c) !== 38)
    return !1;
  if (c + 1 < i) {
    if (r = e.src.charCodeAt(c + 1), r === 35) {
      if (o = e.src.slice(c).match(NV), o)
        return n || (s = o[1][0].toLowerCase() === "x" ? parseInt(o[1].slice(1), 16) : parseInt(o[1], 10), e.pending += MV(s) ? fc(s) : fc(65533)), e.pos += o[0].length, !0;
    } else if (o = e.src.slice(c).match(IV), o && qV(uc, o[1]))
      return n || (e.pending += uc[o[1]]), e.pos += o[0].length, !0;
  }
  return n || (e.pending += "&"), e.pos++, !0;
};
function pc(t, e) {
  var n, r, s, o, c, i, l, a, u = {}, f = e.length;
  if (f) {
    var p = 0, d = -2, k = [];
    for (n = 0; n < f; n++)
      if (s = e[n], k.push(0), (e[p].marker !== s.marker || d !== s.token - 1) && (p = n), d = s.token, s.length = s.length || 0, !!s.close) {
        for (u.hasOwnProperty(s.marker) || (u[s.marker] = [-1, -1, -1, -1, -1, -1]), c = u[s.marker][(s.open ? 3 : 0) + s.length % 3], r = p - k[p] - 1, i = r; r > c; r -= k[r] + 1)
          if (o = e[r], o.marker === s.marker && o.open && o.end < 0 && (l = !1, (o.close || s.open) && (o.length + s.length) % 3 === 0 && (o.length % 3 !== 0 || s.length % 3 !== 0) && (l = !0), !l)) {
            a = r > 0 && !e[r - 1].open ? k[r - 1] + 1 : 0, k[n] = n - r + a, k[r] = a, s.open = !1, o.end = n, o.close = !1, i = -1, d = -2;
            break;
          }
        i !== -1 && (u[s.marker][(s.open ? 3 : 0) + (s.length || 0) % 3] = i);
      }
  }
}
var LV = function(e) {
  var n, r = e.tokens_meta, s = e.tokens_meta.length;
  for (pc(e, e.delimiters), n = 0; n < s; n++)
    r[n] && r[n].delimiters && pc(e, r[n].delimiters);
}, OV = function(e) {
  var n, r, s = 0, o = e.tokens, c = e.tokens.length;
  for (n = r = 0; n < c; n++)
    o[n].nesting < 0 && s--, o[n].level = s, o[n].nesting > 0 && s++, o[n].type === "text" && n + 1 < c && o[n + 1].type === "text" ? o[n + 1].content = o[n].content + o[n + 1].content : (n !== r && (o[r] = o[n]), r++);
  n !== r && (o.length = r);
}, Us = Bs, hc = le.isWhiteSpace, dc = le.isPunctChar, gc = le.isMdAsciiPunct;
function Tn(t, e, n, r) {
  this.src = t, this.env = n, this.md = e, this.tokens = r, this.tokens_meta = Array(r.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1;
}
Tn.prototype.pushPending = function() {
  var t = new Us("text", "", 0);
  return t.content = this.pending, t.level = this.pendingLevel, this.tokens.push(t), this.pending = "", t;
};
Tn.prototype.push = function(t, e, n) {
  this.pending && this.pushPending();
  var r = new Us(t, e, n), s = null;
  return n < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), r.level = this.level, n > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], s = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(r), this.tokens_meta.push(s), r;
};
Tn.prototype.scanDelims = function(t, e) {
  var n = t, r, s, o, c, i, l, a, u, f, p = !0, d = !0, k = this.posMax, b = this.src.charCodeAt(t);
  for (r = t > 0 ? this.src.charCodeAt(t - 1) : 32; n < k && this.src.charCodeAt(n) === b; )
    n++;
  return o = n - t, s = n < k ? this.src.charCodeAt(n) : 32, a = gc(r) || dc(String.fromCharCode(r)), f = gc(s) || dc(String.fromCharCode(s)), l = hc(r), u = hc(s), u ? p = !1 : f && (l || a || (p = !1)), l ? d = !1 : a && (u || f || (d = !1)), e ? (c = p, i = d) : (c = p && (!d || a), i = d && (!p || f)), {
    can_open: c,
    can_close: i,
    length: o
  };
};
Tn.prototype.Token = Us;
var PV = Tn, mc = Ps, Vr = [
  ["text", gV],
  ["newline", _V],
  ["escape", vV],
  ["backticks", xV],
  ["strikethrough", Er.tokenize],
  ["emphasis", wr.tokenize],
  ["link", kV],
  ["image", wV],
  ["autolink", SV],
  ["html_inline", RV],
  ["entity", FV]
], Gr = [
  ["balance_pairs", LV],
  ["strikethrough", Er.postProcess],
  ["emphasis", wr.postProcess],
  ["text_collapse", OV]
];
function Rn() {
  var t;
  for (this.ruler = new mc(), t = 0; t < Vr.length; t++)
    this.ruler.push(Vr[t][0], Vr[t][1]);
  for (this.ruler2 = new mc(), t = 0; t < Gr.length; t++)
    this.ruler2.push(Gr[t][0], Gr[t][1]);
}
Rn.prototype.skipToken = function(t) {
  var e, n, r = t.pos, s = this.ruler.getRules(""), o = s.length, c = t.md.options.maxNesting, i = t.cache;
  if (typeof i[r] < "u") {
    t.pos = i[r];
    return;
  }
  if (t.level < c)
    for (n = 0; n < o && (t.level++, e = s[n](t, !0), t.level--, !e); n++)
      ;
  else
    t.pos = t.posMax;
  e || t.pos++, i[r] = t.pos;
};
Rn.prototype.tokenize = function(t) {
  for (var e, n, r = this.ruler.getRules(""), s = r.length, o = t.posMax, c = t.md.options.maxNesting; t.pos < o; ) {
    if (t.level < c)
      for (n = 0; n < s && (e = r[n](t, !1), !e); n++)
        ;
    if (e) {
      if (t.pos >= o)
        break;
      continue;
    }
    t.pending += t.src[t.pos++];
  }
  t.pending && t.pushPending();
};
Rn.prototype.parse = function(t, e, n, r) {
  var s, o, c, i = new this.State(t, e, n, r);
  for (this.tokenize(i), o = this.ruler2.getRules(""), c = o.length, s = 0; s < c; s++)
    o[s](i);
};
Rn.prototype.State = PV;
var BV = Rn, Zr, _c;
function $V() {
  return _c || (_c = 1, Zr = function(t) {
    var e = {};
    e.src_Any = Ii().source, e.src_Cc = Fi().source, e.src_Z = Li().source, e.src_P = Os.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
    var n = "[><｜]";
    return e.src_pseudo_letter = "(?:(?!" + n + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + n + "|" + e.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + n + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]).|" + (t && t["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + e.src_ZCc + ").|;(?!" + e.src_ZCc + ").|\\!+(?!" + e.src_ZCc + "|[!]).|\\?(?!" + e.src_ZCc + "|[?]).)+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = // Allow letters & digits (http://test1)
    "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + n + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
  }), Zr;
}
function ps(t) {
  var e = Array.prototype.slice.call(arguments, 1);
  return e.forEach(function(n) {
    n && Object.keys(n).forEach(function(r) {
      t[r] = n[r];
    });
  }), t;
}
function Cr(t) {
  return Object.prototype.toString.call(t);
}
function zV(t) {
  return Cr(t) === "[object String]";
}
function UV(t) {
  return Cr(t) === "[object Object]";
}
function HV(t) {
  return Cr(t) === "[object RegExp]";
}
function bc(t) {
  return Cr(t) === "[object Function]";
}
function jV(t) {
  return t.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var Hi = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function VV(t) {
  return Object.keys(t || {}).reduce(function(e, n) {
    return e || Hi.hasOwnProperty(n);
  }, !1);
}
var GV = {
  "http:": {
    validate: function(t, e, n) {
      var r = t.slice(e);
      return n.re.http || (n.re.http = new RegExp(
        "^\\/\\/" + n.re.src_auth + n.re.src_host_port_strict + n.re.src_path,
        "i"
      )), n.re.http.test(r) ? r.match(n.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(t, e, n) {
      var r = t.slice(e);
      return n.re.no_http || (n.re.no_http = new RegExp(
        "^" + n.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + n.re.src_domain + ")\\.)+" + n.re.src_domain_root + ")" + n.re.src_port + n.re.src_host_terminator + n.re.src_path,
        "i"
      )), n.re.no_http.test(r) ? e >= 3 && t[e - 3] === ":" || e >= 3 && t[e - 3] === "/" ? 0 : r.match(n.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(t, e, n) {
      var r = t.slice(e);
      return n.re.mailto || (n.re.mailto = new RegExp(
        "^" + n.re.src_email_name + "@" + n.re.src_host_strict,
        "i"
      )), n.re.mailto.test(r) ? r.match(n.re.mailto)[0].length : 0;
    }
  }
}, ZV = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", KV = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
function WV(t) {
  t.__index__ = -1, t.__text_cache__ = "";
}
function JV(t) {
  return function(e, n) {
    var r = e.slice(n);
    return t.test(r) ? r.match(t)[0].length : 0;
  };
}
function vc() {
  return function(t, e) {
    e.normalize(t);
  };
}
function nr(t) {
  var e = t.re = $V()(t.__opts__), n = t.__tlds__.slice();
  t.onCompile(), t.__tlds_replaced__ || n.push(ZV), n.push(e.src_xn), e.src_tlds = n.join("|");
  function r(i) {
    return i.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(r(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(r(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(r(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(r(e.tpl_host_fuzzy_test), "i");
  var s = [];
  t.__compiled__ = {};
  function o(i, l) {
    throw new Error('(LinkifyIt) Invalid schema "' + i + '": ' + l);
  }
  Object.keys(t.__schemas__).forEach(function(i) {
    var l = t.__schemas__[i];
    if (l !== null) {
      var a = { validate: null, link: null };
      if (t.__compiled__[i] = a, UV(l)) {
        HV(l.validate) ? a.validate = JV(l.validate) : bc(l.validate) ? a.validate = l.validate : o(i, l), bc(l.normalize) ? a.normalize = l.normalize : l.normalize ? o(i, l) : a.normalize = vc();
        return;
      }
      if (zV(l)) {
        s.push(i);
        return;
      }
      o(i, l);
    }
  }), s.forEach(function(i) {
    t.__compiled__[t.__schemas__[i]] && (t.__compiled__[i].validate = t.__compiled__[t.__schemas__[i]].validate, t.__compiled__[i].normalize = t.__compiled__[t.__schemas__[i]].normalize);
  }), t.__compiled__[""] = { validate: null, normalize: vc() };
  var c = Object.keys(t.__compiled__).filter(function(i) {
    return i.length > 0 && t.__compiled__[i];
  }).map(jV).join("|");
  t.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + c + ")", "i"), t.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + c + ")", "ig"), t.re.pretest = RegExp(
    "(" + t.re.schema_test.source + ")|(" + t.re.host_fuzzy_test.source + ")|@",
    "i"
  ), WV(t);
}
function YV(t, e) {
  var n = t.__index__, r = t.__last_index__, s = t.__text_cache__.slice(n, r);
  this.schema = t.__schema__.toLowerCase(), this.index = n + e, this.lastIndex = r + e, this.raw = s, this.text = s, this.url = s;
}
function xc(t, e) {
  var n = new YV(t, e);
  return t.__compiled__[n.schema].normalize(n, t), n;
}
function Oe(t, e) {
  if (!(this instanceof Oe))
    return new Oe(t, e);
  e || VV(t) && (e = t, t = {}), this.__opts__ = ps({}, Hi, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = ps({}, GV, t), this.__compiled__ = {}, this.__tlds__ = KV, this.__tlds_replaced__ = !1, this.re = {}, nr(this);
}
Oe.prototype.add = function(e, n) {
  return this.__schemas__[e] = n, nr(this), this;
};
Oe.prototype.set = function(e) {
  return this.__opts__ = ps(this.__opts__, e), this;
};
Oe.prototype.test = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return !1;
  var n, r, s, o, c, i, l, a, u;
  if (this.re.schema_test.test(e)) {
    for (l = this.re.schema_search, l.lastIndex = 0; (n = l.exec(e)) !== null; )
      if (o = this.testSchemaAt(e, n[2], l.lastIndex), o) {
        this.__schema__ = n[2], this.__index__ = n.index + n[1].length, this.__last_index__ = n.index + n[0].length + o;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (a = e.search(this.re.host_fuzzy_test), a >= 0 && (this.__index__ < 0 || a < this.__index__) && (r = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (c = r.index + r[1].length, (this.__index__ < 0 || c < this.__index__) && (this.__schema__ = "", this.__index__ = c, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (u = e.indexOf("@"), u >= 0 && (s = e.match(this.re.email_fuzzy)) !== null && (c = s.index + s[1].length, i = s.index + s[0].length, (this.__index__ < 0 || c < this.__index__ || c === this.__index__ && i > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = c, this.__last_index__ = i))), this.__index__ >= 0;
};
Oe.prototype.pretest = function(e) {
  return this.re.pretest.test(e);
};
Oe.prototype.testSchemaAt = function(e, n, r) {
  return this.__compiled__[n.toLowerCase()] ? this.__compiled__[n.toLowerCase()].validate(e, r, this) : 0;
};
Oe.prototype.match = function(e) {
  var n = 0, r = [];
  this.__index__ >= 0 && this.__text_cache__ === e && (r.push(xc(this, n)), n = this.__last_index__);
  for (var s = n ? e.slice(n) : e; this.test(s); )
    r.push(xc(this, n)), s = s.slice(this.__last_index__), n += this.__last_index__;
  return r.length ? r : null;
};
Oe.prototype.tlds = function(e, n) {
  return e = Array.isArray(e) ? e : [e], n ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter(function(r, s, o) {
    return r !== o[s - 1];
  }).reverse(), nr(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = !0, nr(this), this);
};
Oe.prototype.normalize = function(e) {
  e.schema || (e.url = "http://" + e.url), e.schema === "mailto:" && !/^mailto:/i.test(e.url) && (e.url = "mailto:" + e.url);
};
Oe.prototype.onCompile = function() {
};
var XV = Oe;
const jt = 2147483647, We = 36, Hs = 1, wn = 26, QV = 38, e5 = 700, ji = 72, Vi = 128, Gi = "-", t5 = /^xn--/, n5 = /[^\0-\x7E]/, r5 = /[\x2E\u3002\uFF0E\uFF61]/g, s5 = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, Kr = We - Hs, Je = Math.floor, Wr = String.fromCharCode;
function Et(t) {
  throw new RangeError(s5[t]);
}
function o5(t, e) {
  const n = [];
  let r = t.length;
  for (; r--; )
    n[r] = e(t[r]);
  return n;
}
function Zi(t, e) {
  const n = t.split("@");
  let r = "";
  n.length > 1 && (r = n[0] + "@", t = n[1]), t = t.replace(r5, ".");
  const s = t.split("."), o = o5(s, e).join(".");
  return r + o;
}
function js(t) {
  const e = [];
  let n = 0;
  const r = t.length;
  for (; n < r; ) {
    const s = t.charCodeAt(n++);
    if (s >= 55296 && s <= 56319 && n < r) {
      const o = t.charCodeAt(n++);
      (o & 64512) == 56320 ? e.push(((s & 1023) << 10) + (o & 1023) + 65536) : (e.push(s), n--);
    } else
      e.push(s);
  }
  return e;
}
const Ki = (t) => String.fromCodePoint(...t), c5 = function(t) {
  return t - 48 < 10 ? t - 22 : t - 65 < 26 ? t - 65 : t - 97 < 26 ? t - 97 : We;
}, yc = function(t, e) {
  return t + 22 + 75 * (t < 26) - ((e != 0) << 5);
}, Wi = function(t, e, n) {
  let r = 0;
  for (t = n ? Je(t / e5) : t >> 1, t += Je(t / e); t > Kr * wn >> 1; r += We)
    t = Je(t / Kr);
  return Je(r + (Kr + 1) * t / (t + QV));
}, Vs = function(t) {
  const e = [], n = t.length;
  let r = 0, s = Vi, o = ji, c = t.lastIndexOf(Gi);
  c < 0 && (c = 0);
  for (let i = 0; i < c; ++i)
    t.charCodeAt(i) >= 128 && Et("not-basic"), e.push(t.charCodeAt(i));
  for (let i = c > 0 ? c + 1 : 0; i < n; ) {
    let l = r;
    for (let u = 1, f = We; ; f += We) {
      i >= n && Et("invalid-input");
      const p = c5(t.charCodeAt(i++));
      (p >= We || p > Je((jt - r) / u)) && Et("overflow"), r += p * u;
      const d = f <= o ? Hs : f >= o + wn ? wn : f - o;
      if (p < d)
        break;
      const k = We - d;
      u > Je(jt / k) && Et("overflow"), u *= k;
    }
    const a = e.length + 1;
    o = Wi(r - l, a, l == 0), Je(r / a) > jt - s && Et("overflow"), s += Je(r / a), r %= a, e.splice(r++, 0, s);
  }
  return String.fromCodePoint(...e);
}, Gs = function(t) {
  const e = [];
  t = js(t);
  let n = t.length, r = Vi, s = 0, o = ji;
  for (const l of t)
    l < 128 && e.push(Wr(l));
  let c = e.length, i = c;
  for (c && e.push(Gi); i < n; ) {
    let l = jt;
    for (const u of t)
      u >= r && u < l && (l = u);
    const a = i + 1;
    l - r > Je((jt - s) / a) && Et("overflow"), s += (l - r) * a, r = l;
    for (const u of t)
      if (u < r && ++s > jt && Et("overflow"), u === r) {
        let f = s;
        for (let p = We; ; p += We) {
          const d = p <= o ? Hs : p >= o + wn ? wn : p - o;
          if (f < d)
            break;
          const k = f - d, b = We - d;
          e.push(
            Wr(yc(d + k % b, 0))
          ), f = Je(k / b);
        }
        e.push(Wr(yc(f, 0))), o = Wi(s, a, i === c), s = 0, ++i;
      }
    ++s, ++r;
  }
  return e.join("");
}, Ji = function(t) {
  return Zi(t, function(e) {
    return t5.test(e) ? Vs(e.slice(4).toLowerCase()) : e;
  });
}, Yi = function(t) {
  return Zi(t, function(e) {
    return n5.test(e) ? "xn--" + Gs(e) : e;
  });
}, i5 = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.1.0",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: js,
    encode: Ki
  },
  decode: Vs,
  encode: Gs,
  toASCII: Yi,
  toUnicode: Ji
}, l5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: Vs,
  default: i5,
  encode: Gs,
  toASCII: Yi,
  toUnicode: Ji,
  ucs2decode: js,
  ucs2encode: Ki
}, Symbol.toStringTag, { value: "Module" })), a5 = /* @__PURE__ */ wf(l5);
var u5 = {
  options: {
    html: !1,
    // Enable HTML tags in source
    xhtmlOut: !1,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 100
    // Internal protection, recursion limit
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, f5 = {
  options: {
    html: !1,
    // Enable HTML tags in source
    xhtmlOut: !1,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "text_collapse"
      ]
    }
  }
}, p5 = {
  options: {
    html: !0,
    // Enable HTML tags in source
    xhtmlOut: !0,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "text_collapse"
      ]
    }
  }
}, _n = le, h5 = vr, d5 = p4, g5 = F4, m5 = hV, _5 = BV, b5 = XV, Ct = Qt, Xi = a5, v5 = {
  default: u5,
  zero: f5,
  commonmark: p5
}, x5 = /^(vbscript|javascript|file|data):/, y5 = /^data:image\/(gif|png|jpeg|webp);/;
function k5(t) {
  var e = t.trim().toLowerCase();
  return x5.test(e) ? !!y5.test(e) : !0;
}
var Qi = ["http:", "https:", "mailto:"];
function E5(t) {
  var e = Ct.parse(t, !0);
  if (e.hostname && (!e.protocol || Qi.indexOf(e.protocol) >= 0))
    try {
      e.hostname = Xi.toASCII(e.hostname);
    } catch {
    }
  return Ct.encode(Ct.format(e));
}
function w5(t) {
  var e = Ct.parse(t, !0);
  if (e.hostname && (!e.protocol || Qi.indexOf(e.protocol) >= 0))
    try {
      e.hostname = Xi.toUnicode(e.hostname);
    } catch {
    }
  return Ct.decode(Ct.format(e), Ct.decode.defaultChars + "%");
}
function Pe(t, e) {
  if (!(this instanceof Pe))
    return new Pe(t, e);
  e || _n.isString(t) || (e = t || {}, t = "default"), this.inline = new _5(), this.block = new m5(), this.core = new g5(), this.renderer = new d5(), this.linkify = new b5(), this.validateLink = k5, this.normalizeLink = E5, this.normalizeLinkText = w5, this.utils = _n, this.helpers = _n.assign({}, h5), this.options = {}, this.configure(t), e && this.set(e);
}
Pe.prototype.set = function(t) {
  return _n.assign(this.options, t), this;
};
Pe.prototype.configure = function(t) {
  var e = this, n;
  if (_n.isString(t) && (n = t, t = v5[n], !t))
    throw new Error('Wrong `markdown-it` preset "' + n + '", check name');
  if (!t)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return t.options && e.set(t.options), t.components && Object.keys(t.components).forEach(function(r) {
    t.components[r].rules && e[r].ruler.enableOnly(t.components[r].rules), t.components[r].rules2 && e[r].ruler2.enableOnly(t.components[r].rules2);
  }), this;
};
Pe.prototype.enable = function(t, e) {
  var n = [];
  Array.isArray(t) || (t = [t]), ["core", "block", "inline"].forEach(function(s) {
    n = n.concat(this[s].ruler.enable(t, !0));
  }, this), n = n.concat(this.inline.ruler2.enable(t, !0));
  var r = t.filter(function(s) {
    return n.indexOf(s) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + r);
  return this;
};
Pe.prototype.disable = function(t, e) {
  var n = [];
  Array.isArray(t) || (t = [t]), ["core", "block", "inline"].forEach(function(s) {
    n = n.concat(this[s].ruler.disable(t, !0));
  }, this), n = n.concat(this.inline.ruler2.disable(t, !0));
  var r = t.filter(function(s) {
    return n.indexOf(s) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + r);
  return this;
};
Pe.prototype.use = function(t) {
  var e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return t.apply(t, e), this;
};
Pe.prototype.parse = function(t, e) {
  if (typeof t != "string")
    throw new Error("Input data should be a String");
  var n = new this.core.State(t, this, e);
  return this.core.process(n), n.tokens;
};
Pe.prototype.render = function(t, e) {
  return e = e || {}, this.renderer.render(this.parse(t, e), this.options, e);
};
Pe.prototype.parseInline = function(t, e) {
  var n = new this.core.State(t, this, e);
  return n.inlineMode = !0, this.core.process(n), n.tokens;
};
Pe.prototype.renderInline = function(t, e) {
  return e = e || {}, this.renderer.render(this.parseInline(t, e), this.options, e);
};
var C5 = Pe, A5 = C5;
const S5 = /* @__PURE__ */ Mi(A5);
var D5 = He({
  name: "VueMarkdown",
  props: {
    source: {
      type: String,
      required: !0
    },
    options: {
      type: Object,
      required: !1
    }
  },
  data: function() {
    return {
      md: null
    };
  },
  computed: {
    content: function() {
      var t, e = this.source;
      return (t = this.md) === null || t === void 0 ? void 0 : t.render(e);
    }
  },
  created: function() {
    var t;
    this.md = new S5((t = this.options) !== null && t !== void 0 ? t : {});
  },
  render: function() {
    return Ai("div", { innerHTML: this.content });
  }
});
const T5 = D5;
function el(t) {
  return t instanceof Map ? t.clear = t.delete = t.set = function() {
    throw new Error("map is read-only");
  } : t instanceof Set && (t.add = t.clear = t.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(t), Object.getOwnPropertyNames(t).forEach((e) => {
    const n = t[e], r = typeof n;
    (r === "object" || r === "function") && !Object.isFrozen(n) && el(n);
  }), t;
}
class kc {
  /**
   * @param {CompiledMode} mode
   */
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
}
function tl(t) {
  return t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function it(t, ...e) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const r in t)
    n[r] = t[r];
  return e.forEach(function(r) {
    for (const s in r)
      n[s] = r[s];
  }), /** @type {T} */
  n;
}
const R5 = "</span>", Ec = (t) => !!t.scope, q5 = (t, { prefix: e }) => {
  if (t.startsWith("language:"))
    return t.replace("language:", "language-");
  if (t.includes(".")) {
    const n = t.split(".");
    return [
      `${e}${n.shift()}`,
      ...n.map((r, s) => `${r}${"_".repeat(s + 1)}`)
    ].join(" ");
  }
  return `${e}${t}`;
};
class M5 {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(e, n) {
    this.buffer = "", this.classPrefix = n.classPrefix, e.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(e) {
    this.buffer += tl(e);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(e) {
    if (!Ec(e))
      return;
    const n = q5(
      e.scope,
      { prefix: this.classPrefix }
    );
    this.span(n);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(e) {
    Ec(e) && (this.buffer += R5);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
}
const wc = (t = {}) => {
  const e = { children: [] };
  return Object.assign(e, t), e;
};
class Zs {
  constructor() {
    this.rootNode = wc(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(e) {
    this.top.children.push(e);
  }
  /** @param {string} scope */
  openNode(e) {
    const n = wc({ scope: e });
    this.add(n), this.stack.push(n);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); )
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(e, n) {
    return typeof n == "string" ? e.addText(n) : n.children && (e.openNode(n), n.children.forEach((r) => this._walk(e, r)), e.closeNode(n)), e;
  }
  /**
   * @param {Node} node
   */
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((n) => typeof n == "string") ? e.children = [e.children.join("")] : e.children.forEach((n) => {
      Zs._collapse(n);
    }));
  }
}
class N5 extends Zs {
  /**
   * @param {*} options
   */
  constructor(e) {
    super(), this.options = e;
  }
  /**
   * @param {string} text
   */
  addText(e) {
    e !== "" && this.add(e);
  }
  /** @param {string} scope */
  startScope(e) {
    this.openNode(e);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(e, n) {
    const r = e.root;
    n && (r.scope = `language:${n}`), this.add(r);
  }
  toHTML() {
    return new M5(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), !0;
  }
}
function Cn(t) {
  return t ? typeof t == "string" ? t : t.source : null;
}
function nl(t) {
  return Mt("(?=", t, ")");
}
function I5(t) {
  return Mt("(?:", t, ")*");
}
function F5(t) {
  return Mt("(?:", t, ")?");
}
function Mt(...t) {
  return t.map((n) => Cn(n)).join("");
}
function L5(t) {
  const e = t[t.length - 1];
  return typeof e == "object" && e.constructor === Object ? (t.splice(t.length - 1, 1), e) : {};
}
function Ks(...t) {
  return "(" + (L5(t).capture ? "" : "?:") + t.map((r) => Cn(r)).join("|") + ")";
}
function rl(t) {
  return new RegExp(t.toString() + "|").exec("").length - 1;
}
function O5(t, e) {
  const n = t && t.exec(e);
  return n && n.index === 0;
}
const P5 = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function Ws(t, { joinWith: e }) {
  let n = 0;
  return t.map((r) => {
    n += 1;
    const s = n;
    let o = Cn(r), c = "";
    for (; o.length > 0; ) {
      const i = P5.exec(o);
      if (!i) {
        c += o;
        break;
      }
      c += o.substring(0, i.index), o = o.substring(i.index + i[0].length), i[0][0] === "\\" && i[1] ? c += "\\" + String(Number(i[1]) + s) : (c += i[0], i[0] === "(" && n++);
    }
    return c;
  }).map((r) => `(${r})`).join(e);
}
const B5 = /\b\B/, sl = "[a-zA-Z]\\w*", Js = "[a-zA-Z_]\\w*", ol = "\\b\\d+(\\.\\d+)?", cl = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", il = "\\b(0b[01]+)", $5 = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", z5 = (t = {}) => {
  const e = /^#![ ]*\//;
  return t.binary && (t.begin = Mt(
    e,
    /.*\b/,
    t.binary,
    /\b.*/
  )), it({
    scope: "meta",
    begin: e,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (n, r) => {
      n.index !== 0 && r.ignoreMatch();
    }
  }, t);
}, An = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, U5 = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [An]
}, H5 = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [An]
}, j5 = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, Ar = function(t, e, n = {}) {
  const r = it(
    {
      scope: "comment",
      begin: t,
      end: e,
      contains: []
    },
    n
  );
  r.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const s = Ks(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return r.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: Mt(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        s,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), r;
}, V5 = Ar("//", "$"), G5 = Ar("/\\*", "\\*/"), Z5 = Ar("#", "$"), K5 = {
  scope: "number",
  begin: ol,
  relevance: 0
}, W5 = {
  scope: "number",
  begin: cl,
  relevance: 0
}, J5 = {
  scope: "number",
  begin: il,
  relevance: 0
}, Y5 = {
  // this outer rule makes sure we actually have a WHOLE regex and not simply
  // an expression such as:
  //
  //     3 / something
  //
  // (which will then blow up when regex's `illegal` sees the newline)
  begin: /(?=\/[^/\n]*\/)/,
  contains: [{
    scope: "regexp",
    begin: /\//,
    end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
      An,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [An]
      }
    ]
  }]
}, X5 = {
  scope: "title",
  begin: sl,
  relevance: 0
}, Q5 = {
  scope: "title",
  begin: Js,
  relevance: 0
}, e9 = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + Js,
  relevance: 0
}, t9 = function(t) {
  return Object.assign(
    t,
    {
      /** @type {ModeCallback} */
      "on:begin": (e, n) => {
        n.data._beginMatch = e[1];
      },
      /** @type {ModeCallback} */
      "on:end": (e, n) => {
        n.data._beginMatch !== e[1] && n.ignoreMatch();
      }
    }
  );
};
var zn = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MATCH_NOTHING_RE: B5,
  IDENT_RE: sl,
  UNDERSCORE_IDENT_RE: Js,
  NUMBER_RE: ol,
  C_NUMBER_RE: cl,
  BINARY_NUMBER_RE: il,
  RE_STARTERS_RE: $5,
  SHEBANG: z5,
  BACKSLASH_ESCAPE: An,
  APOS_STRING_MODE: U5,
  QUOTE_STRING_MODE: H5,
  PHRASAL_WORDS_MODE: j5,
  COMMENT: Ar,
  C_LINE_COMMENT_MODE: V5,
  C_BLOCK_COMMENT_MODE: G5,
  HASH_COMMENT_MODE: Z5,
  NUMBER_MODE: K5,
  C_NUMBER_MODE: W5,
  BINARY_NUMBER_MODE: J5,
  REGEXP_MODE: Y5,
  TITLE_MODE: X5,
  UNDERSCORE_TITLE_MODE: Q5,
  METHOD_GUARD: e9,
  END_SAME_AS_BEGIN: t9
});
function n9(t, e) {
  t.input[t.index - 1] === "." && e.ignoreMatch();
}
function r9(t, e) {
  t.className !== void 0 && (t.scope = t.className, delete t.className);
}
function s9(t, e) {
  e && t.beginKeywords && (t.begin = "\\b(" + t.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", t.__beforeBegin = n9, t.keywords = t.keywords || t.beginKeywords, delete t.beginKeywords, t.relevance === void 0 && (t.relevance = 0));
}
function o9(t, e) {
  Array.isArray(t.illegal) && (t.illegal = Ks(...t.illegal));
}
function c9(t, e) {
  if (t.match) {
    if (t.begin || t.end)
      throw new Error("begin & end are not supported with match");
    t.begin = t.match, delete t.match;
  }
}
function i9(t, e) {
  t.relevance === void 0 && (t.relevance = 1);
}
const l9 = (t, e) => {
  if (!t.beforeMatch)
    return;
  if (t.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const n = Object.assign({}, t);
  Object.keys(t).forEach((r) => {
    delete t[r];
  }), t.keywords = n.keywords, t.begin = Mt(n.beforeMatch, nl(n.begin)), t.starts = {
    relevance: 0,
    contains: [
      Object.assign(n, { endsParent: !0 })
    ]
  }, t.relevance = 0, delete n.beforeMatch;
}, a9 = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], u9 = "keyword";
function ll(t, e, n = u9) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof t == "string" ? s(n, t.split(" ")) : Array.isArray(t) ? s(n, t) : Object.keys(t).forEach(function(o) {
    Object.assign(
      r,
      ll(t[o], e, o)
    );
  }), r;
  function s(o, c) {
    e && (c = c.map((i) => i.toLowerCase())), c.forEach(function(i) {
      const l = i.split("|");
      r[l[0]] = [o, f9(l[0], l[1])];
    });
  }
}
function f9(t, e) {
  return e ? Number(e) : p9(t) ? 0 : 1;
}
function p9(t) {
  return a9.includes(t.toLowerCase());
}
const Cc = {}, Dt = (t) => {
  console.error(t);
}, Ac = (t, ...e) => {
  console.log(`WARN: ${t}`, ...e);
}, Lt = (t, e) => {
  Cc[`${t}/${e}`] || (console.log(`Deprecated as of ${t}. ${e}`), Cc[`${t}/${e}`] = !0);
}, rr = new Error();
function al(t, e, { key: n }) {
  let r = 0;
  const s = t[n], o = {}, c = {};
  for (let i = 1; i <= e.length; i++)
    c[i + r] = s[i], o[i + r] = !0, r += rl(e[i - 1]);
  t[n] = c, t[n]._emit = o, t[n]._multi = !0;
}
function h9(t) {
  if (Array.isArray(t.begin)) {
    if (t.skip || t.excludeBegin || t.returnBegin)
      throw Dt("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), rr;
    if (typeof t.beginScope != "object" || t.beginScope === null)
      throw Dt("beginScope must be object"), rr;
    al(t, t.begin, { key: "beginScope" }), t.begin = Ws(t.begin, { joinWith: "" });
  }
}
function d9(t) {
  if (Array.isArray(t.end)) {
    if (t.skip || t.excludeEnd || t.returnEnd)
      throw Dt("skip, excludeEnd, returnEnd not compatible with endScope: {}"), rr;
    if (typeof t.endScope != "object" || t.endScope === null)
      throw Dt("endScope must be object"), rr;
    al(t, t.end, { key: "endScope" }), t.end = Ws(t.end, { joinWith: "" });
  }
}
function g9(t) {
  t.scope && typeof t.scope == "object" && t.scope !== null && (t.beginScope = t.scope, delete t.scope);
}
function m9(t) {
  g9(t), typeof t.beginScope == "string" && (t.beginScope = { _wrap: t.beginScope }), typeof t.endScope == "string" && (t.endScope = { _wrap: t.endScope }), h9(t), d9(t);
}
function _9(t) {
  function e(c, i) {
    return new RegExp(
      Cn(c),
      "m" + (t.case_insensitive ? "i" : "") + (t.unicodeRegex ? "u" : "") + (i ? "g" : "")
    );
  }
  class n {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(i, l) {
      l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, i]), this.matchAt += rl(i) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const i = this.regexes.map((l) => l[1]);
      this.matcherRe = e(Ws(i, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(i) {
      this.matcherRe.lastIndex = this.lastIndex;
      const l = this.matcherRe.exec(i);
      if (!l)
        return null;
      const a = l.findIndex((f, p) => p > 0 && f !== void 0), u = this.matchIndexes[a];
      return l.splice(0, a), Object.assign(l, u);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(i) {
      if (this.multiRegexes[i])
        return this.multiRegexes[i];
      const l = new n();
      return this.rules.slice(i).forEach(([a, u]) => l.addRule(a, u)), l.compile(), this.multiRegexes[i] = l, l;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(i, l) {
      this.rules.push([i, l]), l.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(i) {
      const l = this.getMatcher(this.regexIndex);
      l.lastIndex = this.lastIndex;
      let a = l.exec(i);
      if (this.resumingScanAtSamePosition() && !(a && a.index === this.lastIndex)) {
        const u = this.getMatcher(0);
        u.lastIndex = this.lastIndex + 1, a = u.exec(i);
      }
      return a && (this.regexIndex += a.position + 1, this.regexIndex === this.count && this.considerAll()), a;
    }
  }
  function s(c) {
    const i = new r();
    return c.contains.forEach((l) => i.addRule(l.begin, { rule: l, type: "begin" })), c.terminatorEnd && i.addRule(c.terminatorEnd, { type: "end" }), c.illegal && i.addRule(c.illegal, { type: "illegal" }), i;
  }
  function o(c, i) {
    const l = (
      /** @type CompiledMode */
      c
    );
    if (c.isCompiled)
      return l;
    [
      r9,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      c9,
      m9,
      l9
    ].forEach((u) => u(c, i)), t.compilerExtensions.forEach((u) => u(c, i)), c.__beforeBegin = null, [
      s9,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      o9,
      // default to 1 relevance if not specified
      i9
    ].forEach((u) => u(c, i)), c.isCompiled = !0;
    let a = null;
    return typeof c.keywords == "object" && c.keywords.$pattern && (c.keywords = Object.assign({}, c.keywords), a = c.keywords.$pattern, delete c.keywords.$pattern), a = a || /\w+/, c.keywords && (c.keywords = ll(c.keywords, t.case_insensitive)), l.keywordPatternRe = e(a, !0), i && (c.begin || (c.begin = /\B|\b/), l.beginRe = e(l.begin), !c.end && !c.endsWithParent && (c.end = /\B|\b/), c.end && (l.endRe = e(l.end)), l.terminatorEnd = Cn(l.end) || "", c.endsWithParent && i.terminatorEnd && (l.terminatorEnd += (c.end ? "|" : "") + i.terminatorEnd)), c.illegal && (l.illegalRe = e(
      /** @type {RegExp | string} */
      c.illegal
    )), c.contains || (c.contains = []), c.contains = [].concat(...c.contains.map(function(u) {
      return b9(u === "self" ? c : u);
    })), c.contains.forEach(function(u) {
      o(
        /** @type Mode */
        u,
        l
      );
    }), c.starts && o(c.starts, i), l.matcher = s(l), l;
  }
  if (t.compilerExtensions || (t.compilerExtensions = []), t.contains && t.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return t.classNameAliases = it(t.classNameAliases || {}), o(
    /** @type Mode */
    t
  );
}
function ul(t) {
  return t ? t.endsWithParent || ul(t.starts) : !1;
}
function b9(t) {
  return t.variants && !t.cachedVariants && (t.cachedVariants = t.variants.map(function(e) {
    return it(t, { variants: null }, e);
  })), t.cachedVariants ? t.cachedVariants : ul(t) ? it(t, { starts: t.starts ? it(t.starts) : null }) : Object.isFrozen(t) ? it(t) : t;
}
var v9 = "11.8.0";
class x9 extends Error {
  constructor(e, n) {
    super(e), this.name = "HTMLInjectionError", this.html = n;
  }
}
const Jr = tl, Sc = it, Dc = Symbol("nomatch"), y9 = 7, fl = function(t) {
  const e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), r = [];
  let s = !0;
  const o = "Could not find the language '{}', did you forget to load/include a language module?", c = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let i = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: N5
  };
  function l(v) {
    return i.noHighlightRe.test(v);
  }
  function a(v) {
    let S = v.className + " ";
    S += v.parentNode ? v.parentNode.className : "";
    const Z = i.languageDetectRe.exec(S);
    if (Z) {
      const te = X(Z[1]);
      return te || (Ac(o.replace("{}", Z[1])), Ac("Falling back to no-highlight mode for this block.", v)), te ? Z[1] : "no-highlight";
    }
    return S.split(/\s+/).find((te) => l(te) || X(te));
  }
  function u(v, S, Z) {
    let te = "", ie = "";
    typeof S == "object" ? (te = v, Z = S.ignoreIllegals, ie = S.language) : (Lt("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Lt("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), ie = v, te = S), Z === void 0 && (Z = !0);
    const ae = {
      code: te,
      language: ie
    };
    ne("before:highlight", ae);
    const De = ae.result ? ae.result : f(ae.language, ae.code, Z);
    return De.code = ae.code, ne("after:highlight", De), De;
  }
  function f(v, S, Z, te) {
    const ie = /* @__PURE__ */ Object.create(null);
    function ae(w, R) {
      return w.keywords[R];
    }
    function De() {
      if (!m.keywords) {
        y.addText(L);
        return;
      }
      let w = 0;
      m.keywordPatternRe.lastIndex = 0;
      let R = m.keywordPatternRe.exec(L), H = "";
      for (; R; ) {
        H += L.substring(w, R.index);
        const Y = x.case_insensitive ? R[0].toLowerCase() : R[0], pe = ae(m, Y);
        if (pe) {
          const [Ne, dt] = pe;
          if (y.addText(H), H = "", ie[Y] = (ie[Y] || 0) + 1, ie[Y] <= y9 && (P += dt), Ne.startsWith("_"))
            H += R[0];
          else {
            const qn = x.classNameAliases[Ne] || Ne;
            ge(R[0], qn);
          }
        } else
          H += R[0];
        w = m.keywordPatternRe.lastIndex, R = m.keywordPatternRe.exec(L);
      }
      H += L.substring(w), y.addText(H);
    }
    function Nt() {
      if (L === "")
        return;
      let w = null;
      if (typeof m.subLanguage == "string") {
        if (!e[m.subLanguage]) {
          y.addText(L);
          return;
        }
        w = f(m.subLanguage, L, !0, F[m.subLanguage]), F[m.subLanguage] = /** @type {CompiledMode} */
        w._top;
      } else
        w = d(L, m.subLanguage.length ? m.subLanguage : null);
      m.relevance > 0 && (P += w.relevance), y.__addSublanguage(w._emitter, w.language);
    }
    function Ce() {
      m.subLanguage != null ? Nt() : De(), L = "";
    }
    function ge(w, R) {
      w !== "" && (y.startScope(R), y.addText(w), y.endScope());
    }
    function ht(w, R) {
      let H = 1;
      const Y = R.length - 1;
      for (; H <= Y; ) {
        if (!w._emit[H]) {
          H++;
          continue;
        }
        const pe = x.classNameAliases[w[H]] || w[H], Ne = R[H];
        pe ? ge(Ne, pe) : (L = Ne, De(), L = ""), H++;
      }
    }
    function nn(w, R) {
      return w.scope && typeof w.scope == "string" && y.openNode(x.classNameAliases[w.scope] || w.scope), w.beginScope && (w.beginScope._wrap ? (ge(L, x.classNameAliases[w.beginScope._wrap] || w.beginScope._wrap), L = "") : w.beginScope._multi && (ht(w.beginScope, R), L = "")), m = Object.create(w, { parent: { value: m } }), m;
    }
    function Qe(w, R, H) {
      let Y = O5(w.endRe, H);
      if (Y) {
        if (w["on:end"]) {
          const pe = new kc(w);
          w["on:end"](R, pe), pe.isMatchIgnored && (Y = !1);
        }
        if (Y) {
          for (; w.endsParent && w.parent; )
            w = w.parent;
          return w;
        }
      }
      if (w.endsWithParent)
        return Qe(w.parent, R, H);
    }
    function rn(w) {
      return m.matcher.regexIndex === 0 ? (L += w[0], 1) : (Q = !0, 0);
    }
    function sn(w) {
      const R = w[0], H = w.rule, Y = new kc(H), pe = [H.__beforeBegin, H["on:begin"]];
      for (const Ne of pe)
        if (Ne && (Ne(w, Y), Y.isMatchIgnored))
          return rn(R);
      return H.skip ? L += R : (H.excludeBegin && (L += R), Ce(), !H.returnBegin && !H.excludeBegin && (L = R)), nn(H, w), H.returnBegin ? 0 : R.length;
    }
    function h(w) {
      const R = w[0], H = S.substring(w.index), Y = Qe(m, w, H);
      if (!Y)
        return Dc;
      const pe = m;
      m.endScope && m.endScope._wrap ? (Ce(), ge(R, m.endScope._wrap)) : m.endScope && m.endScope._multi ? (Ce(), ht(m.endScope, w)) : pe.skip ? L += R : (pe.returnEnd || pe.excludeEnd || (L += R), Ce(), pe.excludeEnd && (L = R));
      do
        m.scope && y.closeNode(), !m.skip && !m.subLanguage && (P += m.relevance), m = m.parent;
      while (m !== Y.parent);
      return Y.starts && nn(Y.starts, w), pe.returnEnd ? 0 : R.length;
    }
    function g() {
      const w = [];
      for (let R = m; R !== x; R = R.parent)
        R.scope && w.unshift(R.scope);
      w.forEach((R) => y.openNode(R));
    }
    let _ = {};
    function E(w, R) {
      const H = R && R[0];
      if (L += w, H == null)
        return Ce(), 0;
      if (_.type === "begin" && R.type === "end" && _.index === R.index && H === "") {
        if (L += S.slice(R.index, R.index + 1), !s) {
          const Y = new Error(`0 width match regex (${v})`);
          throw Y.languageName = v, Y.badRule = _.rule, Y;
        }
        return 1;
      }
      if (_ = R, R.type === "begin")
        return sn(R);
      if (R.type === "illegal" && !Z) {
        const Y = new Error('Illegal lexeme "' + H + '" for mode "' + (m.scope || "<unnamed>") + '"');
        throw Y.mode = m, Y;
      } else if (R.type === "end") {
        const Y = h(R);
        if (Y !== Dc)
          return Y;
      }
      if (R.type === "illegal" && H === "")
        return 1;
      if (K > 1e5 && K > R.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return L += H, H.length;
    }
    const x = X(v);
    if (!x)
      throw Dt(o.replace("{}", v)), new Error('Unknown language: "' + v + '"');
    const M = _9(x);
    let O = "", m = te || M;
    const F = {}, y = new i.__emitter(i);
    g();
    let L = "", P = 0, U = 0, K = 0, Q = !1;
    try {
      if (x.__emitTokens)
        x.__emitTokens(S, y);
      else {
        for (m.matcher.considerAll(); ; ) {
          K++, Q ? Q = !1 : m.matcher.considerAll(), m.matcher.lastIndex = U;
          const w = m.matcher.exec(S);
          if (!w)
            break;
          const R = S.substring(U, w.index), H = E(R, w);
          U = w.index + H;
        }
        E(S.substring(U));
      }
      return y.finalize(), O = y.toHTML(), {
        language: v,
        value: O,
        relevance: P,
        illegal: !1,
        _emitter: y,
        _top: m
      };
    } catch (w) {
      if (w.message && w.message.includes("Illegal"))
        return {
          language: v,
          value: Jr(S),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: w.message,
            index: U,
            context: S.slice(U - 100, U + 100),
            mode: w.mode,
            resultSoFar: O
          },
          _emitter: y
        };
      if (s)
        return {
          language: v,
          value: Jr(S),
          illegal: !1,
          relevance: 0,
          errorRaised: w,
          _emitter: y,
          _top: m
        };
      throw w;
    }
  }
  function p(v) {
    const S = {
      value: Jr(v),
      illegal: !1,
      relevance: 0,
      _top: c,
      _emitter: new i.__emitter(i)
    };
    return S._emitter.addText(v), S;
  }
  function d(v, S) {
    S = S || i.languages || Object.keys(e);
    const Z = p(v), te = S.filter(X).filter(J).map(
      (Ce) => f(Ce, v, !1)
    );
    te.unshift(Z);
    const ie = te.sort((Ce, ge) => {
      if (Ce.relevance !== ge.relevance)
        return ge.relevance - Ce.relevance;
      if (Ce.language && ge.language) {
        if (X(Ce.language).supersetOf === ge.language)
          return 1;
        if (X(ge.language).supersetOf === Ce.language)
          return -1;
      }
      return 0;
    }), [ae, De] = ie, Nt = ae;
    return Nt.secondBest = De, Nt;
  }
  function k(v, S, Z) {
    const te = S && n[S] || Z;
    v.classList.add("hljs"), v.classList.add(`language-${te}`);
  }
  function b(v) {
    let S = null;
    const Z = a(v);
    if (l(Z))
      return;
    if (ne(
      "before:highlightElement",
      { el: v, language: Z }
    ), v.children.length > 0 && (i.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(v)), i.throwUnescapedHTML))
      throw new x9(
        "One of your code blocks includes unescaped HTML.",
        v.innerHTML
      );
    S = v;
    const te = S.textContent, ie = Z ? u(te, { language: Z, ignoreIllegals: !0 }) : d(te);
    v.innerHTML = ie.value, k(v, Z, ie.language), v.result = {
      language: ie.language,
      // TODO: remove with version 11.0
      re: ie.relevance,
      relevance: ie.relevance
    }, ie.secondBest && (v.secondBest = {
      language: ie.secondBest.language,
      relevance: ie.secondBest.relevance
    }), ne("after:highlightElement", { el: v, result: ie, text: te });
  }
  function I(v) {
    i = Sc(i, v);
  }
  const T = () => {
    A(), Lt("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function C() {
    A(), Lt("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let N = !1;
  function A() {
    if (document.readyState === "loading") {
      N = !0;
      return;
    }
    document.querySelectorAll(i.cssSelector).forEach(b);
  }
  function j() {
    N && A();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", j, !1);
  function q(v, S) {
    let Z = null;
    try {
      Z = S(t);
    } catch (te) {
      if (Dt("Language definition for '{}' could not be registered.".replace("{}", v)), s)
        Dt(te);
      else
        throw te;
      Z = c;
    }
    Z.name || (Z.name = v), e[v] = Z, Z.rawDefinition = S.bind(null, t), Z.aliases && z(Z.aliases, { languageName: v });
  }
  function W(v) {
    delete e[v];
    for (const S of Object.keys(n))
      n[S] === v && delete n[S];
  }
  function $() {
    return Object.keys(e);
  }
  function X(v) {
    return v = (v || "").toLowerCase(), e[v] || e[n[v]];
  }
  function z(v, { languageName: S }) {
    typeof v == "string" && (v = [v]), v.forEach((Z) => {
      n[Z.toLowerCase()] = S;
    });
  }
  function J(v) {
    const S = X(v);
    return S && !S.disableAutodetect;
  }
  function B(v) {
    v["before:highlightBlock"] && !v["before:highlightElement"] && (v["before:highlightElement"] = (S) => {
      v["before:highlightBlock"](
        Object.assign({ block: S.el }, S)
      );
    }), v["after:highlightBlock"] && !v["after:highlightElement"] && (v["after:highlightElement"] = (S) => {
      v["after:highlightBlock"](
        Object.assign({ block: S.el }, S)
      );
    });
  }
  function re(v) {
    B(v), r.push(v);
  }
  function D(v) {
    const S = r.indexOf(v);
    S !== -1 && r.splice(S, 1);
  }
  function ne(v, S) {
    const Z = v;
    r.forEach(function(te) {
      te[Z] && te[Z](S);
    });
  }
  function V(v) {
    return Lt("10.7.0", "highlightBlock will be removed entirely in v12.0"), Lt("10.7.0", "Please use highlightElement now."), b(v);
  }
  Object.assign(t, {
    highlight: u,
    highlightAuto: d,
    highlightAll: A,
    highlightElement: b,
    // TODO: Remove with v12 API
    highlightBlock: V,
    configure: I,
    initHighlighting: T,
    initHighlightingOnLoad: C,
    registerLanguage: q,
    unregisterLanguage: W,
    listLanguages: $,
    getLanguage: X,
    registerAliases: z,
    autoDetection: J,
    inherit: Sc,
    addPlugin: re,
    removePlugin: D
  }), t.debugMode = function() {
    s = !1;
  }, t.safeMode = function() {
    s = !0;
  }, t.versionString = v9, t.regex = {
    concat: Mt,
    lookahead: nl,
    either: Ks,
    optional: F5,
    anyNumberOfTimes: I5
  };
  for (const v in zn)
    typeof zn[v] == "object" && el(zn[v]);
  return Object.assign(t, zn), t;
}, Wt = fl({});
Wt.newInstance = () => fl({});
var k9 = Wt;
Wt.HighlightJS = Wt;
Wt.default = Wt;
const sr = /* @__PURE__ */ Mi(k9), hs = /* @__PURE__ */ He({
  __name: "Message",
  props: {
    message: {
      type: Object,
      required: !0
    }
  },
  setup(t) {
    const e = t, { message: n } = pa(e), r = Xt(() => ({
      "chat-message-from-user": n.value.sender === "user",
      "chat-message-from-bot": n.value.sender === "bot"
    })), s = {
      highlight(o, c) {
        if (c && sr.getLanguage(c))
          try {
            return sr.highlight(o, { language: c }).value;
          } catch {
          }
        return "";
      }
    };
    return (o, c) => (oe(), be("div", {
      class: Sn(["chat-message", r.value])
    }, [
      hn(o.$slots, "default", {}, () => [
        de(he(T5), {
          class: "chat-message-markdown",
          source: he(n).text,
          options: s
        }, null, 8, ["source"])
      ])
    ], 2));
  }
});
const E9 = /* @__PURE__ */ we("div", { class: "chat-message-typing-body" }, [
  /* @__PURE__ */ we("span", { class: "chat-message-typing-circle" }),
  /* @__PURE__ */ we("span", { class: "chat-message-typing-circle" }),
  /* @__PURE__ */ we("span", { class: "chat-message-typing-circle" })
], -1), w9 = /* @__PURE__ */ He({
  __name: "MessageTyping",
  props: {
    animation: {
      type: String,
      default: "bouncing"
    }
  },
  setup(t) {
    const e = t, n = {
      id: "typing",
      text: "",
      sender: "bot",
      createdAt: ""
    }, r = Xt(() => ({
      // eslint-disable-next-line @typescript-eslint/naming-convention
      "chat-message-typing": !0,
      [`chat-message-typing-animation-${e.animation}`]: !0
    }));
    return (s, o) => (oe(), Se(he(hs), {
      class: Sn(r.value),
      message: n
    }, {
      default: ut(() => [
        E9
      ]),
      _: 1
    }, 8, ["class"]));
  }
});
const C9 = { class: "chat-messages-list" }, A9 = /* @__PURE__ */ He({
  __name: "MessagesList",
  props: {
    messages: {
      type: Array,
      required: !0
    }
  },
  setup(t) {
    const e = Ls(), { initialMessages: n, waitingForResponse: r } = e;
    return (s, o) => (oe(), be("div", C9, [
      (oe(!0), be(Re, null, ao(he(n), (c) => (oe(), Se(hs, {
        key: c.id,
        message: c
      }, null, 8, ["message"]))), 128)),
      (oe(!0), be(Re, null, ao(t.messages, (c) => (oe(), Se(hs, {
        key: c.id,
        message: c
      }, null, 8, ["message"]))), 128)),
      he(r) ? (oe(), Se(w9, { key: 0 })) : mn("", !0)
    ]));
  }
});
const S9 = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, D9 = /* @__PURE__ */ we("path", {
  fill: "currentColor",
  d: "m2 21l21-9L2 3v7l15 2l-15 2v7Z"
}, null, -1), T9 = [
  D9
];
function R9(t, e) {
  return oe(), be("svg", S9, T9);
}
const q9 = { name: "mdi-send", render: R9 }, M9 = { class: "chat-input" }, N9 = ["placeholder", "onKeydown"], I9 = ["disabled"], F9 = /* @__PURE__ */ He({
  __name: "Input",
  setup(t) {
    const e = Ls(), { waitingForResponse: n } = e, { t: r } = mr(), s = zt(""), o = Xt(() => s.value === "" || n.value);
    async function c(l) {
      if (l.preventDefault(), o.value)
        return;
      const a = s.value;
      s.value = "", await e.sendMessage(a);
    }
    async function i(l) {
      l.shiftKey || await c(l);
    }
    return (l, a) => (oe(), be("div", M9, [
      ii(we("textarea", {
        "onUpdate:modelValue": a[0] || (a[0] = (u) => s.value = u),
        rows: "1",
        placeholder: he(r)("inputPlaceholder"),
        onKeydown: Wu(i, ["enter"])
      }, null, 40, N9), [
        [Zu, s.value]
      ]),
      we("button", {
        disabled: o.value,
        class: "chat-input-send-button",
        onClick: c
      }, [
        de(he(q9), {
          height: "32",
          width: "32"
        })
      ], 8, I9)
    ]));
  }
});
const pl = /* @__PURE__ */ He({
  __name: "Chat",
  setup(t) {
    const { t: e } = mr(), n = Ls(), { messages: r, currentSessionId: s } = n;
    async function o() {
      await n.loadPreviousSession(), Zt(() => {
        Tt.emit("scrollToBottom");
      });
    }
    async function c() {
      n.startNewSession(), Zt(() => {
        Tt.emit("scrollToBottom");
      });
    }
    return Dn(() => {
      o();
    }), (i, l) => (oe(), Se(ff, { class: "chat-wrapper" }, ja({
      footer: ut(() => [
        he(s) ? (oe(), Se(F9, { key: 0 })) : (oe(), Se(Ef, { key: 1 }))
      ]),
      default: ut(() => [
        he(s) ? (oe(), Se(A9, {
          key: 1,
          messages: he(r)
        }, null, 8, ["messages"])) : (oe(), Se(gf, {
          key: 0,
          "onClick:button": c
        }))
      ]),
      _: 2
    }, [
      he(s) ? void 0 : {
        name: "header",
        fn: ut(() => [
          we("h1", null, Zn(he(e)("title")), 1),
          we("p", null, Zn(he(e)("subtitle")), 1)
        ]),
        key: "0"
      }
    ]), 1024));
  }
}), L9 = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, O9 = /* @__PURE__ */ we("path", {
  fill: "currentColor",
  d: "M12 3c5.5 0 10 3.58 10 8s-4.5 8-10 8c-1.24 0-2.43-.18-3.53-.5C5.55 21 2 21 2 21c2.33-2.33 2.7-3.9 2.75-4.5C3.05 15.07 2 13.13 2 11c0-4.42 4.5-8 10-8Z"
}, null, -1), P9 = [
  O9
];
function B9(t, e) {
  return oe(), be("svg", L9, P9);
}
const $9 = { name: "mdi-chat", render: B9 }, z9 = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, U9 = /* @__PURE__ */ we("path", {
  fill: "currentColor",
  d: "M7.41 8.58L12 13.17l4.59-4.59L18 10l-6 6l-6-6l1.41-1.42Z"
}, null, -1), H9 = [
  U9
];
function j9(t, e) {
  return oe(), be("svg", z9, H9);
}
const V9 = { name: "mdi-chevron-down", render: j9 }, G9 = { class: "chat-window-wrapper" }, Z9 = { class: "chat-window" }, K9 = /* @__PURE__ */ He({
  __name: "ChatWindow",
  setup(t) {
    const e = zt(!1);
    function n() {
      e.value = !e.value, e.value && Zt(() => {
        Tt.emit("scrollToBottom");
      });
    }
    return (r, s) => (oe(), be("div", G9, [
      de(er, { name: "chat-window-transition" }, {
        default: ut(() => [
          ii(we("div", Z9, [
            de(pl)
          ], 512), [
            [Ju, e.value]
          ])
        ]),
        _: 1
      }),
      we("div", {
        class: "chat-window-toggle",
        onClick: n
      }, [
        de(er, {
          name: "chat-window-toggle-transition",
          mode: "out-in"
        }, {
          default: ut(() => [
            e.value ? (oe(), Se(he(V9), {
              key: 1,
              height: "32",
              width: "32"
            })) : (oe(), Se(he($9), {
              key: 0,
              height: "32",
              width: "32"
            }))
          ]),
          _: 1
        })
      ])
    ]));
  }
});
function W9(t) {
  const e = t.regex, n = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, s = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, o = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, c = t.inherit(o, {
    begin: /\(/,
    end: /\)/
  }), i = t.inherit(t.APOS_STRING_MODE, { className: "string" }), l = t.inherit(t.QUOTE_STRING_MODE, { className: "string" }), a = {
    endsWithParent: !0,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: r,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: !0,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [s]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [s]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          o,
          l,
          i,
          c,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  o,
                  c,
                  l,
                  i
                ]
              }
            ]
          }
        ]
      },
      t.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      s,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              l
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [a],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [a],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: e.concat(
          /</,
          e.lookahead(e.concat(
            n,
            // <tag/>
            // <tag>
            // <tag ...
            e.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0,
            starts: a
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: e.concat(
          /<\//,
          e.lookahead(e.concat(
            n,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: !0
          }
        ]
      }
    ]
  };
}
const Tc = "[A-Za-z$_][0-9A-Za-z$_]*", J9 = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], Y9 = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], hl = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], dl = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], gl = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], X9 = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], Q9 = [].concat(
  gl,
  hl,
  dl
);
function eG(t) {
  const e = t.regex, n = (S, { after: Z }) => {
    const te = "</" + S[0].slice(1);
    return S.input.indexOf(te, Z) !== -1;
  }, r = Tc, s = {
    begin: "<>",
    end: "</>"
  }, o = /<[A-Za-z0-9\\._:-]+\s*\/>/, c = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (S, Z) => {
      const te = S[0].length + S.index, ie = S.input[te];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        ie === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        ie === ","
      ) {
        Z.ignoreMatch();
        return;
      }
      ie === ">" && (n(S, { after: te }) || Z.ignoreMatch());
      let ae;
      const De = S.input.substring(te);
      if (ae = De.match(/^\s*=/)) {
        Z.ignoreMatch();
        return;
      }
      if ((ae = De.match(/^\s+extends\s+/)) && ae.index === 0) {
        Z.ignoreMatch();
        return;
      }
    }
  }, i = {
    $pattern: Tc,
    keyword: J9,
    literal: Y9,
    built_in: Q9,
    "variable.language": X9
  }, l = "[0-9](_?[0-9])*", a = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", f = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${a})|\\.)?|(${a}))[eE][+-]?(${l})\\b` },
      { begin: `\\b(${u})\\b((${a})\\b|\\.)?|(${a})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, p = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: i,
    contains: []
    // defined later
  }, d = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        p
      ],
      subLanguage: "xml"
    }
  }, k = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        p
      ],
      subLanguage: "css"
    }
  }, b = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        p
      ],
      subLanguage: "graphql"
    }
  }, I = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      t.BACKSLASH_ESCAPE,
      p
    ]
  }, C = {
    className: "comment",
    variants: [
      t.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      t.C_BLOCK_COMMENT_MODE,
      t.C_LINE_COMMENT_MODE
    ]
  }, N = [
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    d,
    k,
    b,
    I,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    f
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  p.contains = N.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: i,
    contains: [
      "self"
    ].concat(N)
  });
  const A = [].concat(C, p.contains), j = A.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: i,
      contains: ["self"].concat(A)
    }
  ]), q = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: i,
    contains: j
  }, W = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, $ = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...hl,
        ...dl
      ]
    }
  }, X = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, z = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [q],
    illegal: /%/
  }, J = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function B(S) {
    return e.concat("(?!", S.join("|"), ")");
  }
  const re = {
    match: e.concat(
      /\b/,
      B([
        ...gl,
        "super",
        "import"
      ]),
      r,
      e.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, D = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, ne = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      q
    ]
  }, V = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + t.UNDERSCORE_IDENT_RE + ")\\s*=>", v = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(V)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      q
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: i,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: j, CLASS_REFERENCE: $ },
    illegal: /#(?![$_A-z])/,
    contains: [
      t.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      X,
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      d,
      k,
      b,
      I,
      C,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      f,
      $,
      {
        className: "attr",
        begin: r + e.lookahead(":"),
        relevance: 0
      },
      v,
      {
        // "value" container
        begin: "(" + t.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          C,
          t.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: V,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: t.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: i,
                    contains: j
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: s.begin, end: s.end },
              { match: o },
              {
                begin: c.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": c.isTrulyOpeningTag,
                end: c.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: c.begin,
                end: c.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      z,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + t.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          q,
          t.inherit(t.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      D,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [q]
      },
      re,
      J,
      W,
      ne,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
const tG = /* @__PURE__ */ He({
  __name: "App",
  props: {},
  setup(t) {
    const { options: e } = qi(), n = Xt(() => e.mode === "fullscreen");
    return Dn(() => {
      sr.registerLanguage("xml", W9), sr.registerLanguage("javascript", eG);
    }), (r, s) => n.value ? (oe(), Se(he(pl), {
      key: 0,
      class: "n8n-chat"
    })) : (oe(), Se(he(K9), {
      key: 1,
      class: "n8n-chat"
    }));
  }
});
var Un, nG = new Uint8Array(16);
function rG() {
  if (!Un && (Un = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !Un))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Un(nG);
}
const sG = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function oG(t) {
  return typeof t == "string" && sG.test(t);
}
var ve = [];
for (var Yr = 0; Yr < 256; ++Yr)
  ve.push((Yr + 256).toString(16).substr(1));
function cG(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = (ve[t[e + 0]] + ve[t[e + 1]] + ve[t[e + 2]] + ve[t[e + 3]] + "-" + ve[t[e + 4]] + ve[t[e + 5]] + "-" + ve[t[e + 6]] + ve[t[e + 7]] + "-" + ve[t[e + 8]] + ve[t[e + 9]] + "-" + ve[t[e + 10]] + ve[t[e + 11]] + ve[t[e + 12]] + ve[t[e + 13]] + ve[t[e + 14]] + ve[t[e + 15]]).toLowerCase();
  if (!oG(n))
    throw TypeError("Stringified UUID is invalid");
  return n;
}
function an(t, e, n) {
  t = t || {};
  var r = t.random || (t.rng || rG)();
  if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, e) {
    n = n || 0;
    for (var s = 0; s < 16; ++s)
      e[n + s] = r[s];
    return e;
  }
  return cG(r);
}
async function iG() {
  return "";
}
async function ml(...t) {
  var r;
  const e = await iG();
  return await (await fetch(t[0], {
    ...t[1],
    mode: "cors",
    cache: "no-cache",
    headers: {
      ...e ? { authorization: `Bearer ${e}` } : {},
      ...(r = t[1]) == null ? void 0 : r.headers
    }
  })).json();
}
async function _l(t, e = {}, n = {}) {
  let r = t;
  return Object.keys(e).length > 0 && (r = `${r}?${new URLSearchParams(e).toString()}`), ml(r, { ...n, method: "GET" });
}
async function bl(t, e = {}, n = {}) {
  return ml(t, {
    ...n,
    method: "POST",
    body: JSON.stringify(e)
  });
}
async function lG(t, e) {
  var r, s;
  return (((r = e.webhookConfig) == null ? void 0 : r.method) === "POST" ? bl : _l)(
    `${e.webhookUrl}`,
    {
      action: "loadPreviousSession",
      sessionId: t
    },
    {
      headers: (s = e.webhookConfig) == null ? void 0 : s.headers
    }
  );
}
async function aG(t, e, n) {
  var s, o;
  return (((s = n.webhookConfig) == null ? void 0 : s.method) === "POST" ? bl : _l)(
    `${n.webhookUrl}`,
    {
      action: "sendMessage",
      sessionId: e,
      message: t
    },
    {
      headers: (o = n.webhookConfig) == null ? void 0 : o.headers
    }
  );
}
const uG = {
  install(t, e) {
    t.provide(Ri, e);
    const n = zt([]), r = zt(null), s = zt(!1), o = Xt(
      () => (e.initialMessages ?? []).map((a) => ({
        id: an(),
        text: a,
        sender: "bot",
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      }))
    );
    async function c(a) {
      const u = {
        id: an(),
        text: a,
        sender: "user",
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      n.value.push(u), s.value = !0, Zt(() => {
        Tt.emit("scrollToBottom");
      });
      const f = await aG(
        a,
        r.value,
        e
      ), p = {
        id: an(),
        text: f.output,
        sender: "bot",
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      n.value.push(p), s.value = !1, Zt(() => {
        Tt.emit("scrollToBottom");
      });
    }
    async function i() {
      const a = localStorage.getItem(Oo) ?? an(), u = await lG(a, e), f = (/* @__PURE__ */ new Date()).toISOString();
      return n.value = ((u == null ? void 0 : u.data) || []).map((p, d) => ({
        id: `${d}`,
        text: p.kwargs.content,
        sender: p.id.includes("HumanMessage") ? "user" : "bot",
        createdAt: f
      })), n.value.length && (r.value = a), a;
    }
    async function l() {
      r.value = an(), localStorage.setItem(Oo, r.value);
    }
    t.provide(Ti, {
      initialMessages: o,
      messages: n,
      currentSessionId: r,
      waitingForResponse: s,
      loadPreviousSession: i,
      startNewSession: l,
      sendMessage: c
    });
  }
};
function fG(t) {
  var s, o;
  const e = {
    ...ln,
    ...t,
    webhookConfig: {
      ...ln.webhookConfig,
      ...t == null ? void 0 : t.webhookConfig
    },
    i18n: {
      ...ln.i18n,
      ...t == null ? void 0 : t.i18n,
      en: {
        ...(s = ln.i18n) == null ? void 0 : s.en,
        ...(o = t == null ? void 0 : t.i18n) == null ? void 0 : o.en
      }
    },
    theme: {
      ...ln.theme,
      ...t == null ? void 0 : t.theme
    }
  }, n = e.target ?? pf;
  typeof n == "string" && cf(n);
  const r = Qu(tG);
  return r.use(uG, e), r.mount(n), r;
}
export {
  fG as createChat
};
