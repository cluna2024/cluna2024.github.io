import { openBlock as F, createElementBlock as G, renderSlot as Le, defineComponent as te, ref as Ce, onMounted as In, onBeforeUnmount as no, createCommentVNode as Fe, inject as Qt, createVNode as be, withCtx as ve, createTextVNode as er, toDisplayString as Xe, unref as V, createElementVNode as J, h as to, toRefs as ro, computed as $e, normalizeClass as nr, createBlock as X, Fragment as rt, renderList as ot, withDirectives as tr, withKeys as oo, vModelText as so, createSlots as co, nextTick as Oe, Transition as st, vShow as io, createApp as ao } from "vue";
const rr = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [r, o] of e)
    t[r] = o;
  return t;
}, lo = {}, uo = { class: "chat-button" };
function fo(n, e) {
  return F(), G("button", uo, [
    Le(n.$slots, "default")
  ]);
}
const po = /* @__PURE__ */ rr(lo, [["render", fo]]);
function ho() {
  const n = /* @__PURE__ */ new Map();
  function e(o, s) {
    const c = n.get(o);
    c && c.splice(c.indexOf(s) >>> 0, 1);
  }
  function t(o, s) {
    let c = n.get(o);
    return c ? c.push(s) : c = [s], n.set(o, c), () => e(o, s);
  }
  function r(o, s) {
    const c = n.get(o);
    c && c.slice().forEach(async (i) => {
      await i(s);
    });
  }
  return {
    on: t,
    off: e,
    emit: r
  };
}
function go(n) {
  if (!document.querySelector(n)) {
    const t = document.createElement("div");
    n.startsWith("#") && (t.id = n.replace("#", "")), n.startsWith(".") && t.classList.add(n.replace(".", "")), document.body.appendChild(t);
  }
}
const xe = ho(), mo = { class: "chat-layout" }, _o = {
  key: 0,
  class: "chat-header"
}, bo = {
  key: 2,
  class: "chat-footer"
}, vo = /* @__PURE__ */ te({
  __name: "Layout",
  setup(n) {
    const e = Ce(null);
    function t() {
      const r = e.value;
      r && (r.scrollTop = r.scrollHeight);
    }
    return In(() => {
      xe.on("scrollToBottom", t), window.addEventListener("resize", t);
    }), no(() => {
      xe.off("scrollToBottom", t), window.removeEventListener("resize", t);
    }), (r, o) => (F(), G("main", mo, [
      r.$slots.header ? (F(), G("div", _o, [
        Le(r.$slots, "header")
      ])) : Fe("", !0),
      r.$slots.default ? (F(), G("div", {
        key: 1,
        class: "chat-body",
        ref_key: "chatBodyRef",
        ref: e
      }, [
        Le(r.$slots, "default")
      ], 512)) : Fe("", !0),
      r.$slots.footer ? (F(), G("div", bo, [
        Le(r.$slots, "footer")
      ])) : Fe("", !0)
    ]));
  }
});
const Ne = {
  webhookUrl: "http://localhost:5678",
  webhookConfig: {
    method: "POST",
    headers: {}
  },
  target: "#n8n-chat",
  mode: "window",
  defaultLanguage: "en",
  initialMessages: ["Hi there! 👋", "My name is Nathan. How can I assist you today?"],
  i18n: {
    en: {
      title: "Hi there! 👋",
      subtitle: "Start a chat. We're here to help you 24/7.",
      footer: "",
      getStarted: "New Conversation",
      inputPlaceholder: "Type your question.."
    }
  },
  theme: {}
}, ko = "#n8n-chat", xo = "n8n-chat", ct = `${xo}/sessionId`, or = "Chat", sr = "ChatOptions";
function On() {
  return Qt(or);
}
function cr() {
  return {
    options: Qt(sr)
  };
}
function rn() {
  const { options: n } = cr(), e = (n == null ? void 0 : n.defaultLanguage) ?? "en";
  function t(o) {
    var s, c;
    return ((c = (s = n == null ? void 0 : n.i18n) == null ? void 0 : s[e]) == null ? void 0 : c[o]) ?? o;
  }
  function r(o) {
    var s, c;
    return !!((c = (s = n == null ? void 0 : n.i18n) == null ? void 0 : s[e]) != null && c[o]);
  }
  return { t, te: r };
}
const yo = { class: "chat-get-started" }, wo = /* @__PURE__ */ te({
  __name: "GetStarted",
  setup(n) {
    const { t: e } = rn();
    return (t, r) => (F(), G("div", yo, [
      be(po, {
        onClick: r[0] || (r[0] = (o) => t.$emit("click:button"))
      }, {
        default: ve(() => [
          er(Xe(V(e)("getStarted")), 1)
        ]),
        _: 1
      })
    ]));
  }
});
const Eo = {}, Ao = { class: "chat-powered-by" }, Co = /* @__PURE__ */ J("a", { href: "https://n8n.io?utm_source=n8n-external&utm_medium=widget-powered-by" }, "n8n", -1);
function So(n, e) {
  return F(), G("div", Ao, [
    er(" Powered by "),
    Co
  ]);
}
const Do = /* @__PURE__ */ rr(Eo, [["render", So]]), qo = { class: "chat-get-started-footer" }, To = { key: 0 }, Ro = /* @__PURE__ */ te({
  __name: "GetStartedFooter",
  setup(n) {
    const { t: e, te: t } = rn();
    return (r, o) => (F(), G("div", qo, [
      V(t)("footer") ? (F(), G("div", To, Xe(V(e)("footer")), 1)) : Fe("", !0),
      be(Do)
    ]));
  }
});
function ir(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function No(n) {
  if (n.__esModule)
    return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function(r) {
    var o = Object.getOwnPropertyDescriptor(n, r);
    Object.defineProperty(t, r, o.get ? o : {
      enumerable: !0,
      get: function() {
        return n[r];
      }
    });
  }), t;
}
var I = {};
const Mo = "Á", Lo = "á", Fo = "Ă", Io = "ă", Oo = "∾", Bo = "∿", Po = "∾̳", zo = "Â", $o = "â", Uo = "´", Vo = "А", Go = "а", Ho = "Æ", jo = "æ", Zo = "⁡", Wo = "𝔄", Ko = "𝔞", Jo = "À", Yo = "à", Xo = "ℵ", Qo = "ℵ", es = "Α", ns = "α", ts = "Ā", rs = "ā", os = "⨿", ss = "&", cs = "&", is = "⩕", as = "⩓", ls = "∧", us = "⩜", fs = "⩘", ps = "⩚", hs = "∠", ds = "⦤", gs = "∠", ms = "⦨", _s = "⦩", bs = "⦪", vs = "⦫", ks = "⦬", xs = "⦭", ys = "⦮", ws = "⦯", Es = "∡", As = "∟", Cs = "⊾", Ss = "⦝", Ds = "∢", qs = "Å", Ts = "⍼", Rs = "Ą", Ns = "ą", Ms = "𝔸", Ls = "𝕒", Fs = "⩯", Is = "≈", Os = "⩰", Bs = "≊", Ps = "≋", zs = "'", $s = "⁡", Us = "≈", Vs = "≊", Gs = "Å", Hs = "å", js = "𝒜", Zs = "𝒶", Ws = "≔", Ks = "*", Js = "≈", Ys = "≍", Xs = "Ã", Qs = "ã", ec = "Ä", nc = "ä", tc = "∳", rc = "⨑", oc = "≌", sc = "϶", cc = "‵", ic = "∽", ac = "⋍", lc = "∖", uc = "⫧", fc = "⊽", pc = "⌅", hc = "⌆", dc = "⌅", gc = "⎵", mc = "⎶", _c = "≌", bc = "Б", vc = "б", kc = "„", xc = "∵", yc = "∵", wc = "∵", Ec = "⦰", Ac = "϶", Cc = "ℬ", Sc = "ℬ", Dc = "Β", qc = "β", Tc = "ℶ", Rc = "≬", Nc = "𝔅", Mc = "𝔟", Lc = "⋂", Fc = "◯", Ic = "⋃", Oc = "⨀", Bc = "⨁", Pc = "⨂", zc = "⨆", $c = "★", Uc = "▽", Vc = "△", Gc = "⨄", Hc = "⋁", jc = "⋀", Zc = "⤍", Wc = "⧫", Kc = "▪", Jc = "▴", Yc = "▾", Xc = "◂", Qc = "▸", ei = "␣", ni = "▒", ti = "░", ri = "▓", oi = "█", si = "=⃥", ci = "≡⃥", ii = "⫭", ai = "⌐", li = "𝔹", ui = "𝕓", fi = "⊥", pi = "⊥", hi = "⋈", di = "⧉", gi = "┐", mi = "╕", _i = "╖", bi = "╗", vi = "┌", ki = "╒", xi = "╓", yi = "╔", wi = "─", Ei = "═", Ai = "┬", Ci = "╤", Si = "╥", Di = "╦", qi = "┴", Ti = "╧", Ri = "╨", Ni = "╩", Mi = "⊟", Li = "⊞", Fi = "⊠", Ii = "┘", Oi = "╛", Bi = "╜", Pi = "╝", zi = "└", $i = "╘", Ui = "╙", Vi = "╚", Gi = "│", Hi = "║", ji = "┼", Zi = "╪", Wi = "╫", Ki = "╬", Ji = "┤", Yi = "╡", Xi = "╢", Qi = "╣", ea = "├", na = "╞", ta = "╟", ra = "╠", oa = "‵", sa = "˘", ca = "˘", ia = "¦", aa = "𝒷", la = "ℬ", ua = "⁏", fa = "∽", pa = "⋍", ha = "⧅", da = "\\", ga = "⟈", ma = "•", _a = "•", ba = "≎", va = "⪮", ka = "≏", xa = "≎", ya = "≏", wa = "Ć", Ea = "ć", Aa = "⩄", Ca = "⩉", Sa = "⩋", Da = "∩", qa = "⋒", Ta = "⩇", Ra = "⩀", Na = "ⅅ", Ma = "∩︀", La = "⁁", Fa = "ˇ", Ia = "ℭ", Oa = "⩍", Ba = "Č", Pa = "č", za = "Ç", $a = "ç", Ua = "Ĉ", Va = "ĉ", Ga = "∰", Ha = "⩌", ja = "⩐", Za = "Ċ", Wa = "ċ", Ka = "¸", Ja = "¸", Ya = "⦲", Xa = "¢", Qa = "·", el = "·", nl = "𝔠", tl = "ℭ", rl = "Ч", ol = "ч", sl = "✓", cl = "✓", il = "Χ", al = "χ", ll = "ˆ", ul = "≗", fl = "↺", pl = "↻", hl = "⊛", dl = "⊚", gl = "⊝", ml = "⊙", _l = "®", bl = "Ⓢ", vl = "⊖", kl = "⊕", xl = "⊗", yl = "○", wl = "⧃", El = "≗", Al = "⨐", Cl = "⫯", Sl = "⧂", Dl = "∲", ql = "”", Tl = "’", Rl = "♣", Nl = "♣", Ml = ":", Ll = "∷", Fl = "⩴", Il = "≔", Ol = "≔", Bl = ",", Pl = "@", zl = "∁", $l = "∘", Ul = "∁", Vl = "ℂ", Gl = "≅", Hl = "⩭", jl = "≡", Zl = "∮", Wl = "∯", Kl = "∮", Jl = "𝕔", Yl = "ℂ", Xl = "∐", Ql = "∐", eu = "©", nu = "©", tu = "℗", ru = "∳", ou = "↵", su = "✗", cu = "⨯", iu = "𝒞", au = "𝒸", lu = "⫏", uu = "⫑", fu = "⫐", pu = "⫒", hu = "⋯", du = "⤸", gu = "⤵", mu = "⋞", _u = "⋟", bu = "↶", vu = "⤽", ku = "⩈", xu = "⩆", yu = "≍", wu = "∪", Eu = "⋓", Au = "⩊", Cu = "⊍", Su = "⩅", Du = "∪︀", qu = "↷", Tu = "⤼", Ru = "⋞", Nu = "⋟", Mu = "⋎", Lu = "⋏", Fu = "¤", Iu = "↶", Ou = "↷", Bu = "⋎", Pu = "⋏", zu = "∲", $u = "∱", Uu = "⌭", Vu = "†", Gu = "‡", Hu = "ℸ", ju = "↓", Zu = "↡", Wu = "⇓", Ku = "‐", Ju = "⫤", Yu = "⊣", Xu = "⤏", Qu = "˝", ef = "Ď", nf = "ď", tf = "Д", rf = "д", of = "‡", sf = "⇊", cf = "ⅅ", af = "ⅆ", lf = "⤑", uf = "⩷", ff = "°", pf = "∇", hf = "Δ", df = "δ", gf = "⦱", mf = "⥿", _f = "𝔇", bf = "𝔡", vf = "⥥", kf = "⇃", xf = "⇂", yf = "´", wf = "˙", Ef = "˝", Af = "`", Cf = "˜", Sf = "⋄", Df = "⋄", qf = "⋄", Tf = "♦", Rf = "♦", Nf = "¨", Mf = "ⅆ", Lf = "ϝ", Ff = "⋲", If = "÷", Of = "÷", Bf = "⋇", Pf = "⋇", zf = "Ђ", $f = "ђ", Uf = "⌞", Vf = "⌍", Gf = "$", Hf = "𝔻", jf = "𝕕", Zf = "¨", Wf = "˙", Kf = "⃜", Jf = "≐", Yf = "≑", Xf = "≐", Qf = "∸", ep = "∔", np = "⊡", tp = "⌆", rp = "∯", op = "¨", sp = "⇓", cp = "⇐", ip = "⇔", ap = "⫤", lp = "⟸", up = "⟺", fp = "⟹", pp = "⇒", hp = "⊨", dp = "⇑", gp = "⇕", mp = "∥", _p = "⤓", bp = "↓", vp = "↓", kp = "⇓", xp = "⇵", yp = "̑", wp = "⇊", Ep = "⇃", Ap = "⇂", Cp = "⥐", Sp = "⥞", Dp = "⥖", qp = "↽", Tp = "⥟", Rp = "⥗", Np = "⇁", Mp = "↧", Lp = "⊤", Fp = "⤐", Ip = "⌟", Op = "⌌", Bp = "𝒟", Pp = "𝒹", zp = "Ѕ", $p = "ѕ", Up = "⧶", Vp = "Đ", Gp = "đ", Hp = "⋱", jp = "▿", Zp = "▾", Wp = "⇵", Kp = "⥯", Jp = "⦦", Yp = "Џ", Xp = "џ", Qp = "⟿", eh = "É", nh = "é", th = "⩮", rh = "Ě", oh = "ě", sh = "Ê", ch = "ê", ih = "≖", ah = "≕", lh = "Э", uh = "э", fh = "⩷", ph = "Ė", hh = "ė", dh = "≑", gh = "ⅇ", mh = "≒", _h = "𝔈", bh = "𝔢", vh = "⪚", kh = "È", xh = "è", yh = "⪖", wh = "⪘", Eh = "⪙", Ah = "∈", Ch = "⏧", Sh = "ℓ", Dh = "⪕", qh = "⪗", Th = "Ē", Rh = "ē", Nh = "∅", Mh = "∅", Lh = "◻", Fh = "∅", Ih = "▫", Oh = " ", Bh = " ", Ph = " ", zh = "Ŋ", $h = "ŋ", Uh = " ", Vh = "Ę", Gh = "ę", Hh = "𝔼", jh = "𝕖", Zh = "⋕", Wh = "⧣", Kh = "⩱", Jh = "ε", Yh = "Ε", Xh = "ε", Qh = "ϵ", ed = "≖", nd = "≕", td = "≂", rd = "⪖", od = "⪕", sd = "⩵", cd = "=", id = "≂", ad = "≟", ld = "⇌", ud = "≡", fd = "⩸", pd = "⧥", hd = "⥱", dd = "≓", gd = "ℯ", md = "ℰ", _d = "≐", bd = "⩳", vd = "≂", kd = "Η", xd = "η", yd = "Ð", wd = "ð", Ed = "Ë", Ad = "ë", Cd = "€", Sd = "!", Dd = "∃", qd = "∃", Td = "ℰ", Rd = "ⅇ", Nd = "ⅇ", Md = "≒", Ld = "Ф", Fd = "ф", Id = "♀", Od = "ﬃ", Bd = "ﬀ", Pd = "ﬄ", zd = "𝔉", $d = "𝔣", Ud = "ﬁ", Vd = "◼", Gd = "▪", Hd = "fj", jd = "♭", Zd = "ﬂ", Wd = "▱", Kd = "ƒ", Jd = "𝔽", Yd = "𝕗", Xd = "∀", Qd = "∀", eg = "⋔", ng = "⫙", tg = "ℱ", rg = "⨍", og = "½", sg = "⅓", cg = "¼", ig = "⅕", ag = "⅙", lg = "⅛", ug = "⅔", fg = "⅖", pg = "¾", hg = "⅗", dg = "⅜", gg = "⅘", mg = "⅚", _g = "⅝", bg = "⅞", vg = "⁄", kg = "⌢", xg = "𝒻", yg = "ℱ", wg = "ǵ", Eg = "Γ", Ag = "γ", Cg = "Ϝ", Sg = "ϝ", Dg = "⪆", qg = "Ğ", Tg = "ğ", Rg = "Ģ", Ng = "Ĝ", Mg = "ĝ", Lg = "Г", Fg = "г", Ig = "Ġ", Og = "ġ", Bg = "≥", Pg = "≧", zg = "⪌", $g = "⋛", Ug = "≥", Vg = "≧", Gg = "⩾", Hg = "⪩", jg = "⩾", Zg = "⪀", Wg = "⪂", Kg = "⪄", Jg = "⋛︀", Yg = "⪔", Xg = "𝔊", Qg = "𝔤", em = "≫", nm = "⋙", tm = "⋙", rm = "ℷ", om = "Ѓ", sm = "ѓ", cm = "⪥", im = "≷", am = "⪒", lm = "⪤", um = "⪊", fm = "⪊", pm = "⪈", hm = "≩", dm = "⪈", gm = "≩", mm = "⋧", _m = "𝔾", bm = "𝕘", vm = "`", km = "≥", xm = "⋛", ym = "≧", wm = "⪢", Em = "≷", Am = "⩾", Cm = "≳", Sm = "𝒢", Dm = "ℊ", qm = "≳", Tm = "⪎", Rm = "⪐", Nm = "⪧", Mm = "⩺", Lm = ">", Fm = ">", Im = "≫", Om = "⋗", Bm = "⦕", Pm = "⩼", zm = "⪆", $m = "⥸", Um = "⋗", Vm = "⋛", Gm = "⪌", Hm = "≷", jm = "≳", Zm = "≩︀", Wm = "≩︀", Km = "ˇ", Jm = " ", Ym = "½", Xm = "ℋ", Qm = "Ъ", e_ = "ъ", n_ = "⥈", t_ = "↔", r_ = "⇔", o_ = "↭", s_ = "^", c_ = "ℏ", i_ = "Ĥ", a_ = "ĥ", l_ = "♥", u_ = "♥", f_ = "…", p_ = "⊹", h_ = "𝔥", d_ = "ℌ", g_ = "ℋ", m_ = "⤥", __ = "⤦", b_ = "⇿", v_ = "∻", k_ = "↩", x_ = "↪", y_ = "𝕙", w_ = "ℍ", E_ = "―", A_ = "─", C_ = "𝒽", S_ = "ℋ", D_ = "ℏ", q_ = "Ħ", T_ = "ħ", R_ = "≎", N_ = "≏", M_ = "⁃", L_ = "‐", F_ = "Í", I_ = "í", O_ = "⁣", B_ = "Î", P_ = "î", z_ = "И", $_ = "и", U_ = "İ", V_ = "Е", G_ = "е", H_ = "¡", j_ = "⇔", Z_ = "𝔦", W_ = "ℑ", K_ = "Ì", J_ = "ì", Y_ = "ⅈ", X_ = "⨌", Q_ = "∭", eb = "⧜", nb = "℩", tb = "Ĳ", rb = "ĳ", ob = "Ī", sb = "ī", cb = "ℑ", ib = "ⅈ", ab = "ℐ", lb = "ℑ", ub = "ı", fb = "ℑ", pb = "⊷", hb = "Ƶ", db = "⇒", gb = "℅", mb = "∞", _b = "⧝", bb = "ı", vb = "⊺", kb = "∫", xb = "∬", yb = "ℤ", wb = "∫", Eb = "⊺", Ab = "⋂", Cb = "⨗", Sb = "⨼", Db = "⁣", qb = "⁢", Tb = "Ё", Rb = "ё", Nb = "Į", Mb = "į", Lb = "𝕀", Fb = "𝕚", Ib = "Ι", Ob = "ι", Bb = "⨼", Pb = "¿", zb = "𝒾", $b = "ℐ", Ub = "∈", Vb = "⋵", Gb = "⋹", Hb = "⋴", jb = "⋳", Zb = "∈", Wb = "⁢", Kb = "Ĩ", Jb = "ĩ", Yb = "І", Xb = "і", Qb = "Ï", e0 = "ï", n0 = "Ĵ", t0 = "ĵ", r0 = "Й", o0 = "й", s0 = "𝔍", c0 = "𝔧", i0 = "ȷ", a0 = "𝕁", l0 = "𝕛", u0 = "𝒥", f0 = "𝒿", p0 = "Ј", h0 = "ј", d0 = "Є", g0 = "є", m0 = "Κ", _0 = "κ", b0 = "ϰ", v0 = "Ķ", k0 = "ķ", x0 = "К", y0 = "к", w0 = "𝔎", E0 = "𝔨", A0 = "ĸ", C0 = "Х", S0 = "х", D0 = "Ќ", q0 = "ќ", T0 = "𝕂", R0 = "𝕜", N0 = "𝒦", M0 = "𝓀", L0 = "⇚", F0 = "Ĺ", I0 = "ĺ", O0 = "⦴", B0 = "ℒ", P0 = "Λ", z0 = "λ", $0 = "⟨", U0 = "⟪", V0 = "⦑", G0 = "⟨", H0 = "⪅", j0 = "ℒ", Z0 = "«", W0 = "⇤", K0 = "⤟", J0 = "←", Y0 = "↞", X0 = "⇐", Q0 = "⤝", ev = "↩", nv = "↫", tv = "⤹", rv = "⥳", ov = "↢", sv = "⤙", cv = "⤛", iv = "⪫", av = "⪭", lv = "⪭︀", uv = "⤌", fv = "⤎", pv = "❲", hv = "{", dv = "[", gv = "⦋", mv = "⦏", _v = "⦍", bv = "Ľ", vv = "ľ", kv = "Ļ", xv = "ļ", yv = "⌈", wv = "{", Ev = "Л", Av = "л", Cv = "⤶", Sv = "“", Dv = "„", qv = "⥧", Tv = "⥋", Rv = "↲", Nv = "≤", Mv = "≦", Lv = "⟨", Fv = "⇤", Iv = "←", Ov = "←", Bv = "⇐", Pv = "⇆", zv = "↢", $v = "⌈", Uv = "⟦", Vv = "⥡", Gv = "⥙", Hv = "⇃", jv = "⌊", Zv = "↽", Wv = "↼", Kv = "⇇", Jv = "↔", Yv = "↔", Xv = "⇔", Qv = "⇆", ek = "⇋", nk = "↭", tk = "⥎", rk = "↤", ok = "⊣", sk = "⥚", ck = "⋋", ik = "⧏", ak = "⊲", lk = "⊴", uk = "⥑", fk = "⥠", pk = "⥘", hk = "↿", dk = "⥒", gk = "↼", mk = "⪋", _k = "⋚", bk = "≤", vk = "≦", kk = "⩽", xk = "⪨", yk = "⩽", wk = "⩿", Ek = "⪁", Ak = "⪃", Ck = "⋚︀", Sk = "⪓", Dk = "⪅", qk = "⋖", Tk = "⋚", Rk = "⪋", Nk = "⋚", Mk = "≦", Lk = "≶", Fk = "≶", Ik = "⪡", Ok = "≲", Bk = "⩽", Pk = "≲", zk = "⥼", $k = "⌊", Uk = "𝔏", Vk = "𝔩", Gk = "≶", Hk = "⪑", jk = "⥢", Zk = "↽", Wk = "↼", Kk = "⥪", Jk = "▄", Yk = "Љ", Xk = "љ", Qk = "⇇", ex = "≪", nx = "⋘", tx = "⌞", rx = "⇚", ox = "⥫", sx = "◺", cx = "Ŀ", ix = "ŀ", ax = "⎰", lx = "⎰", ux = "⪉", fx = "⪉", px = "⪇", hx = "≨", dx = "⪇", gx = "≨", mx = "⋦", _x = "⟬", bx = "⇽", vx = "⟦", kx = "⟵", xx = "⟵", yx = "⟸", wx = "⟷", Ex = "⟷", Ax = "⟺", Cx = "⟼", Sx = "⟶", Dx = "⟶", qx = "⟹", Tx = "↫", Rx = "↬", Nx = "⦅", Mx = "𝕃", Lx = "𝕝", Fx = "⨭", Ix = "⨴", Ox = "∗", Bx = "_", Px = "↙", zx = "↘", $x = "◊", Ux = "◊", Vx = "⧫", Gx = "(", Hx = "⦓", jx = "⇆", Zx = "⌟", Wx = "⇋", Kx = "⥭", Jx = "‎", Yx = "⊿", Xx = "‹", Qx = "𝓁", ey = "ℒ", ny = "↰", ty = "↰", ry = "≲", oy = "⪍", sy = "⪏", cy = "[", iy = "‘", ay = "‚", ly = "Ł", uy = "ł", fy = "⪦", py = "⩹", hy = "<", dy = "<", gy = "≪", my = "⋖", _y = "⋋", by = "⋉", vy = "⥶", ky = "⩻", xy = "◃", yy = "⊴", wy = "◂", Ey = "⦖", Ay = "⥊", Cy = "⥦", Sy = "≨︀", Dy = "≨︀", qy = "¯", Ty = "♂", Ry = "✠", Ny = "✠", My = "↦", Ly = "↦", Fy = "↧", Iy = "↤", Oy = "↥", By = "▮", Py = "⨩", zy = "М", $y = "м", Uy = "—", Vy = "∺", Gy = "∡", Hy = " ", jy = "ℳ", Zy = "𝔐", Wy = "𝔪", Ky = "℧", Jy = "µ", Yy = "*", Xy = "⫰", Qy = "∣", ew = "·", nw = "⊟", tw = "−", rw = "∸", ow = "⨪", sw = "∓", cw = "⫛", iw = "…", aw = "∓", lw = "⊧", uw = "𝕄", fw = "𝕞", pw = "∓", hw = "𝓂", dw = "ℳ", gw = "∾", mw = "Μ", _w = "μ", bw = "⊸", vw = "⊸", kw = "∇", xw = "Ń", yw = "ń", ww = "∠⃒", Ew = "≉", Aw = "⩰̸", Cw = "≋̸", Sw = "ŉ", Dw = "≉", qw = "♮", Tw = "ℕ", Rw = "♮", Nw = " ", Mw = "≎̸", Lw = "≏̸", Fw = "⩃", Iw = "Ň", Ow = "ň", Bw = "Ņ", Pw = "ņ", zw = "≇", $w = "⩭̸", Uw = "⩂", Vw = "Н", Gw = "н", Hw = "–", jw = "⤤", Zw = "↗", Ww = "⇗", Kw = "↗", Jw = "≠", Yw = "≐̸", Xw = "​", Qw = "​", eE = "​", nE = "​", tE = "≢", rE = "⤨", oE = "≂̸", sE = "≫", cE = "≪", iE = `
`, aE = "∄", lE = "∄", uE = "𝔑", fE = "𝔫", pE = "≧̸", hE = "≱", dE = "≱", gE = "≧̸", mE = "⩾̸", _E = "⩾̸", bE = "⋙̸", vE = "≵", kE = "≫⃒", xE = "≯", yE = "≯", wE = "≫̸", EE = "↮", AE = "⇎", CE = "⫲", SE = "∋", DE = "⋼", qE = "⋺", TE = "∋", RE = "Њ", NE = "њ", ME = "↚", LE = "⇍", FE = "‥", IE = "≦̸", OE = "≰", BE = "↚", PE = "⇍", zE = "↮", $E = "⇎", UE = "≰", VE = "≦̸", GE = "⩽̸", HE = "⩽̸", jE = "≮", ZE = "⋘̸", WE = "≴", KE = "≪⃒", JE = "≮", YE = "⋪", XE = "⋬", QE = "≪̸", eA = "∤", nA = "⁠", tA = " ", rA = "𝕟", oA = "ℕ", sA = "⫬", cA = "¬", iA = "≢", aA = "≭", lA = "∦", uA = "∉", fA = "≠", pA = "≂̸", hA = "∄", dA = "≯", gA = "≱", mA = "≧̸", _A = "≫̸", bA = "≹", vA = "⩾̸", kA = "≵", xA = "≎̸", yA = "≏̸", wA = "∉", EA = "⋵̸", AA = "⋹̸", CA = "∉", SA = "⋷", DA = "⋶", qA = "⧏̸", TA = "⋪", RA = "⋬", NA = "≮", MA = "≰", LA = "≸", FA = "≪̸", IA = "⩽̸", OA = "≴", BA = "⪢̸", PA = "⪡̸", zA = "∌", $A = "∌", UA = "⋾", VA = "⋽", GA = "⊀", HA = "⪯̸", jA = "⋠", ZA = "∌", WA = "⧐̸", KA = "⋫", JA = "⋭", YA = "⊏̸", XA = "⋢", QA = "⊐̸", eC = "⋣", nC = "⊂⃒", tC = "⊈", rC = "⊁", oC = "⪰̸", sC = "⋡", cC = "≿̸", iC = "⊃⃒", aC = "⊉", lC = "≁", uC = "≄", fC = "≇", pC = "≉", hC = "∤", dC = "∦", gC = "∦", mC = "⫽⃥", _C = "∂̸", bC = "⨔", vC = "⊀", kC = "⋠", xC = "⊀", yC = "⪯̸", wC = "⪯̸", EC = "⤳̸", AC = "↛", CC = "⇏", SC = "↝̸", DC = "↛", qC = "⇏", TC = "⋫", RC = "⋭", NC = "⊁", MC = "⋡", LC = "⪰̸", FC = "𝒩", IC = "𝓃", OC = "∤", BC = "∦", PC = "≁", zC = "≄", $C = "≄", UC = "∤", VC = "∦", GC = "⋢", HC = "⋣", jC = "⊄", ZC = "⫅̸", WC = "⊈", KC = "⊂⃒", JC = "⊈", YC = "⫅̸", XC = "⊁", QC = "⪰̸", e1 = "⊅", n1 = "⫆̸", t1 = "⊉", r1 = "⊃⃒", o1 = "⊉", s1 = "⫆̸", c1 = "≹", i1 = "Ñ", a1 = "ñ", l1 = "≸", u1 = "⋪", f1 = "⋬", p1 = "⋫", h1 = "⋭", d1 = "Ν", g1 = "ν", m1 = "#", _1 = "№", b1 = " ", v1 = "≍⃒", k1 = "⊬", x1 = "⊭", y1 = "⊮", w1 = "⊯", E1 = "≥⃒", A1 = ">⃒", C1 = "⤄", S1 = "⧞", D1 = "⤂", q1 = "≤⃒", T1 = "<⃒", R1 = "⊴⃒", N1 = "⤃", M1 = "⊵⃒", L1 = "∼⃒", F1 = "⤣", I1 = "↖", O1 = "⇖", B1 = "↖", P1 = "⤧", z1 = "Ó", $1 = "ó", U1 = "⊛", V1 = "Ô", G1 = "ô", H1 = "⊚", j1 = "О", Z1 = "о", W1 = "⊝", K1 = "Ő", J1 = "ő", Y1 = "⨸", X1 = "⊙", Q1 = "⦼", eS = "Œ", nS = "œ", tS = "⦿", rS = "𝔒", oS = "𝔬", sS = "˛", cS = "Ò", iS = "ò", aS = "⧁", lS = "⦵", uS = "Ω", fS = "∮", pS = "↺", hS = "⦾", dS = "⦻", gS = "‾", mS = "⧀", _S = "Ō", bS = "ō", vS = "Ω", kS = "ω", xS = "Ο", yS = "ο", wS = "⦶", ES = "⊖", AS = "𝕆", CS = "𝕠", SS = "⦷", DS = "“", qS = "‘", TS = "⦹", RS = "⊕", NS = "↻", MS = "⩔", LS = "∨", FS = "⩝", IS = "ℴ", OS = "ℴ", BS = "ª", PS = "º", zS = "⊶", $S = "⩖", US = "⩗", VS = "⩛", GS = "Ⓢ", HS = "𝒪", jS = "ℴ", ZS = "Ø", WS = "ø", KS = "⊘", JS = "Õ", YS = "õ", XS = "⨶", QS = "⨷", eD = "⊗", nD = "Ö", tD = "ö", rD = "⌽", oD = "‾", sD = "⏞", cD = "⎴", iD = "⏜", aD = "¶", lD = "∥", uD = "∥", fD = "⫳", pD = "⫽", hD = "∂", dD = "∂", gD = "П", mD = "п", _D = "%", bD = ".", vD = "‰", kD = "⊥", xD = "‱", yD = "𝔓", wD = "𝔭", ED = "Φ", AD = "φ", CD = "ϕ", SD = "ℳ", DD = "☎", qD = "Π", TD = "π", RD = "⋔", ND = "ϖ", MD = "ℏ", LD = "ℎ", FD = "ℏ", ID = "⨣", OD = "⊞", BD = "⨢", PD = "+", zD = "∔", $D = "⨥", UD = "⩲", VD = "±", GD = "±", HD = "⨦", jD = "⨧", ZD = "±", WD = "ℌ", KD = "⨕", JD = "𝕡", YD = "ℙ", XD = "£", QD = "⪷", eq = "⪻", nq = "≺", tq = "≼", rq = "⪷", oq = "≺", sq = "≼", cq = "≺", iq = "⪯", aq = "≼", lq = "≾", uq = "⪯", fq = "⪹", pq = "⪵", hq = "⋨", dq = "⪯", gq = "⪳", mq = "≾", _q = "′", bq = "″", vq = "ℙ", kq = "⪹", xq = "⪵", yq = "⋨", wq = "∏", Eq = "∏", Aq = "⌮", Cq = "⌒", Sq = "⌓", Dq = "∝", qq = "∝", Tq = "∷", Rq = "∝", Nq = "≾", Mq = "⊰", Lq = "𝒫", Fq = "𝓅", Iq = "Ψ", Oq = "ψ", Bq = " ", Pq = "𝔔", zq = "𝔮", $q = "⨌", Uq = "𝕢", Vq = "ℚ", Gq = "⁗", Hq = "𝒬", jq = "𝓆", Zq = "ℍ", Wq = "⨖", Kq = "?", Jq = "≟", Yq = '"', Xq = '"', Qq = "⇛", eT = "∽̱", nT = "Ŕ", tT = "ŕ", rT = "√", oT = "⦳", sT = "⟩", cT = "⟫", iT = "⦒", aT = "⦥", lT = "⟩", uT = "»", fT = "⥵", pT = "⇥", hT = "⤠", dT = "⤳", gT = "→", mT = "↠", _T = "⇒", bT = "⤞", vT = "↪", kT = "↬", xT = "⥅", yT = "⥴", wT = "⤖", ET = "↣", AT = "↝", CT = "⤚", ST = "⤜", DT = "∶", qT = "ℚ", TT = "⤍", RT = "⤏", NT = "⤐", MT = "❳", LT = "}", FT = "]", IT = "⦌", OT = "⦎", BT = "⦐", PT = "Ř", zT = "ř", $T = "Ŗ", UT = "ŗ", VT = "⌉", GT = "}", HT = "Р", jT = "р", ZT = "⤷", WT = "⥩", KT = "”", JT = "”", YT = "↳", XT = "ℜ", QT = "ℛ", eR = "ℜ", nR = "ℝ", tR = "ℜ", rR = "▭", oR = "®", sR = "®", cR = "∋", iR = "⇋", aR = "⥯", lR = "⥽", uR = "⌋", fR = "𝔯", pR = "ℜ", hR = "⥤", dR = "⇁", gR = "⇀", mR = "⥬", _R = "Ρ", bR = "ρ", vR = "ϱ", kR = "⟩", xR = "⇥", yR = "→", wR = "→", ER = "⇒", AR = "⇄", CR = "↣", SR = "⌉", DR = "⟧", qR = "⥝", TR = "⥕", RR = "⇂", NR = "⌋", MR = "⇁", LR = "⇀", FR = "⇄", IR = "⇌", OR = "⇉", BR = "↝", PR = "↦", zR = "⊢", $R = "⥛", UR = "⋌", VR = "⧐", GR = "⊳", HR = "⊵", jR = "⥏", ZR = "⥜", WR = "⥔", KR = "↾", JR = "⥓", YR = "⇀", XR = "˚", QR = "≓", eN = "⇄", nN = "⇌", tN = "‏", rN = "⎱", oN = "⎱", sN = "⫮", cN = "⟭", iN = "⇾", aN = "⟧", lN = "⦆", uN = "𝕣", fN = "ℝ", pN = "⨮", hN = "⨵", dN = "⥰", gN = ")", mN = "⦔", _N = "⨒", bN = "⇉", vN = "⇛", kN = "›", xN = "𝓇", yN = "ℛ", wN = "↱", EN = "↱", AN = "]", CN = "’", SN = "’", DN = "⋌", qN = "⋊", TN = "▹", RN = "⊵", NN = "▸", MN = "⧎", LN = "⧴", FN = "⥨", IN = "℞", ON = "Ś", BN = "ś", PN = "‚", zN = "⪸", $N = "Š", UN = "š", VN = "⪼", GN = "≻", HN = "≽", jN = "⪰", ZN = "⪴", WN = "Ş", KN = "ş", JN = "Ŝ", YN = "ŝ", XN = "⪺", QN = "⪶", eM = "⋩", nM = "⨓", tM = "≿", rM = "С", oM = "с", sM = "⊡", cM = "⋅", iM = "⩦", aM = "⤥", lM = "↘", uM = "⇘", fM = "↘", pM = "§", hM = ";", dM = "⤩", gM = "∖", mM = "∖", _M = "✶", bM = "𝔖", vM = "𝔰", kM = "⌢", xM = "♯", yM = "Щ", wM = "щ", EM = "Ш", AM = "ш", CM = "↓", SM = "←", DM = "∣", qM = "∥", TM = "→", RM = "↑", NM = "­", MM = "Σ", LM = "σ", FM = "ς", IM = "ς", OM = "∼", BM = "⩪", PM = "≃", zM = "≃", $M = "⪞", UM = "⪠", VM = "⪝", GM = "⪟", HM = "≆", jM = "⨤", ZM = "⥲", WM = "←", KM = "∘", JM = "∖", YM = "⨳", XM = "⧤", QM = "∣", eL = "⌣", nL = "⪪", tL = "⪬", rL = "⪬︀", oL = "Ь", sL = "ь", cL = "⌿", iL = "⧄", aL = "/", lL = "𝕊", uL = "𝕤", fL = "♠", pL = "♠", hL = "∥", dL = "⊓", gL = "⊓︀", mL = "⊔", _L = "⊔︀", bL = "√", vL = "⊏", kL = "⊑", xL = "⊏", yL = "⊑", wL = "⊐", EL = "⊒", AL = "⊐", CL = "⊒", SL = "□", DL = "□", qL = "⊓", TL = "⊏", RL = "⊑", NL = "⊐", ML = "⊒", LL = "⊔", FL = "▪", IL = "□", OL = "▪", BL = "→", PL = "𝒮", zL = "𝓈", $L = "∖", UL = "⌣", VL = "⋆", GL = "⋆", HL = "☆", jL = "★", ZL = "ϵ", WL = "ϕ", KL = "¯", JL = "⊂", YL = "⋐", XL = "⪽", QL = "⫅", e2 = "⊆", n2 = "⫃", t2 = "⫁", r2 = "⫋", o2 = "⊊", s2 = "⪿", c2 = "⥹", i2 = "⊂", a2 = "⋐", l2 = "⊆", u2 = "⫅", f2 = "⊆", p2 = "⊊", h2 = "⫋", d2 = "⫇", g2 = "⫕", m2 = "⫓", _2 = "⪸", b2 = "≻", v2 = "≽", k2 = "≻", x2 = "⪰", y2 = "≽", w2 = "≿", E2 = "⪰", A2 = "⪺", C2 = "⪶", S2 = "⋩", D2 = "≿", q2 = "∋", T2 = "∑", R2 = "∑", N2 = "♪", M2 = "¹", L2 = "²", F2 = "³", I2 = "⊃", O2 = "⋑", B2 = "⪾", P2 = "⫘", z2 = "⫆", $2 = "⊇", U2 = "⫄", V2 = "⊃", G2 = "⊇", H2 = "⟉", j2 = "⫗", Z2 = "⥻", W2 = "⫂", K2 = "⫌", J2 = "⊋", Y2 = "⫀", X2 = "⊃", Q2 = "⋑", eF = "⊇", nF = "⫆", tF = "⊋", rF = "⫌", oF = "⫈", sF = "⫔", cF = "⫖", iF = "⤦", aF = "↙", lF = "⇙", uF = "↙", fF = "⤪", pF = "ß", hF = "	", dF = "⌖", gF = "Τ", mF = "τ", _F = "⎴", bF = "Ť", vF = "ť", kF = "Ţ", xF = "ţ", yF = "Т", wF = "т", EF = "⃛", AF = "⌕", CF = "𝔗", SF = "𝔱", DF = "∴", qF = "∴", TF = "∴", RF = "Θ", NF = "θ", MF = "ϑ", LF = "ϑ", FF = "≈", IF = "∼", OF = "  ", BF = " ", PF = " ", zF = "≈", $F = "∼", UF = "Þ", VF = "þ", GF = "˜", HF = "∼", jF = "≃", ZF = "≅", WF = "≈", KF = "⨱", JF = "⊠", YF = "×", XF = "⨰", QF = "∭", eI = "⤨", nI = "⌶", tI = "⫱", rI = "⊤", oI = "𝕋", sI = "𝕥", cI = "⫚", iI = "⤩", aI = "‴", lI = "™", uI = "™", fI = "▵", pI = "▿", hI = "◃", dI = "⊴", gI = "≜", mI = "▹", _I = "⊵", bI = "◬", vI = "≜", kI = "⨺", xI = "⃛", yI = "⨹", wI = "⧍", EI = "⨻", AI = "⏢", CI = "𝒯", SI = "𝓉", DI = "Ц", qI = "ц", TI = "Ћ", RI = "ћ", NI = "Ŧ", MI = "ŧ", LI = "≬", FI = "↞", II = "↠", OI = "Ú", BI = "ú", PI = "↑", zI = "↟", $I = "⇑", UI = "⥉", VI = "Ў", GI = "ў", HI = "Ŭ", jI = "ŭ", ZI = "Û", WI = "û", KI = "У", JI = "у", YI = "⇅", XI = "Ű", QI = "ű", eO = "⥮", nO = "⥾", tO = "𝔘", rO = "𝔲", oO = "Ù", sO = "ù", cO = "⥣", iO = "↿", aO = "↾", lO = "▀", uO = "⌜", fO = "⌜", pO = "⌏", hO = "◸", dO = "Ū", gO = "ū", mO = "¨", _O = "_", bO = "⏟", vO = "⎵", kO = "⏝", xO = "⋃", yO = "⊎", wO = "Ų", EO = "ų", AO = "𝕌", CO = "𝕦", SO = "⤒", DO = "↑", qO = "↑", TO = "⇑", RO = "⇅", NO = "↕", MO = "↕", LO = "⇕", FO = "⥮", IO = "↿", OO = "↾", BO = "⊎", PO = "↖", zO = "↗", $O = "υ", UO = "ϒ", VO = "ϒ", GO = "Υ", HO = "υ", jO = "↥", ZO = "⊥", WO = "⇈", KO = "⌝", JO = "⌝", YO = "⌎", XO = "Ů", QO = "ů", eB = "◹", nB = "𝒰", tB = "𝓊", rB = "⋰", oB = "Ũ", sB = "ũ", cB = "▵", iB = "▴", aB = "⇈", lB = "Ü", uB = "ü", fB = "⦧", pB = "⦜", hB = "ϵ", dB = "ϰ", gB = "∅", mB = "ϕ", _B = "ϖ", bB = "∝", vB = "↕", kB = "⇕", xB = "ϱ", yB = "ς", wB = "⊊︀", EB = "⫋︀", AB = "⊋︀", CB = "⫌︀", SB = "ϑ", DB = "⊲", qB = "⊳", TB = "⫨", RB = "⫫", NB = "⫩", MB = "В", LB = "в", FB = "⊢", IB = "⊨", OB = "⊩", BB = "⊫", PB = "⫦", zB = "⊻", $B = "∨", UB = "⋁", VB = "≚", GB = "⋮", HB = "|", jB = "‖", ZB = "|", WB = "‖", KB = "∣", JB = "|", YB = "❘", XB = "≀", QB = " ", eP = "𝔙", nP = "𝔳", tP = "⊲", rP = "⊂⃒", oP = "⊃⃒", sP = "𝕍", cP = "𝕧", iP = "∝", aP = "⊳", lP = "𝒱", uP = "𝓋", fP = "⫋︀", pP = "⊊︀", hP = "⫌︀", dP = "⊋︀", gP = "⊪", mP = "⦚", _P = "Ŵ", bP = "ŵ", vP = "⩟", kP = "∧", xP = "⋀", yP = "≙", wP = "℘", EP = "𝔚", AP = "𝔴", CP = "𝕎", SP = "𝕨", DP = "℘", qP = "≀", TP = "≀", RP = "𝒲", NP = "𝓌", MP = "⋂", LP = "◯", FP = "⋃", IP = "▽", OP = "𝔛", BP = "𝔵", PP = "⟷", zP = "⟺", $P = "Ξ", UP = "ξ", VP = "⟵", GP = "⟸", HP = "⟼", jP = "⋻", ZP = "⨀", WP = "𝕏", KP = "𝕩", JP = "⨁", YP = "⨂", XP = "⟶", QP = "⟹", ez = "𝒳", nz = "𝓍", tz = "⨆", rz = "⨄", oz = "△", sz = "⋁", cz = "⋀", iz = "Ý", az = "ý", lz = "Я", uz = "я", fz = "Ŷ", pz = "ŷ", hz = "Ы", dz = "ы", gz = "¥", mz = "𝔜", _z = "𝔶", bz = "Ї", vz = "ї", kz = "𝕐", xz = "𝕪", yz = "𝒴", wz = "𝓎", Ez = "Ю", Az = "ю", Cz = "ÿ", Sz = "Ÿ", Dz = "Ź", qz = "ź", Tz = "Ž", Rz = "ž", Nz = "З", Mz = "з", Lz = "Ż", Fz = "ż", Iz = "ℨ", Oz = "​", Bz = "Ζ", Pz = "ζ", zz = "𝔷", $z = "ℨ", Uz = "Ж", Vz = "ж", Gz = "⇝", Hz = "𝕫", jz = "ℤ", Zz = "𝒵", Wz = "𝓏", Kz = "‍", Jz = "‌", Yz = {
  Aacute: Mo,
  aacute: Lo,
  Abreve: Fo,
  abreve: Io,
  ac: Oo,
  acd: Bo,
  acE: Po,
  Acirc: zo,
  acirc: $o,
  acute: Uo,
  Acy: Vo,
  acy: Go,
  AElig: Ho,
  aelig: jo,
  af: Zo,
  Afr: Wo,
  afr: Ko,
  Agrave: Jo,
  agrave: Yo,
  alefsym: Xo,
  aleph: Qo,
  Alpha: es,
  alpha: ns,
  Amacr: ts,
  amacr: rs,
  amalg: os,
  amp: ss,
  AMP: cs,
  andand: is,
  And: as,
  and: ls,
  andd: us,
  andslope: fs,
  andv: ps,
  ang: hs,
  ange: ds,
  angle: gs,
  angmsdaa: ms,
  angmsdab: _s,
  angmsdac: bs,
  angmsdad: vs,
  angmsdae: ks,
  angmsdaf: xs,
  angmsdag: ys,
  angmsdah: ws,
  angmsd: Es,
  angrt: As,
  angrtvb: Cs,
  angrtvbd: Ss,
  angsph: Ds,
  angst: qs,
  angzarr: Ts,
  Aogon: Rs,
  aogon: Ns,
  Aopf: Ms,
  aopf: Ls,
  apacir: Fs,
  ap: Is,
  apE: Os,
  ape: Bs,
  apid: Ps,
  apos: zs,
  ApplyFunction: $s,
  approx: Us,
  approxeq: Vs,
  Aring: Gs,
  aring: Hs,
  Ascr: js,
  ascr: Zs,
  Assign: Ws,
  ast: Ks,
  asymp: Js,
  asympeq: Ys,
  Atilde: Xs,
  atilde: Qs,
  Auml: ec,
  auml: nc,
  awconint: tc,
  awint: rc,
  backcong: oc,
  backepsilon: sc,
  backprime: cc,
  backsim: ic,
  backsimeq: ac,
  Backslash: lc,
  Barv: uc,
  barvee: fc,
  barwed: pc,
  Barwed: hc,
  barwedge: dc,
  bbrk: gc,
  bbrktbrk: mc,
  bcong: _c,
  Bcy: bc,
  bcy: vc,
  bdquo: kc,
  becaus: xc,
  because: yc,
  Because: wc,
  bemptyv: Ec,
  bepsi: Ac,
  bernou: Cc,
  Bernoullis: Sc,
  Beta: Dc,
  beta: qc,
  beth: Tc,
  between: Rc,
  Bfr: Nc,
  bfr: Mc,
  bigcap: Lc,
  bigcirc: Fc,
  bigcup: Ic,
  bigodot: Oc,
  bigoplus: Bc,
  bigotimes: Pc,
  bigsqcup: zc,
  bigstar: $c,
  bigtriangledown: Uc,
  bigtriangleup: Vc,
  biguplus: Gc,
  bigvee: Hc,
  bigwedge: jc,
  bkarow: Zc,
  blacklozenge: Wc,
  blacksquare: Kc,
  blacktriangle: Jc,
  blacktriangledown: Yc,
  blacktriangleleft: Xc,
  blacktriangleright: Qc,
  blank: ei,
  blk12: ni,
  blk14: ti,
  blk34: ri,
  block: oi,
  bne: si,
  bnequiv: ci,
  bNot: ii,
  bnot: ai,
  Bopf: li,
  bopf: ui,
  bot: fi,
  bottom: pi,
  bowtie: hi,
  boxbox: di,
  boxdl: gi,
  boxdL: mi,
  boxDl: _i,
  boxDL: bi,
  boxdr: vi,
  boxdR: ki,
  boxDr: xi,
  boxDR: yi,
  boxh: wi,
  boxH: Ei,
  boxhd: Ai,
  boxHd: Ci,
  boxhD: Si,
  boxHD: Di,
  boxhu: qi,
  boxHu: Ti,
  boxhU: Ri,
  boxHU: Ni,
  boxminus: Mi,
  boxplus: Li,
  boxtimes: Fi,
  boxul: Ii,
  boxuL: Oi,
  boxUl: Bi,
  boxUL: Pi,
  boxur: zi,
  boxuR: $i,
  boxUr: Ui,
  boxUR: Vi,
  boxv: Gi,
  boxV: Hi,
  boxvh: ji,
  boxvH: Zi,
  boxVh: Wi,
  boxVH: Ki,
  boxvl: Ji,
  boxvL: Yi,
  boxVl: Xi,
  boxVL: Qi,
  boxvr: ea,
  boxvR: na,
  boxVr: ta,
  boxVR: ra,
  bprime: oa,
  breve: sa,
  Breve: ca,
  brvbar: ia,
  bscr: aa,
  Bscr: la,
  bsemi: ua,
  bsim: fa,
  bsime: pa,
  bsolb: ha,
  bsol: da,
  bsolhsub: ga,
  bull: ma,
  bullet: _a,
  bump: ba,
  bumpE: va,
  bumpe: ka,
  Bumpeq: xa,
  bumpeq: ya,
  Cacute: wa,
  cacute: Ea,
  capand: Aa,
  capbrcup: Ca,
  capcap: Sa,
  cap: Da,
  Cap: qa,
  capcup: Ta,
  capdot: Ra,
  CapitalDifferentialD: Na,
  caps: Ma,
  caret: La,
  caron: Fa,
  Cayleys: Ia,
  ccaps: Oa,
  Ccaron: Ba,
  ccaron: Pa,
  Ccedil: za,
  ccedil: $a,
  Ccirc: Ua,
  ccirc: Va,
  Cconint: Ga,
  ccups: Ha,
  ccupssm: ja,
  Cdot: Za,
  cdot: Wa,
  cedil: Ka,
  Cedilla: Ja,
  cemptyv: Ya,
  cent: Xa,
  centerdot: Qa,
  CenterDot: el,
  cfr: nl,
  Cfr: tl,
  CHcy: rl,
  chcy: ol,
  check: sl,
  checkmark: cl,
  Chi: il,
  chi: al,
  circ: ll,
  circeq: ul,
  circlearrowleft: fl,
  circlearrowright: pl,
  circledast: hl,
  circledcirc: dl,
  circleddash: gl,
  CircleDot: ml,
  circledR: _l,
  circledS: bl,
  CircleMinus: vl,
  CirclePlus: kl,
  CircleTimes: xl,
  cir: yl,
  cirE: wl,
  cire: El,
  cirfnint: Al,
  cirmid: Cl,
  cirscir: Sl,
  ClockwiseContourIntegral: Dl,
  CloseCurlyDoubleQuote: ql,
  CloseCurlyQuote: Tl,
  clubs: Rl,
  clubsuit: Nl,
  colon: Ml,
  Colon: Ll,
  Colone: Fl,
  colone: Il,
  coloneq: Ol,
  comma: Bl,
  commat: Pl,
  comp: zl,
  compfn: $l,
  complement: Ul,
  complexes: Vl,
  cong: Gl,
  congdot: Hl,
  Congruent: jl,
  conint: Zl,
  Conint: Wl,
  ContourIntegral: Kl,
  copf: Jl,
  Copf: Yl,
  coprod: Xl,
  Coproduct: Ql,
  copy: eu,
  COPY: nu,
  copysr: tu,
  CounterClockwiseContourIntegral: ru,
  crarr: ou,
  cross: su,
  Cross: cu,
  Cscr: iu,
  cscr: au,
  csub: lu,
  csube: uu,
  csup: fu,
  csupe: pu,
  ctdot: hu,
  cudarrl: du,
  cudarrr: gu,
  cuepr: mu,
  cuesc: _u,
  cularr: bu,
  cularrp: vu,
  cupbrcap: ku,
  cupcap: xu,
  CupCap: yu,
  cup: wu,
  Cup: Eu,
  cupcup: Au,
  cupdot: Cu,
  cupor: Su,
  cups: Du,
  curarr: qu,
  curarrm: Tu,
  curlyeqprec: Ru,
  curlyeqsucc: Nu,
  curlyvee: Mu,
  curlywedge: Lu,
  curren: Fu,
  curvearrowleft: Iu,
  curvearrowright: Ou,
  cuvee: Bu,
  cuwed: Pu,
  cwconint: zu,
  cwint: $u,
  cylcty: Uu,
  dagger: Vu,
  Dagger: Gu,
  daleth: Hu,
  darr: ju,
  Darr: Zu,
  dArr: Wu,
  dash: Ku,
  Dashv: Ju,
  dashv: Yu,
  dbkarow: Xu,
  dblac: Qu,
  Dcaron: ef,
  dcaron: nf,
  Dcy: tf,
  dcy: rf,
  ddagger: of,
  ddarr: sf,
  DD: cf,
  dd: af,
  DDotrahd: lf,
  ddotseq: uf,
  deg: ff,
  Del: pf,
  Delta: hf,
  delta: df,
  demptyv: gf,
  dfisht: mf,
  Dfr: _f,
  dfr: bf,
  dHar: vf,
  dharl: kf,
  dharr: xf,
  DiacriticalAcute: yf,
  DiacriticalDot: wf,
  DiacriticalDoubleAcute: Ef,
  DiacriticalGrave: Af,
  DiacriticalTilde: Cf,
  diam: Sf,
  diamond: Df,
  Diamond: qf,
  diamondsuit: Tf,
  diams: Rf,
  die: Nf,
  DifferentialD: Mf,
  digamma: Lf,
  disin: Ff,
  div: If,
  divide: Of,
  divideontimes: Bf,
  divonx: Pf,
  DJcy: zf,
  djcy: $f,
  dlcorn: Uf,
  dlcrop: Vf,
  dollar: Gf,
  Dopf: Hf,
  dopf: jf,
  Dot: Zf,
  dot: Wf,
  DotDot: Kf,
  doteq: Jf,
  doteqdot: Yf,
  DotEqual: Xf,
  dotminus: Qf,
  dotplus: ep,
  dotsquare: np,
  doublebarwedge: tp,
  DoubleContourIntegral: rp,
  DoubleDot: op,
  DoubleDownArrow: sp,
  DoubleLeftArrow: cp,
  DoubleLeftRightArrow: ip,
  DoubleLeftTee: ap,
  DoubleLongLeftArrow: lp,
  DoubleLongLeftRightArrow: up,
  DoubleLongRightArrow: fp,
  DoubleRightArrow: pp,
  DoubleRightTee: hp,
  DoubleUpArrow: dp,
  DoubleUpDownArrow: gp,
  DoubleVerticalBar: mp,
  DownArrowBar: _p,
  downarrow: bp,
  DownArrow: vp,
  Downarrow: kp,
  DownArrowUpArrow: xp,
  DownBreve: yp,
  downdownarrows: wp,
  downharpoonleft: Ep,
  downharpoonright: Ap,
  DownLeftRightVector: Cp,
  DownLeftTeeVector: Sp,
  DownLeftVectorBar: Dp,
  DownLeftVector: qp,
  DownRightTeeVector: Tp,
  DownRightVectorBar: Rp,
  DownRightVector: Np,
  DownTeeArrow: Mp,
  DownTee: Lp,
  drbkarow: Fp,
  drcorn: Ip,
  drcrop: Op,
  Dscr: Bp,
  dscr: Pp,
  DScy: zp,
  dscy: $p,
  dsol: Up,
  Dstrok: Vp,
  dstrok: Gp,
  dtdot: Hp,
  dtri: jp,
  dtrif: Zp,
  duarr: Wp,
  duhar: Kp,
  dwangle: Jp,
  DZcy: Yp,
  dzcy: Xp,
  dzigrarr: Qp,
  Eacute: eh,
  eacute: nh,
  easter: th,
  Ecaron: rh,
  ecaron: oh,
  Ecirc: sh,
  ecirc: ch,
  ecir: ih,
  ecolon: ah,
  Ecy: lh,
  ecy: uh,
  eDDot: fh,
  Edot: ph,
  edot: hh,
  eDot: dh,
  ee: gh,
  efDot: mh,
  Efr: _h,
  efr: bh,
  eg: vh,
  Egrave: kh,
  egrave: xh,
  egs: yh,
  egsdot: wh,
  el: Eh,
  Element: Ah,
  elinters: Ch,
  ell: Sh,
  els: Dh,
  elsdot: qh,
  Emacr: Th,
  emacr: Rh,
  empty: Nh,
  emptyset: Mh,
  EmptySmallSquare: Lh,
  emptyv: Fh,
  EmptyVerySmallSquare: Ih,
  emsp13: Oh,
  emsp14: Bh,
  emsp: Ph,
  ENG: zh,
  eng: $h,
  ensp: Uh,
  Eogon: Vh,
  eogon: Gh,
  Eopf: Hh,
  eopf: jh,
  epar: Zh,
  eparsl: Wh,
  eplus: Kh,
  epsi: Jh,
  Epsilon: Yh,
  epsilon: Xh,
  epsiv: Qh,
  eqcirc: ed,
  eqcolon: nd,
  eqsim: td,
  eqslantgtr: rd,
  eqslantless: od,
  Equal: sd,
  equals: cd,
  EqualTilde: id,
  equest: ad,
  Equilibrium: ld,
  equiv: ud,
  equivDD: fd,
  eqvparsl: pd,
  erarr: hd,
  erDot: dd,
  escr: gd,
  Escr: md,
  esdot: _d,
  Esim: bd,
  esim: vd,
  Eta: kd,
  eta: xd,
  ETH: yd,
  eth: wd,
  Euml: Ed,
  euml: Ad,
  euro: Cd,
  excl: Sd,
  exist: Dd,
  Exists: qd,
  expectation: Td,
  exponentiale: Rd,
  ExponentialE: Nd,
  fallingdotseq: Md,
  Fcy: Ld,
  fcy: Fd,
  female: Id,
  ffilig: Od,
  fflig: Bd,
  ffllig: Pd,
  Ffr: zd,
  ffr: $d,
  filig: Ud,
  FilledSmallSquare: Vd,
  FilledVerySmallSquare: Gd,
  fjlig: Hd,
  flat: jd,
  fllig: Zd,
  fltns: Wd,
  fnof: Kd,
  Fopf: Jd,
  fopf: Yd,
  forall: Xd,
  ForAll: Qd,
  fork: eg,
  forkv: ng,
  Fouriertrf: tg,
  fpartint: rg,
  frac12: og,
  frac13: sg,
  frac14: cg,
  frac15: ig,
  frac16: ag,
  frac18: lg,
  frac23: ug,
  frac25: fg,
  frac34: pg,
  frac35: hg,
  frac38: dg,
  frac45: gg,
  frac56: mg,
  frac58: _g,
  frac78: bg,
  frasl: vg,
  frown: kg,
  fscr: xg,
  Fscr: yg,
  gacute: wg,
  Gamma: Eg,
  gamma: Ag,
  Gammad: Cg,
  gammad: Sg,
  gap: Dg,
  Gbreve: qg,
  gbreve: Tg,
  Gcedil: Rg,
  Gcirc: Ng,
  gcirc: Mg,
  Gcy: Lg,
  gcy: Fg,
  Gdot: Ig,
  gdot: Og,
  ge: Bg,
  gE: Pg,
  gEl: zg,
  gel: $g,
  geq: Ug,
  geqq: Vg,
  geqslant: Gg,
  gescc: Hg,
  ges: jg,
  gesdot: Zg,
  gesdoto: Wg,
  gesdotol: Kg,
  gesl: Jg,
  gesles: Yg,
  Gfr: Xg,
  gfr: Qg,
  gg: em,
  Gg: nm,
  ggg: tm,
  gimel: rm,
  GJcy: om,
  gjcy: sm,
  gla: cm,
  gl: im,
  glE: am,
  glj: lm,
  gnap: um,
  gnapprox: fm,
  gne: pm,
  gnE: hm,
  gneq: dm,
  gneqq: gm,
  gnsim: mm,
  Gopf: _m,
  gopf: bm,
  grave: vm,
  GreaterEqual: km,
  GreaterEqualLess: xm,
  GreaterFullEqual: ym,
  GreaterGreater: wm,
  GreaterLess: Em,
  GreaterSlantEqual: Am,
  GreaterTilde: Cm,
  Gscr: Sm,
  gscr: Dm,
  gsim: qm,
  gsime: Tm,
  gsiml: Rm,
  gtcc: Nm,
  gtcir: Mm,
  gt: Lm,
  GT: Fm,
  Gt: Im,
  gtdot: Om,
  gtlPar: Bm,
  gtquest: Pm,
  gtrapprox: zm,
  gtrarr: $m,
  gtrdot: Um,
  gtreqless: Vm,
  gtreqqless: Gm,
  gtrless: Hm,
  gtrsim: jm,
  gvertneqq: Zm,
  gvnE: Wm,
  Hacek: Km,
  hairsp: Jm,
  half: Ym,
  hamilt: Xm,
  HARDcy: Qm,
  hardcy: e_,
  harrcir: n_,
  harr: t_,
  hArr: r_,
  harrw: o_,
  Hat: s_,
  hbar: c_,
  Hcirc: i_,
  hcirc: a_,
  hearts: l_,
  heartsuit: u_,
  hellip: f_,
  hercon: p_,
  hfr: h_,
  Hfr: d_,
  HilbertSpace: g_,
  hksearow: m_,
  hkswarow: __,
  hoarr: b_,
  homtht: v_,
  hookleftarrow: k_,
  hookrightarrow: x_,
  hopf: y_,
  Hopf: w_,
  horbar: E_,
  HorizontalLine: A_,
  hscr: C_,
  Hscr: S_,
  hslash: D_,
  Hstrok: q_,
  hstrok: T_,
  HumpDownHump: R_,
  HumpEqual: N_,
  hybull: M_,
  hyphen: L_,
  Iacute: F_,
  iacute: I_,
  ic: O_,
  Icirc: B_,
  icirc: P_,
  Icy: z_,
  icy: $_,
  Idot: U_,
  IEcy: V_,
  iecy: G_,
  iexcl: H_,
  iff: j_,
  ifr: Z_,
  Ifr: W_,
  Igrave: K_,
  igrave: J_,
  ii: Y_,
  iiiint: X_,
  iiint: Q_,
  iinfin: eb,
  iiota: nb,
  IJlig: tb,
  ijlig: rb,
  Imacr: ob,
  imacr: sb,
  image: cb,
  ImaginaryI: ib,
  imagline: ab,
  imagpart: lb,
  imath: ub,
  Im: fb,
  imof: pb,
  imped: hb,
  Implies: db,
  incare: gb,
  in: "∈",
  infin: mb,
  infintie: _b,
  inodot: bb,
  intcal: vb,
  int: kb,
  Int: xb,
  integers: yb,
  Integral: wb,
  intercal: Eb,
  Intersection: Ab,
  intlarhk: Cb,
  intprod: Sb,
  InvisibleComma: Db,
  InvisibleTimes: qb,
  IOcy: Tb,
  iocy: Rb,
  Iogon: Nb,
  iogon: Mb,
  Iopf: Lb,
  iopf: Fb,
  Iota: Ib,
  iota: Ob,
  iprod: Bb,
  iquest: Pb,
  iscr: zb,
  Iscr: $b,
  isin: Ub,
  isindot: Vb,
  isinE: Gb,
  isins: Hb,
  isinsv: jb,
  isinv: Zb,
  it: Wb,
  Itilde: Kb,
  itilde: Jb,
  Iukcy: Yb,
  iukcy: Xb,
  Iuml: Qb,
  iuml: e0,
  Jcirc: n0,
  jcirc: t0,
  Jcy: r0,
  jcy: o0,
  Jfr: s0,
  jfr: c0,
  jmath: i0,
  Jopf: a0,
  jopf: l0,
  Jscr: u0,
  jscr: f0,
  Jsercy: p0,
  jsercy: h0,
  Jukcy: d0,
  jukcy: g0,
  Kappa: m0,
  kappa: _0,
  kappav: b0,
  Kcedil: v0,
  kcedil: k0,
  Kcy: x0,
  kcy: y0,
  Kfr: w0,
  kfr: E0,
  kgreen: A0,
  KHcy: C0,
  khcy: S0,
  KJcy: D0,
  kjcy: q0,
  Kopf: T0,
  kopf: R0,
  Kscr: N0,
  kscr: M0,
  lAarr: L0,
  Lacute: F0,
  lacute: I0,
  laemptyv: O0,
  lagran: B0,
  Lambda: P0,
  lambda: z0,
  lang: $0,
  Lang: U0,
  langd: V0,
  langle: G0,
  lap: H0,
  Laplacetrf: j0,
  laquo: Z0,
  larrb: W0,
  larrbfs: K0,
  larr: J0,
  Larr: Y0,
  lArr: X0,
  larrfs: Q0,
  larrhk: ev,
  larrlp: nv,
  larrpl: tv,
  larrsim: rv,
  larrtl: ov,
  latail: sv,
  lAtail: cv,
  lat: iv,
  late: av,
  lates: lv,
  lbarr: uv,
  lBarr: fv,
  lbbrk: pv,
  lbrace: hv,
  lbrack: dv,
  lbrke: gv,
  lbrksld: mv,
  lbrkslu: _v,
  Lcaron: bv,
  lcaron: vv,
  Lcedil: kv,
  lcedil: xv,
  lceil: yv,
  lcub: wv,
  Lcy: Ev,
  lcy: Av,
  ldca: Cv,
  ldquo: Sv,
  ldquor: Dv,
  ldrdhar: qv,
  ldrushar: Tv,
  ldsh: Rv,
  le: Nv,
  lE: Mv,
  LeftAngleBracket: Lv,
  LeftArrowBar: Fv,
  leftarrow: Iv,
  LeftArrow: Ov,
  Leftarrow: Bv,
  LeftArrowRightArrow: Pv,
  leftarrowtail: zv,
  LeftCeiling: $v,
  LeftDoubleBracket: Uv,
  LeftDownTeeVector: Vv,
  LeftDownVectorBar: Gv,
  LeftDownVector: Hv,
  LeftFloor: jv,
  leftharpoondown: Zv,
  leftharpoonup: Wv,
  leftleftarrows: Kv,
  leftrightarrow: Jv,
  LeftRightArrow: Yv,
  Leftrightarrow: Xv,
  leftrightarrows: Qv,
  leftrightharpoons: ek,
  leftrightsquigarrow: nk,
  LeftRightVector: tk,
  LeftTeeArrow: rk,
  LeftTee: ok,
  LeftTeeVector: sk,
  leftthreetimes: ck,
  LeftTriangleBar: ik,
  LeftTriangle: ak,
  LeftTriangleEqual: lk,
  LeftUpDownVector: uk,
  LeftUpTeeVector: fk,
  LeftUpVectorBar: pk,
  LeftUpVector: hk,
  LeftVectorBar: dk,
  LeftVector: gk,
  lEg: mk,
  leg: _k,
  leq: bk,
  leqq: vk,
  leqslant: kk,
  lescc: xk,
  les: yk,
  lesdot: wk,
  lesdoto: Ek,
  lesdotor: Ak,
  lesg: Ck,
  lesges: Sk,
  lessapprox: Dk,
  lessdot: qk,
  lesseqgtr: Tk,
  lesseqqgtr: Rk,
  LessEqualGreater: Nk,
  LessFullEqual: Mk,
  LessGreater: Lk,
  lessgtr: Fk,
  LessLess: Ik,
  lesssim: Ok,
  LessSlantEqual: Bk,
  LessTilde: Pk,
  lfisht: zk,
  lfloor: $k,
  Lfr: Uk,
  lfr: Vk,
  lg: Gk,
  lgE: Hk,
  lHar: jk,
  lhard: Zk,
  lharu: Wk,
  lharul: Kk,
  lhblk: Jk,
  LJcy: Yk,
  ljcy: Xk,
  llarr: Qk,
  ll: ex,
  Ll: nx,
  llcorner: tx,
  Lleftarrow: rx,
  llhard: ox,
  lltri: sx,
  Lmidot: cx,
  lmidot: ix,
  lmoustache: ax,
  lmoust: lx,
  lnap: ux,
  lnapprox: fx,
  lne: px,
  lnE: hx,
  lneq: dx,
  lneqq: gx,
  lnsim: mx,
  loang: _x,
  loarr: bx,
  lobrk: vx,
  longleftarrow: kx,
  LongLeftArrow: xx,
  Longleftarrow: yx,
  longleftrightarrow: wx,
  LongLeftRightArrow: Ex,
  Longleftrightarrow: Ax,
  longmapsto: Cx,
  longrightarrow: Sx,
  LongRightArrow: Dx,
  Longrightarrow: qx,
  looparrowleft: Tx,
  looparrowright: Rx,
  lopar: Nx,
  Lopf: Mx,
  lopf: Lx,
  loplus: Fx,
  lotimes: Ix,
  lowast: Ox,
  lowbar: Bx,
  LowerLeftArrow: Px,
  LowerRightArrow: zx,
  loz: $x,
  lozenge: Ux,
  lozf: Vx,
  lpar: Gx,
  lparlt: Hx,
  lrarr: jx,
  lrcorner: Zx,
  lrhar: Wx,
  lrhard: Kx,
  lrm: Jx,
  lrtri: Yx,
  lsaquo: Xx,
  lscr: Qx,
  Lscr: ey,
  lsh: ny,
  Lsh: ty,
  lsim: ry,
  lsime: oy,
  lsimg: sy,
  lsqb: cy,
  lsquo: iy,
  lsquor: ay,
  Lstrok: ly,
  lstrok: uy,
  ltcc: fy,
  ltcir: py,
  lt: hy,
  LT: dy,
  Lt: gy,
  ltdot: my,
  lthree: _y,
  ltimes: by,
  ltlarr: vy,
  ltquest: ky,
  ltri: xy,
  ltrie: yy,
  ltrif: wy,
  ltrPar: Ey,
  lurdshar: Ay,
  luruhar: Cy,
  lvertneqq: Sy,
  lvnE: Dy,
  macr: qy,
  male: Ty,
  malt: Ry,
  maltese: Ny,
  Map: "⤅",
  map: My,
  mapsto: Ly,
  mapstodown: Fy,
  mapstoleft: Iy,
  mapstoup: Oy,
  marker: By,
  mcomma: Py,
  Mcy: zy,
  mcy: $y,
  mdash: Uy,
  mDDot: Vy,
  measuredangle: Gy,
  MediumSpace: Hy,
  Mellintrf: jy,
  Mfr: Zy,
  mfr: Wy,
  mho: Ky,
  micro: Jy,
  midast: Yy,
  midcir: Xy,
  mid: Qy,
  middot: ew,
  minusb: nw,
  minus: tw,
  minusd: rw,
  minusdu: ow,
  MinusPlus: sw,
  mlcp: cw,
  mldr: iw,
  mnplus: aw,
  models: lw,
  Mopf: uw,
  mopf: fw,
  mp: pw,
  mscr: hw,
  Mscr: dw,
  mstpos: gw,
  Mu: mw,
  mu: _w,
  multimap: bw,
  mumap: vw,
  nabla: kw,
  Nacute: xw,
  nacute: yw,
  nang: ww,
  nap: Ew,
  napE: Aw,
  napid: Cw,
  napos: Sw,
  napprox: Dw,
  natural: qw,
  naturals: Tw,
  natur: Rw,
  nbsp: Nw,
  nbump: Mw,
  nbumpe: Lw,
  ncap: Fw,
  Ncaron: Iw,
  ncaron: Ow,
  Ncedil: Bw,
  ncedil: Pw,
  ncong: zw,
  ncongdot: $w,
  ncup: Uw,
  Ncy: Vw,
  ncy: Gw,
  ndash: Hw,
  nearhk: jw,
  nearr: Zw,
  neArr: Ww,
  nearrow: Kw,
  ne: Jw,
  nedot: Yw,
  NegativeMediumSpace: Xw,
  NegativeThickSpace: Qw,
  NegativeThinSpace: eE,
  NegativeVeryThinSpace: nE,
  nequiv: tE,
  nesear: rE,
  nesim: oE,
  NestedGreaterGreater: sE,
  NestedLessLess: cE,
  NewLine: iE,
  nexist: aE,
  nexists: lE,
  Nfr: uE,
  nfr: fE,
  ngE: pE,
  nge: hE,
  ngeq: dE,
  ngeqq: gE,
  ngeqslant: mE,
  nges: _E,
  nGg: bE,
  ngsim: vE,
  nGt: kE,
  ngt: xE,
  ngtr: yE,
  nGtv: wE,
  nharr: EE,
  nhArr: AE,
  nhpar: CE,
  ni: SE,
  nis: DE,
  nisd: qE,
  niv: TE,
  NJcy: RE,
  njcy: NE,
  nlarr: ME,
  nlArr: LE,
  nldr: FE,
  nlE: IE,
  nle: OE,
  nleftarrow: BE,
  nLeftarrow: PE,
  nleftrightarrow: zE,
  nLeftrightarrow: $E,
  nleq: UE,
  nleqq: VE,
  nleqslant: GE,
  nles: HE,
  nless: jE,
  nLl: ZE,
  nlsim: WE,
  nLt: KE,
  nlt: JE,
  nltri: YE,
  nltrie: XE,
  nLtv: QE,
  nmid: eA,
  NoBreak: nA,
  NonBreakingSpace: tA,
  nopf: rA,
  Nopf: oA,
  Not: sA,
  not: cA,
  NotCongruent: iA,
  NotCupCap: aA,
  NotDoubleVerticalBar: lA,
  NotElement: uA,
  NotEqual: fA,
  NotEqualTilde: pA,
  NotExists: hA,
  NotGreater: dA,
  NotGreaterEqual: gA,
  NotGreaterFullEqual: mA,
  NotGreaterGreater: _A,
  NotGreaterLess: bA,
  NotGreaterSlantEqual: vA,
  NotGreaterTilde: kA,
  NotHumpDownHump: xA,
  NotHumpEqual: yA,
  notin: wA,
  notindot: EA,
  notinE: AA,
  notinva: CA,
  notinvb: SA,
  notinvc: DA,
  NotLeftTriangleBar: qA,
  NotLeftTriangle: TA,
  NotLeftTriangleEqual: RA,
  NotLess: NA,
  NotLessEqual: MA,
  NotLessGreater: LA,
  NotLessLess: FA,
  NotLessSlantEqual: IA,
  NotLessTilde: OA,
  NotNestedGreaterGreater: BA,
  NotNestedLessLess: PA,
  notni: zA,
  notniva: $A,
  notnivb: UA,
  notnivc: VA,
  NotPrecedes: GA,
  NotPrecedesEqual: HA,
  NotPrecedesSlantEqual: jA,
  NotReverseElement: ZA,
  NotRightTriangleBar: WA,
  NotRightTriangle: KA,
  NotRightTriangleEqual: JA,
  NotSquareSubset: YA,
  NotSquareSubsetEqual: XA,
  NotSquareSuperset: QA,
  NotSquareSupersetEqual: eC,
  NotSubset: nC,
  NotSubsetEqual: tC,
  NotSucceeds: rC,
  NotSucceedsEqual: oC,
  NotSucceedsSlantEqual: sC,
  NotSucceedsTilde: cC,
  NotSuperset: iC,
  NotSupersetEqual: aC,
  NotTilde: lC,
  NotTildeEqual: uC,
  NotTildeFullEqual: fC,
  NotTildeTilde: pC,
  NotVerticalBar: hC,
  nparallel: dC,
  npar: gC,
  nparsl: mC,
  npart: _C,
  npolint: bC,
  npr: vC,
  nprcue: kC,
  nprec: xC,
  npreceq: yC,
  npre: wC,
  nrarrc: EC,
  nrarr: AC,
  nrArr: CC,
  nrarrw: SC,
  nrightarrow: DC,
  nRightarrow: qC,
  nrtri: TC,
  nrtrie: RC,
  nsc: NC,
  nsccue: MC,
  nsce: LC,
  Nscr: FC,
  nscr: IC,
  nshortmid: OC,
  nshortparallel: BC,
  nsim: PC,
  nsime: zC,
  nsimeq: $C,
  nsmid: UC,
  nspar: VC,
  nsqsube: GC,
  nsqsupe: HC,
  nsub: jC,
  nsubE: ZC,
  nsube: WC,
  nsubset: KC,
  nsubseteq: JC,
  nsubseteqq: YC,
  nsucc: XC,
  nsucceq: QC,
  nsup: e1,
  nsupE: n1,
  nsupe: t1,
  nsupset: r1,
  nsupseteq: o1,
  nsupseteqq: s1,
  ntgl: c1,
  Ntilde: i1,
  ntilde: a1,
  ntlg: l1,
  ntriangleleft: u1,
  ntrianglelefteq: f1,
  ntriangleright: p1,
  ntrianglerighteq: h1,
  Nu: d1,
  nu: g1,
  num: m1,
  numero: _1,
  numsp: b1,
  nvap: v1,
  nvdash: k1,
  nvDash: x1,
  nVdash: y1,
  nVDash: w1,
  nvge: E1,
  nvgt: A1,
  nvHarr: C1,
  nvinfin: S1,
  nvlArr: D1,
  nvle: q1,
  nvlt: T1,
  nvltrie: R1,
  nvrArr: N1,
  nvrtrie: M1,
  nvsim: L1,
  nwarhk: F1,
  nwarr: I1,
  nwArr: O1,
  nwarrow: B1,
  nwnear: P1,
  Oacute: z1,
  oacute: $1,
  oast: U1,
  Ocirc: V1,
  ocirc: G1,
  ocir: H1,
  Ocy: j1,
  ocy: Z1,
  odash: W1,
  Odblac: K1,
  odblac: J1,
  odiv: Y1,
  odot: X1,
  odsold: Q1,
  OElig: eS,
  oelig: nS,
  ofcir: tS,
  Ofr: rS,
  ofr: oS,
  ogon: sS,
  Ograve: cS,
  ograve: iS,
  ogt: aS,
  ohbar: lS,
  ohm: uS,
  oint: fS,
  olarr: pS,
  olcir: hS,
  olcross: dS,
  oline: gS,
  olt: mS,
  Omacr: _S,
  omacr: bS,
  Omega: vS,
  omega: kS,
  Omicron: xS,
  omicron: yS,
  omid: wS,
  ominus: ES,
  Oopf: AS,
  oopf: CS,
  opar: SS,
  OpenCurlyDoubleQuote: DS,
  OpenCurlyQuote: qS,
  operp: TS,
  oplus: RS,
  orarr: NS,
  Or: MS,
  or: LS,
  ord: FS,
  order: IS,
  orderof: OS,
  ordf: BS,
  ordm: PS,
  origof: zS,
  oror: $S,
  orslope: US,
  orv: VS,
  oS: GS,
  Oscr: HS,
  oscr: jS,
  Oslash: ZS,
  oslash: WS,
  osol: KS,
  Otilde: JS,
  otilde: YS,
  otimesas: XS,
  Otimes: QS,
  otimes: eD,
  Ouml: nD,
  ouml: tD,
  ovbar: rD,
  OverBar: oD,
  OverBrace: sD,
  OverBracket: cD,
  OverParenthesis: iD,
  para: aD,
  parallel: lD,
  par: uD,
  parsim: fD,
  parsl: pD,
  part: hD,
  PartialD: dD,
  Pcy: gD,
  pcy: mD,
  percnt: _D,
  period: bD,
  permil: vD,
  perp: kD,
  pertenk: xD,
  Pfr: yD,
  pfr: wD,
  Phi: ED,
  phi: AD,
  phiv: CD,
  phmmat: SD,
  phone: DD,
  Pi: qD,
  pi: TD,
  pitchfork: RD,
  piv: ND,
  planck: MD,
  planckh: LD,
  plankv: FD,
  plusacir: ID,
  plusb: OD,
  pluscir: BD,
  plus: PD,
  plusdo: zD,
  plusdu: $D,
  pluse: UD,
  PlusMinus: VD,
  plusmn: GD,
  plussim: HD,
  plustwo: jD,
  pm: ZD,
  Poincareplane: WD,
  pointint: KD,
  popf: JD,
  Popf: YD,
  pound: XD,
  prap: QD,
  Pr: eq,
  pr: nq,
  prcue: tq,
  precapprox: rq,
  prec: oq,
  preccurlyeq: sq,
  Precedes: cq,
  PrecedesEqual: iq,
  PrecedesSlantEqual: aq,
  PrecedesTilde: lq,
  preceq: uq,
  precnapprox: fq,
  precneqq: pq,
  precnsim: hq,
  pre: dq,
  prE: gq,
  precsim: mq,
  prime: _q,
  Prime: bq,
  primes: vq,
  prnap: kq,
  prnE: xq,
  prnsim: yq,
  prod: wq,
  Product: Eq,
  profalar: Aq,
  profline: Cq,
  profsurf: Sq,
  prop: Dq,
  Proportional: qq,
  Proportion: Tq,
  propto: Rq,
  prsim: Nq,
  prurel: Mq,
  Pscr: Lq,
  pscr: Fq,
  Psi: Iq,
  psi: Oq,
  puncsp: Bq,
  Qfr: Pq,
  qfr: zq,
  qint: $q,
  qopf: Uq,
  Qopf: Vq,
  qprime: Gq,
  Qscr: Hq,
  qscr: jq,
  quaternions: Zq,
  quatint: Wq,
  quest: Kq,
  questeq: Jq,
  quot: Yq,
  QUOT: Xq,
  rAarr: Qq,
  race: eT,
  Racute: nT,
  racute: tT,
  radic: rT,
  raemptyv: oT,
  rang: sT,
  Rang: cT,
  rangd: iT,
  range: aT,
  rangle: lT,
  raquo: uT,
  rarrap: fT,
  rarrb: pT,
  rarrbfs: hT,
  rarrc: dT,
  rarr: gT,
  Rarr: mT,
  rArr: _T,
  rarrfs: bT,
  rarrhk: vT,
  rarrlp: kT,
  rarrpl: xT,
  rarrsim: yT,
  Rarrtl: wT,
  rarrtl: ET,
  rarrw: AT,
  ratail: CT,
  rAtail: ST,
  ratio: DT,
  rationals: qT,
  rbarr: TT,
  rBarr: RT,
  RBarr: NT,
  rbbrk: MT,
  rbrace: LT,
  rbrack: FT,
  rbrke: IT,
  rbrksld: OT,
  rbrkslu: BT,
  Rcaron: PT,
  rcaron: zT,
  Rcedil: $T,
  rcedil: UT,
  rceil: VT,
  rcub: GT,
  Rcy: HT,
  rcy: jT,
  rdca: ZT,
  rdldhar: WT,
  rdquo: KT,
  rdquor: JT,
  rdsh: YT,
  real: XT,
  realine: QT,
  realpart: eR,
  reals: nR,
  Re: tR,
  rect: rR,
  reg: oR,
  REG: sR,
  ReverseElement: cR,
  ReverseEquilibrium: iR,
  ReverseUpEquilibrium: aR,
  rfisht: lR,
  rfloor: uR,
  rfr: fR,
  Rfr: pR,
  rHar: hR,
  rhard: dR,
  rharu: gR,
  rharul: mR,
  Rho: _R,
  rho: bR,
  rhov: vR,
  RightAngleBracket: kR,
  RightArrowBar: xR,
  rightarrow: yR,
  RightArrow: wR,
  Rightarrow: ER,
  RightArrowLeftArrow: AR,
  rightarrowtail: CR,
  RightCeiling: SR,
  RightDoubleBracket: DR,
  RightDownTeeVector: qR,
  RightDownVectorBar: TR,
  RightDownVector: RR,
  RightFloor: NR,
  rightharpoondown: MR,
  rightharpoonup: LR,
  rightleftarrows: FR,
  rightleftharpoons: IR,
  rightrightarrows: OR,
  rightsquigarrow: BR,
  RightTeeArrow: PR,
  RightTee: zR,
  RightTeeVector: $R,
  rightthreetimes: UR,
  RightTriangleBar: VR,
  RightTriangle: GR,
  RightTriangleEqual: HR,
  RightUpDownVector: jR,
  RightUpTeeVector: ZR,
  RightUpVectorBar: WR,
  RightUpVector: KR,
  RightVectorBar: JR,
  RightVector: YR,
  ring: XR,
  risingdotseq: QR,
  rlarr: eN,
  rlhar: nN,
  rlm: tN,
  rmoustache: rN,
  rmoust: oN,
  rnmid: sN,
  roang: cN,
  roarr: iN,
  robrk: aN,
  ropar: lN,
  ropf: uN,
  Ropf: fN,
  roplus: pN,
  rotimes: hN,
  RoundImplies: dN,
  rpar: gN,
  rpargt: mN,
  rppolint: _N,
  rrarr: bN,
  Rrightarrow: vN,
  rsaquo: kN,
  rscr: xN,
  Rscr: yN,
  rsh: wN,
  Rsh: EN,
  rsqb: AN,
  rsquo: CN,
  rsquor: SN,
  rthree: DN,
  rtimes: qN,
  rtri: TN,
  rtrie: RN,
  rtrif: NN,
  rtriltri: MN,
  RuleDelayed: LN,
  ruluhar: FN,
  rx: IN,
  Sacute: ON,
  sacute: BN,
  sbquo: PN,
  scap: zN,
  Scaron: $N,
  scaron: UN,
  Sc: VN,
  sc: GN,
  sccue: HN,
  sce: jN,
  scE: ZN,
  Scedil: WN,
  scedil: KN,
  Scirc: JN,
  scirc: YN,
  scnap: XN,
  scnE: QN,
  scnsim: eM,
  scpolint: nM,
  scsim: tM,
  Scy: rM,
  scy: oM,
  sdotb: sM,
  sdot: cM,
  sdote: iM,
  searhk: aM,
  searr: lM,
  seArr: uM,
  searrow: fM,
  sect: pM,
  semi: hM,
  seswar: dM,
  setminus: gM,
  setmn: mM,
  sext: _M,
  Sfr: bM,
  sfr: vM,
  sfrown: kM,
  sharp: xM,
  SHCHcy: yM,
  shchcy: wM,
  SHcy: EM,
  shcy: AM,
  ShortDownArrow: CM,
  ShortLeftArrow: SM,
  shortmid: DM,
  shortparallel: qM,
  ShortRightArrow: TM,
  ShortUpArrow: RM,
  shy: NM,
  Sigma: MM,
  sigma: LM,
  sigmaf: FM,
  sigmav: IM,
  sim: OM,
  simdot: BM,
  sime: PM,
  simeq: zM,
  simg: $M,
  simgE: UM,
  siml: VM,
  simlE: GM,
  simne: HM,
  simplus: jM,
  simrarr: ZM,
  slarr: WM,
  SmallCircle: KM,
  smallsetminus: JM,
  smashp: YM,
  smeparsl: XM,
  smid: QM,
  smile: eL,
  smt: nL,
  smte: tL,
  smtes: rL,
  SOFTcy: oL,
  softcy: sL,
  solbar: cL,
  solb: iL,
  sol: aL,
  Sopf: lL,
  sopf: uL,
  spades: fL,
  spadesuit: pL,
  spar: hL,
  sqcap: dL,
  sqcaps: gL,
  sqcup: mL,
  sqcups: _L,
  Sqrt: bL,
  sqsub: vL,
  sqsube: kL,
  sqsubset: xL,
  sqsubseteq: yL,
  sqsup: wL,
  sqsupe: EL,
  sqsupset: AL,
  sqsupseteq: CL,
  square: SL,
  Square: DL,
  SquareIntersection: qL,
  SquareSubset: TL,
  SquareSubsetEqual: RL,
  SquareSuperset: NL,
  SquareSupersetEqual: ML,
  SquareUnion: LL,
  squarf: FL,
  squ: IL,
  squf: OL,
  srarr: BL,
  Sscr: PL,
  sscr: zL,
  ssetmn: $L,
  ssmile: UL,
  sstarf: VL,
  Star: GL,
  star: HL,
  starf: jL,
  straightepsilon: ZL,
  straightphi: WL,
  strns: KL,
  sub: JL,
  Sub: YL,
  subdot: XL,
  subE: QL,
  sube: e2,
  subedot: n2,
  submult: t2,
  subnE: r2,
  subne: o2,
  subplus: s2,
  subrarr: c2,
  subset: i2,
  Subset: a2,
  subseteq: l2,
  subseteqq: u2,
  SubsetEqual: f2,
  subsetneq: p2,
  subsetneqq: h2,
  subsim: d2,
  subsub: g2,
  subsup: m2,
  succapprox: _2,
  succ: b2,
  succcurlyeq: v2,
  Succeeds: k2,
  SucceedsEqual: x2,
  SucceedsSlantEqual: y2,
  SucceedsTilde: w2,
  succeq: E2,
  succnapprox: A2,
  succneqq: C2,
  succnsim: S2,
  succsim: D2,
  SuchThat: q2,
  sum: T2,
  Sum: R2,
  sung: N2,
  sup1: M2,
  sup2: L2,
  sup3: F2,
  sup: I2,
  Sup: O2,
  supdot: B2,
  supdsub: P2,
  supE: z2,
  supe: $2,
  supedot: U2,
  Superset: V2,
  SupersetEqual: G2,
  suphsol: H2,
  suphsub: j2,
  suplarr: Z2,
  supmult: W2,
  supnE: K2,
  supne: J2,
  supplus: Y2,
  supset: X2,
  Supset: Q2,
  supseteq: eF,
  supseteqq: nF,
  supsetneq: tF,
  supsetneqq: rF,
  supsim: oF,
  supsub: sF,
  supsup: cF,
  swarhk: iF,
  swarr: aF,
  swArr: lF,
  swarrow: uF,
  swnwar: fF,
  szlig: pF,
  Tab: hF,
  target: dF,
  Tau: gF,
  tau: mF,
  tbrk: _F,
  Tcaron: bF,
  tcaron: vF,
  Tcedil: kF,
  tcedil: xF,
  Tcy: yF,
  tcy: wF,
  tdot: EF,
  telrec: AF,
  Tfr: CF,
  tfr: SF,
  there4: DF,
  therefore: qF,
  Therefore: TF,
  Theta: RF,
  theta: NF,
  thetasym: MF,
  thetav: LF,
  thickapprox: FF,
  thicksim: IF,
  ThickSpace: OF,
  ThinSpace: BF,
  thinsp: PF,
  thkap: zF,
  thksim: $F,
  THORN: UF,
  thorn: VF,
  tilde: GF,
  Tilde: HF,
  TildeEqual: jF,
  TildeFullEqual: ZF,
  TildeTilde: WF,
  timesbar: KF,
  timesb: JF,
  times: YF,
  timesd: XF,
  tint: QF,
  toea: eI,
  topbot: nI,
  topcir: tI,
  top: rI,
  Topf: oI,
  topf: sI,
  topfork: cI,
  tosa: iI,
  tprime: aI,
  trade: lI,
  TRADE: uI,
  triangle: fI,
  triangledown: pI,
  triangleleft: hI,
  trianglelefteq: dI,
  triangleq: gI,
  triangleright: mI,
  trianglerighteq: _I,
  tridot: bI,
  trie: vI,
  triminus: kI,
  TripleDot: xI,
  triplus: yI,
  trisb: wI,
  tritime: EI,
  trpezium: AI,
  Tscr: CI,
  tscr: SI,
  TScy: DI,
  tscy: qI,
  TSHcy: TI,
  tshcy: RI,
  Tstrok: NI,
  tstrok: MI,
  twixt: LI,
  twoheadleftarrow: FI,
  twoheadrightarrow: II,
  Uacute: OI,
  uacute: BI,
  uarr: PI,
  Uarr: zI,
  uArr: $I,
  Uarrocir: UI,
  Ubrcy: VI,
  ubrcy: GI,
  Ubreve: HI,
  ubreve: jI,
  Ucirc: ZI,
  ucirc: WI,
  Ucy: KI,
  ucy: JI,
  udarr: YI,
  Udblac: XI,
  udblac: QI,
  udhar: eO,
  ufisht: nO,
  Ufr: tO,
  ufr: rO,
  Ugrave: oO,
  ugrave: sO,
  uHar: cO,
  uharl: iO,
  uharr: aO,
  uhblk: lO,
  ulcorn: uO,
  ulcorner: fO,
  ulcrop: pO,
  ultri: hO,
  Umacr: dO,
  umacr: gO,
  uml: mO,
  UnderBar: _O,
  UnderBrace: bO,
  UnderBracket: vO,
  UnderParenthesis: kO,
  Union: xO,
  UnionPlus: yO,
  Uogon: wO,
  uogon: EO,
  Uopf: AO,
  uopf: CO,
  UpArrowBar: SO,
  uparrow: DO,
  UpArrow: qO,
  Uparrow: TO,
  UpArrowDownArrow: RO,
  updownarrow: NO,
  UpDownArrow: MO,
  Updownarrow: LO,
  UpEquilibrium: FO,
  upharpoonleft: IO,
  upharpoonright: OO,
  uplus: BO,
  UpperLeftArrow: PO,
  UpperRightArrow: zO,
  upsi: $O,
  Upsi: UO,
  upsih: VO,
  Upsilon: GO,
  upsilon: HO,
  UpTeeArrow: jO,
  UpTee: ZO,
  upuparrows: WO,
  urcorn: KO,
  urcorner: JO,
  urcrop: YO,
  Uring: XO,
  uring: QO,
  urtri: eB,
  Uscr: nB,
  uscr: tB,
  utdot: rB,
  Utilde: oB,
  utilde: sB,
  utri: cB,
  utrif: iB,
  uuarr: aB,
  Uuml: lB,
  uuml: uB,
  uwangle: fB,
  vangrt: pB,
  varepsilon: hB,
  varkappa: dB,
  varnothing: gB,
  varphi: mB,
  varpi: _B,
  varpropto: bB,
  varr: vB,
  vArr: kB,
  varrho: xB,
  varsigma: yB,
  varsubsetneq: wB,
  varsubsetneqq: EB,
  varsupsetneq: AB,
  varsupsetneqq: CB,
  vartheta: SB,
  vartriangleleft: DB,
  vartriangleright: qB,
  vBar: TB,
  Vbar: RB,
  vBarv: NB,
  Vcy: MB,
  vcy: LB,
  vdash: FB,
  vDash: IB,
  Vdash: OB,
  VDash: BB,
  Vdashl: PB,
  veebar: zB,
  vee: $B,
  Vee: UB,
  veeeq: VB,
  vellip: GB,
  verbar: HB,
  Verbar: jB,
  vert: ZB,
  Vert: WB,
  VerticalBar: KB,
  VerticalLine: JB,
  VerticalSeparator: YB,
  VerticalTilde: XB,
  VeryThinSpace: QB,
  Vfr: eP,
  vfr: nP,
  vltri: tP,
  vnsub: rP,
  vnsup: oP,
  Vopf: sP,
  vopf: cP,
  vprop: iP,
  vrtri: aP,
  Vscr: lP,
  vscr: uP,
  vsubnE: fP,
  vsubne: pP,
  vsupnE: hP,
  vsupne: dP,
  Vvdash: gP,
  vzigzag: mP,
  Wcirc: _P,
  wcirc: bP,
  wedbar: vP,
  wedge: kP,
  Wedge: xP,
  wedgeq: yP,
  weierp: wP,
  Wfr: EP,
  wfr: AP,
  Wopf: CP,
  wopf: SP,
  wp: DP,
  wr: qP,
  wreath: TP,
  Wscr: RP,
  wscr: NP,
  xcap: MP,
  xcirc: LP,
  xcup: FP,
  xdtri: IP,
  Xfr: OP,
  xfr: BP,
  xharr: PP,
  xhArr: zP,
  Xi: $P,
  xi: UP,
  xlarr: VP,
  xlArr: GP,
  xmap: HP,
  xnis: jP,
  xodot: ZP,
  Xopf: WP,
  xopf: KP,
  xoplus: JP,
  xotime: YP,
  xrarr: XP,
  xrArr: QP,
  Xscr: ez,
  xscr: nz,
  xsqcup: tz,
  xuplus: rz,
  xutri: oz,
  xvee: sz,
  xwedge: cz,
  Yacute: iz,
  yacute: az,
  YAcy: lz,
  yacy: uz,
  Ycirc: fz,
  ycirc: pz,
  Ycy: hz,
  ycy: dz,
  yen: gz,
  Yfr: mz,
  yfr: _z,
  YIcy: bz,
  yicy: vz,
  Yopf: kz,
  yopf: xz,
  Yscr: yz,
  yscr: wz,
  YUcy: Ez,
  yucy: Az,
  yuml: Cz,
  Yuml: Sz,
  Zacute: Dz,
  zacute: qz,
  Zcaron: Tz,
  zcaron: Rz,
  Zcy: Nz,
  zcy: Mz,
  Zdot: Lz,
  zdot: Fz,
  zeetrf: Iz,
  ZeroWidthSpace: Oz,
  Zeta: Bz,
  zeta: Pz,
  zfr: zz,
  Zfr: $z,
  ZHcy: Uz,
  zhcy: Vz,
  zigrarr: Gz,
  zopf: Hz,
  Zopf: jz,
  Zscr: Zz,
  zscr: Wz,
  zwj: Kz,
  zwnj: Jz
};
var ar = Yz, Bn = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, qe = {}, it = {};
function Xz(n) {
  var e, t, r = it[n];
  if (r)
    return r;
  for (r = it[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), /^[0-9a-z]$/i.test(t) ? r.push(t) : r.push("%" + ("0" + e.toString(16).toUpperCase()).slice(-2));
  for (e = 0; e < n.length; e++)
    r[n.charCodeAt(e)] = n[e];
  return r;
}
function on(n, e, t) {
  var r, o, s, c, i, a = "";
  for (typeof e != "string" && (t = e, e = on.defaultChars), typeof t > "u" && (t = !0), i = Xz(e), r = 0, o = n.length; r < o; r++) {
    if (s = n.charCodeAt(r), t && s === 37 && r + 2 < o && /^[0-9a-f]{2}$/i.test(n.slice(r + 1, r + 3))) {
      a += n.slice(r, r + 3), r += 2;
      continue;
    }
    if (s < 128) {
      a += i[s];
      continue;
    }
    if (s >= 55296 && s <= 57343) {
      if (s >= 55296 && s <= 56319 && r + 1 < o && (c = n.charCodeAt(r + 1), c >= 56320 && c <= 57343)) {
        a += encodeURIComponent(n[r] + n[r + 1]), r++;
        continue;
      }
      a += "%EF%BF%BD";
      continue;
    }
    a += encodeURIComponent(n[r]);
  }
  return a;
}
on.defaultChars = ";/?:@&=+$,-_.!~*'()#";
on.componentChars = "-_.!~*'()";
var Qz = on, at = {};
function e3(n) {
  var e, t, r = at[n];
  if (r)
    return r;
  for (r = at[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), r.push(t);
  for (e = 0; e < n.length; e++)
    t = n.charCodeAt(e), r[t] = "%" + ("0" + t.toString(16).toUpperCase()).slice(-2);
  return r;
}
function sn(n, e) {
  var t;
  return typeof e != "string" && (e = sn.defaultChars), t = e3(e), n.replace(/(%[a-f0-9]{2})+/gi, function(r) {
    var o, s, c, i, a, l, u, p = "";
    for (o = 0, s = r.length; o < s; o += 3) {
      if (c = parseInt(r.slice(o + 1, o + 3), 16), c < 128) {
        p += t[c];
        continue;
      }
      if ((c & 224) === 192 && o + 3 < s && (i = parseInt(r.slice(o + 4, o + 6), 16), (i & 192) === 128)) {
        u = c << 6 & 1984 | i & 63, u < 128 ? p += "��" : p += String.fromCharCode(u), o += 3;
        continue;
      }
      if ((c & 240) === 224 && o + 6 < s && (i = parseInt(r.slice(o + 4, o + 6), 16), a = parseInt(r.slice(o + 7, o + 9), 16), (i & 192) === 128 && (a & 192) === 128)) {
        u = c << 12 & 61440 | i << 6 & 4032 | a & 63, u < 2048 || u >= 55296 && u <= 57343 ? p += "���" : p += String.fromCharCode(u), o += 6;
        continue;
      }
      if ((c & 248) === 240 && o + 9 < s && (i = parseInt(r.slice(o + 4, o + 6), 16), a = parseInt(r.slice(o + 7, o + 9), 16), l = parseInt(r.slice(o + 10, o + 12), 16), (i & 192) === 128 && (a & 192) === 128 && (l & 192) === 128)) {
        u = c << 18 & 1835008 | i << 12 & 258048 | a << 6 & 4032 | l & 63, u < 65536 || u > 1114111 ? p += "����" : (u -= 65536, p += String.fromCharCode(55296 + (u >> 10), 56320 + (u & 1023))), o += 9;
        continue;
      }
      p += "�";
    }
    return p;
  });
}
sn.defaultChars = ";/?:@&=+$,#";
sn.componentChars = "";
var n3 = sn, t3 = function(e) {
  var t = "";
  return t += e.protocol || "", t += e.slashes ? "//" : "", t += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? t += "[" + e.hostname + "]" : t += e.hostname || "", t += e.port ? ":" + e.port : "", t += e.pathname || "", t += e.search || "", t += e.hash || "", t;
};
function Qe() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
var r3 = /^([a-z0-9.+-]+:)/i, o3 = /:[0-9]*$/, s3 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, c3 = ["<", ">", '"', "`", " ", "\r", `
`, "	"], i3 = ["{", "}", "|", "\\", "^", "`"].concat(c3), a3 = ["'"].concat(i3), lt = ["%", "/", "?", ";", "#"].concat(a3), ut = ["/", "?", "#"], l3 = 255, ft = /^[+a-z0-9A-Z_-]{0,63}$/, u3 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, pt = {
  javascript: !0,
  "javascript:": !0
}, ht = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function f3(n, e) {
  if (n && n instanceof Qe)
    return n;
  var t = new Qe();
  return t.parse(n, e), t;
}
Qe.prototype.parse = function(n, e) {
  var t, r, o, s, c, i = n;
  if (i = i.trim(), !e && n.split("#").length === 1) {
    var a = s3.exec(i);
    if (a)
      return this.pathname = a[1], a[2] && (this.search = a[2]), this;
  }
  var l = r3.exec(i);
  if (l && (l = l[0], o = l.toLowerCase(), this.protocol = l, i = i.substr(l.length)), (e || l || i.match(/^\/\/[^@\/]+@[^@\/]+/)) && (c = i.substr(0, 2) === "//", c && !(l && pt[l]) && (i = i.substr(2), this.slashes = !0)), !pt[l] && (c || l && !ht[l])) {
    var u = -1;
    for (t = 0; t < ut.length; t++)
      s = i.indexOf(ut[t]), s !== -1 && (u === -1 || s < u) && (u = s);
    var p, f;
    for (u === -1 ? f = i.lastIndexOf("@") : f = i.lastIndexOf("@", u), f !== -1 && (p = i.slice(0, f), i = i.slice(f + 1), this.auth = p), u = -1, t = 0; t < lt.length; t++)
      s = i.indexOf(lt[t]), s !== -1 && (u === -1 || s < u) && (u = s);
    u === -1 && (u = i.length), i[u - 1] === ":" && u--;
    var h = i.slice(0, u);
    i = i.slice(u), this.parseHost(h), this.hostname = this.hostname || "";
    var k = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!k) {
      var v = this.hostname.split(/\./);
      for (t = 0, r = v.length; t < r; t++) {
        var A = v[t];
        if (A && !A.match(ft)) {
          for (var y = "", g = 0, w = A.length; g < w; g++)
            A.charCodeAt(g) > 127 ? y += "x" : y += A[g];
          if (!y.match(ft)) {
            var C = v.slice(0, t), q = v.slice(t + 1), _ = A.match(u3);
            _ && (C.push(_[1]), q.unshift(_[2])), q.length && (i = q.join(".") + i), this.hostname = C.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > l3 && (this.hostname = ""), k && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  var M = i.indexOf("#");
  M !== -1 && (this.hash = i.substr(M), i = i.slice(0, M));
  var $ = i.indexOf("?");
  return $ !== -1 && (this.search = i.substr($), i = i.slice(0, $)), i && (this.pathname = i), ht[o] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
Qe.prototype.parseHost = function(n) {
  var e = o3.exec(n);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), n = n.substr(0, n.length - e.length)), n && (this.hostname = n);
};
var p3 = f3;
qe.encode = Qz;
qe.decode = n3;
qe.format = t3;
qe.parse = p3;
var ge = {}, bn, dt;
function lr() {
  return dt || (dt = 1, bn = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), bn;
}
var vn, gt;
function ur() {
  return gt || (gt = 1, vn = /[\0-\x1F\x7F-\x9F]/), vn;
}
var kn, mt;
function h3() {
  return mt || (mt = 1, kn = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/), kn;
}
var xn, _t;
function fr() {
  return _t || (_t = 1, xn = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/), xn;
}
var bt;
function d3() {
  return bt || (bt = 1, ge.Any = lr(), ge.Cc = ur(), ge.Cf = h3(), ge.P = Bn, ge.Z = fr()), ge;
}
(function(n) {
  function e(m) {
    return Object.prototype.toString.call(m);
  }
  function t(m) {
    return e(m) === "[object String]";
  }
  var r = Object.prototype.hasOwnProperty;
  function o(m, O) {
    return r.call(m, O);
  }
  function s(m) {
    var O = Array.prototype.slice.call(arguments, 1);
    return O.forEach(function(N) {
      if (N) {
        if (typeof N != "object")
          throw new TypeError(N + "must be object");
        Object.keys(N).forEach(function(d) {
          m[d] = N[d];
        });
      }
    }), m;
  }
  function c(m, O, N) {
    return [].concat(m.slice(0, O), N, m.slice(O + 1));
  }
  function i(m) {
    return !(m >= 55296 && m <= 57343 || m >= 64976 && m <= 65007 || (m & 65535) === 65535 || (m & 65535) === 65534 || m >= 0 && m <= 8 || m === 11 || m >= 14 && m <= 31 || m >= 127 && m <= 159 || m > 1114111);
  }
  function a(m) {
    if (m > 65535) {
      m -= 65536;
      var O = 55296 + (m >> 10), N = 56320 + (m & 1023);
      return String.fromCharCode(O, N);
    }
    return String.fromCharCode(m);
  }
  var l = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g, u = /&([a-z#][a-z0-9]{1,31});/gi, p = new RegExp(l.source + "|" + u.source, "gi"), f = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i, h = ar;
  function k(m, O) {
    var N = 0;
    return o(h, O) ? h[O] : O.charCodeAt(0) === 35 && f.test(O) && (N = O[1].toLowerCase() === "x" ? parseInt(O.slice(2), 16) : parseInt(O.slice(1), 10), i(N)) ? a(N) : m;
  }
  function v(m) {
    return m.indexOf("\\") < 0 ? m : m.replace(l, "$1");
  }
  function A(m) {
    return m.indexOf("\\") < 0 && m.indexOf("&") < 0 ? m : m.replace(p, function(O, N, d) {
      return N || k(O, d);
    });
  }
  var y = /[&<>"]/, g = /[&<>"]/g, w = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function C(m) {
    return w[m];
  }
  function q(m) {
    return y.test(m) ? m.replace(g, C) : m;
  }
  var _ = /[.?*+^$[\]\\(){}|-]/g;
  function M(m) {
    return m.replace(_, "\\$&");
  }
  function $(m) {
    switch (m) {
      case 9:
      case 32:
        return !0;
    }
    return !1;
  }
  function H(m) {
    if (m >= 8192 && m <= 8202)
      return !0;
    switch (m) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return !0;
    }
    return !1;
  }
  var R = Bn;
  function P(m) {
    return R.test(m);
  }
  function fe(m) {
    switch (m) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return !0;
      default:
        return !1;
    }
  }
  function oe(m) {
    return m = m.trim().replace(/\s+/g, " "), "ẞ".toLowerCase() === "Ṿ" && (m = m.replace(/ẞ/g, "ß")), m.toLowerCase().toUpperCase();
  }
  n.lib = {}, n.lib.mdurl = qe, n.lib.ucmicro = d3(), n.assign = s, n.isString = t, n.has = o, n.unescapeMd = v, n.unescapeAll = A, n.isValidEntityCode = i, n.fromCodePoint = a, n.escapeHtml = q, n.arrayReplaceAt = c, n.isSpace = $, n.isWhiteSpace = H, n.isMdAsciiPunct = fe, n.isPunctChar = P, n.escapeRE = M, n.normalizeReference = oe;
})(I);
var cn = {}, g3 = function(e, t, r) {
  var o, s, c, i, a = -1, l = e.posMax, u = e.pos;
  for (e.pos = t + 1, o = 1; e.pos < l; ) {
    if (c = e.src.charCodeAt(e.pos), c === 93 && (o--, o === 0)) {
      s = !0;
      break;
    }
    if (i = e.pos, e.md.inline.skipToken(e), c === 91) {
      if (i === e.pos - 1)
        o++;
      else if (r)
        return e.pos = u, -1;
    }
  }
  return s && (a = e.pos), e.pos = u, a;
}, vt = I.unescapeAll, m3 = function(e, t, r) {
  var o, s, c = 0, i = t, a = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (e.charCodeAt(t) === 60) {
    for (t++; t < r; ) {
      if (o = e.charCodeAt(t), o === 10 || o === 60)
        return a;
      if (o === 62)
        return a.pos = t + 1, a.str = vt(e.slice(i + 1, t)), a.ok = !0, a;
      if (o === 92 && t + 1 < r) {
        t += 2;
        continue;
      }
      t++;
    }
    return a;
  }
  for (s = 0; t < r && (o = e.charCodeAt(t), !(o === 32 || o < 32 || o === 127)); ) {
    if (o === 92 && t + 1 < r) {
      if (e.charCodeAt(t + 1) === 32)
        break;
      t += 2;
      continue;
    }
    if (o === 40 && (s++, s > 32))
      return a;
    if (o === 41) {
      if (s === 0)
        break;
      s--;
    }
    t++;
  }
  return i === t || s !== 0 || (a.str = vt(e.slice(i, t)), a.lines = c, a.pos = t, a.ok = !0), a;
}, _3 = I.unescapeAll, b3 = function(e, t, r) {
  var o, s, c = 0, i = t, a = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (t >= r || (s = e.charCodeAt(t), s !== 34 && s !== 39 && s !== 40))
    return a;
  for (t++, s === 40 && (s = 41); t < r; ) {
    if (o = e.charCodeAt(t), o === s)
      return a.pos = t + 1, a.lines = c, a.str = _3(e.slice(i + 1, t)), a.ok = !0, a;
    if (o === 40 && s === 41)
      return a;
    o === 10 ? c++ : o === 92 && t + 1 < r && (t++, e.charCodeAt(t) === 10 && c++), t++;
  }
  return a;
};
cn.parseLinkLabel = g3;
cn.parseLinkDestination = m3;
cn.parseLinkTitle = b3;
var v3 = I.assign, k3 = I.unescapeAll, ye = I.escapeHtml, le = {};
le.code_inline = function(n, e, t, r, o) {
  var s = n[e];
  return "<code" + o.renderAttrs(s) + ">" + ye(n[e].content) + "</code>";
};
le.code_block = function(n, e, t, r, o) {
  var s = n[e];
  return "<pre" + o.renderAttrs(s) + "><code>" + ye(n[e].content) + `</code></pre>
`;
};
le.fence = function(n, e, t, r, o) {
  var s = n[e], c = s.info ? k3(s.info).trim() : "", i = "", a = "", l, u, p, f, h;
  return c && (p = c.split(/(\s+)/g), i = p[0], a = p.slice(2).join("")), t.highlight ? l = t.highlight(s.content, i, a) || ye(s.content) : l = ye(s.content), l.indexOf("<pre") === 0 ? l + `
` : c ? (u = s.attrIndex("class"), f = s.attrs ? s.attrs.slice() : [], u < 0 ? f.push(["class", t.langPrefix + i]) : (f[u] = f[u].slice(), f[u][1] += " " + t.langPrefix + i), h = {
    attrs: f
  }, "<pre><code" + o.renderAttrs(h) + ">" + l + `</code></pre>
`) : "<pre><code" + o.renderAttrs(s) + ">" + l + `</code></pre>
`;
};
le.image = function(n, e, t, r, o) {
  var s = n[e];
  return s.attrs[s.attrIndex("alt")][1] = o.renderInlineAsText(s.children, t, r), o.renderToken(n, e, t);
};
le.hardbreak = function(n, e, t) {
  return t.xhtmlOut ? `<br />
` : `<br>
`;
};
le.softbreak = function(n, e, t) {
  return t.breaks ? t.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
le.text = function(n, e) {
  return ye(n[e].content);
};
le.html_block = function(n, e) {
  return n[e].content;
};
le.html_inline = function(n, e) {
  return n[e].content;
};
function Te() {
  this.rules = v3({}, le);
}
Te.prototype.renderAttrs = function(e) {
  var t, r, o;
  if (!e.attrs)
    return "";
  for (o = "", t = 0, r = e.attrs.length; t < r; t++)
    o += " " + ye(e.attrs[t][0]) + '="' + ye(e.attrs[t][1]) + '"';
  return o;
};
Te.prototype.renderToken = function(e, t, r) {
  var o, s = "", c = !1, i = e[t];
  return i.hidden ? "" : (i.block && i.nesting !== -1 && t && e[t - 1].hidden && (s += `
`), s += (i.nesting === -1 ? "</" : "<") + i.tag, s += this.renderAttrs(i), i.nesting === 0 && r.xhtmlOut && (s += " /"), i.block && (c = !0, i.nesting === 1 && t + 1 < e.length && (o = e[t + 1], (o.type === "inline" || o.hidden || o.nesting === -1 && o.tag === i.tag) && (c = !1))), s += c ? `>
` : ">", s);
};
Te.prototype.renderInline = function(n, e, t) {
  for (var r, o = "", s = this.rules, c = 0, i = n.length; c < i; c++)
    r = n[c].type, typeof s[r] < "u" ? o += s[r](n, c, e, t, this) : o += this.renderToken(n, c, e);
  return o;
};
Te.prototype.renderInlineAsText = function(n, e, t) {
  for (var r = "", o = 0, s = n.length; o < s; o++)
    n[o].type === "text" ? r += n[o].content : n[o].type === "image" ? r += this.renderInlineAsText(n[o].children, e, t) : n[o].type === "softbreak" && (r += `
`);
  return r;
};
Te.prototype.render = function(n, e, t) {
  var r, o, s, c = "", i = this.rules;
  for (r = 0, o = n.length; r < o; r++)
    s = n[r].type, s === "inline" ? c += this.renderInline(n[r].children, e, t) : typeof i[s] < "u" ? c += i[n[r].type](n, r, e, t, this) : c += this.renderToken(n, r, e, t);
  return c;
};
var x3 = Te;
function re() {
  this.__rules__ = [], this.__cache__ = null;
}
re.prototype.__find__ = function(n) {
  for (var e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === n)
      return e;
  return -1;
};
re.prototype.__compile__ = function() {
  var n = this, e = [""];
  n.__rules__.forEach(function(t) {
    t.enabled && t.alt.forEach(function(r) {
      e.indexOf(r) < 0 && e.push(r);
    });
  }), n.__cache__ = {}, e.forEach(function(t) {
    n.__cache__[t] = [], n.__rules__.forEach(function(r) {
      r.enabled && (t && r.alt.indexOf(t) < 0 || n.__cache__[t].push(r.fn));
    });
  });
};
re.prototype.at = function(n, e, t) {
  var r = this.__find__(n), o = t || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__[r].fn = e, this.__rules__[r].alt = o.alt || [], this.__cache__ = null;
};
re.prototype.before = function(n, e, t, r) {
  var o = this.__find__(n), s = r || {};
  if (o === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(o, 0, {
    name: e,
    enabled: !0,
    fn: t,
    alt: s.alt || []
  }), this.__cache__ = null;
};
re.prototype.after = function(n, e, t, r) {
  var o = this.__find__(n), s = r || {};
  if (o === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(o + 1, 0, {
    name: e,
    enabled: !0,
    fn: t,
    alt: s.alt || []
  }), this.__cache__ = null;
};
re.prototype.push = function(n, e, t) {
  var r = t || {};
  this.__rules__.push({
    name: n,
    enabled: !0,
    fn: e,
    alt: r.alt || []
  }), this.__cache__ = null;
};
re.prototype.enable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(r) {
    var o = this.__find__(r);
    if (o < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[o].enabled = !0, t.push(r);
  }, this), this.__cache__ = null, t;
};
re.prototype.enableOnly = function(n, e) {
  Array.isArray(n) || (n = [n]), this.__rules__.forEach(function(t) {
    t.enabled = !1;
  }), this.enable(n, e);
};
re.prototype.disable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(r) {
    var o = this.__find__(r);
    if (o < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[o].enabled = !1, t.push(r);
  }, this), this.__cache__ = null, t;
};
re.prototype.getRules = function(n) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[n] || [];
};
var Pn = re, y3 = /\r\n?|\n/g, w3 = /\0/g, E3 = function(e) {
  var t;
  t = e.src.replace(y3, `
`), t = t.replace(w3, "�"), e.src = t;
}, A3 = function(e) {
  var t;
  e.inlineMode ? (t = new e.Token("inline", "", 0), t.content = e.src, t.map = [0, 1], t.children = [], e.tokens.push(t)) : e.md.block.parse(e.src, e.md, e.env, e.tokens);
}, C3 = function(e) {
  var t = e.tokens, r, o, s;
  for (o = 0, s = t.length; o < s; o++)
    r = t[o], r.type === "inline" && e.md.inline.parse(r.content, e.md, e.env, r.children);
}, S3 = I.arrayReplaceAt;
function D3(n) {
  return /^<a[>\s]/i.test(n);
}
function q3(n) {
  return /^<\/a\s*>/i.test(n);
}
var T3 = function(e) {
  var t, r, o, s, c, i, a, l, u, p, f, h, k, v, A, y, g = e.tokens, w;
  if (e.md.options.linkify) {
    for (r = 0, o = g.length; r < o; r++)
      if (!(g[r].type !== "inline" || !e.md.linkify.pretest(g[r].content)))
        for (s = g[r].children, k = 0, t = s.length - 1; t >= 0; t--) {
          if (i = s[t], i.type === "link_close") {
            for (t--; s[t].level !== i.level && s[t].type !== "link_open"; )
              t--;
            continue;
          }
          if (i.type === "html_inline" && (D3(i.content) && k > 0 && k--, q3(i.content) && k++), !(k > 0) && i.type === "text" && e.md.linkify.test(i.content)) {
            for (u = i.content, w = e.md.linkify.match(u), a = [], h = i.level, f = 0, l = 0; l < w.length; l++)
              v = w[l].url, A = e.md.normalizeLink(v), e.md.validateLink(A) && (y = w[l].text, w[l].schema ? w[l].schema === "mailto:" && !/^mailto:/i.test(y) ? y = e.md.normalizeLinkText("mailto:" + y).replace(/^mailto:/, "") : y = e.md.normalizeLinkText(y) : y = e.md.normalizeLinkText("http://" + y).replace(/^http:\/\//, ""), p = w[l].index, p > f && (c = new e.Token("text", "", 0), c.content = u.slice(f, p), c.level = h, a.push(c)), c = new e.Token("link_open", "a", 1), c.attrs = [["href", A]], c.level = h++, c.markup = "linkify", c.info = "auto", a.push(c), c = new e.Token("text", "", 0), c.content = y, c.level = h, a.push(c), c = new e.Token("link_close", "a", -1), c.level = --h, c.markup = "linkify", c.info = "auto", a.push(c), f = w[l].lastIndex);
            f < u.length && (c = new e.Token("text", "", 0), c.content = u.slice(f), c.level = h, a.push(c)), g[r].children = s = S3(s, t, a);
          }
        }
  }
}, pr = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, R3 = /\((c|tm|r|p)\)/i, N3 = /\((c|tm|r|p)\)/ig, M3 = {
  c: "©",
  r: "®",
  p: "§",
  tm: "™"
};
function L3(n, e) {
  return M3[e.toLowerCase()];
}
function F3(n) {
  var e, t, r = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !r && (t.content = t.content.replace(N3, L3)), t.type === "link_open" && t.info === "auto" && r--, t.type === "link_close" && t.info === "auto" && r++;
}
function I3(n) {
  var e, t, r = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !r && pr.test(t.content) && (t.content = t.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–")), t.type === "link_open" && t.info === "auto" && r--, t.type === "link_close" && t.info === "auto" && r++;
}
var O3 = function(e) {
  var t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type === "inline" && (R3.test(e.tokens[t].content) && F3(e.tokens[t].children), pr.test(e.tokens[t].content) && I3(e.tokens[t].children));
}, kt = I.isWhiteSpace, xt = I.isPunctChar, yt = I.isMdAsciiPunct, B3 = /['"]/, wt = /['"]/g, Et = "’";
function Ze(n, e, t) {
  return n.substr(0, e) + t + n.substr(e + 1);
}
function P3(n, e) {
  var t, r, o, s, c, i, a, l, u, p, f, h, k, v, A, y, g, w, C, q, _;
  for (C = [], t = 0; t < n.length; t++) {
    for (r = n[t], a = n[t].level, g = C.length - 1; g >= 0 && !(C[g].level <= a); g--)
      ;
    if (C.length = g + 1, r.type === "text") {
      o = r.content, c = 0, i = o.length;
      e:
        for (; c < i && (wt.lastIndex = c, s = wt.exec(o), !!s); ) {
          if (A = y = !0, c = s.index + 1, w = s[0] === "'", u = 32, s.index - 1 >= 0)
            u = o.charCodeAt(s.index - 1);
          else
            for (g = t - 1; g >= 0 && !(n[g].type === "softbreak" || n[g].type === "hardbreak"); g--)
              if (n[g].content) {
                u = n[g].content.charCodeAt(n[g].content.length - 1);
                break;
              }
          if (p = 32, c < i)
            p = o.charCodeAt(c);
          else
            for (g = t + 1; g < n.length && !(n[g].type === "softbreak" || n[g].type === "hardbreak"); g++)
              if (n[g].content) {
                p = n[g].content.charCodeAt(0);
                break;
              }
          if (f = yt(u) || xt(String.fromCharCode(u)), h = yt(p) || xt(String.fromCharCode(p)), k = kt(u), v = kt(p), v ? A = !1 : h && (k || f || (A = !1)), k ? y = !1 : f && (v || h || (y = !1)), p === 34 && s[0] === '"' && u >= 48 && u <= 57 && (y = A = !1), A && y && (A = f, y = h), !A && !y) {
            w && (r.content = Ze(r.content, s.index, Et));
            continue;
          }
          if (y) {
            for (g = C.length - 1; g >= 0 && (l = C[g], !(C[g].level < a)); g--)
              if (l.single === w && C[g].level === a) {
                l = C[g], w ? (q = e.md.options.quotes[2], _ = e.md.options.quotes[3]) : (q = e.md.options.quotes[0], _ = e.md.options.quotes[1]), r.content = Ze(r.content, s.index, _), n[l.token].content = Ze(
                  n[l.token].content,
                  l.pos,
                  q
                ), c += _.length - 1, l.token === t && (c += q.length - 1), o = r.content, i = o.length, C.length = g;
                continue e;
              }
          }
          A ? C.push({
            token: t,
            pos: s.index,
            single: w,
            level: a
          }) : y && w && (r.content = Ze(r.content, s.index, Et));
        }
    }
  }
}
var z3 = function(e) {
  var t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type !== "inline" || !B3.test(e.tokens[t].content) || P3(e.tokens[t].children, e);
};
function Re(n, e, t) {
  this.type = n, this.tag = e, this.attrs = null, this.map = null, this.nesting = t, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
Re.prototype.attrIndex = function(e) {
  var t, r, o;
  if (!this.attrs)
    return -1;
  for (t = this.attrs, r = 0, o = t.length; r < o; r++)
    if (t[r][0] === e)
      return r;
  return -1;
};
Re.prototype.attrPush = function(e) {
  this.attrs ? this.attrs.push(e) : this.attrs = [e];
};
Re.prototype.attrSet = function(e, t) {
  var r = this.attrIndex(e), o = [e, t];
  r < 0 ? this.attrPush(o) : this.attrs[r] = o;
};
Re.prototype.attrGet = function(e) {
  var t = this.attrIndex(e), r = null;
  return t >= 0 && (r = this.attrs[t][1]), r;
};
Re.prototype.attrJoin = function(e, t) {
  var r = this.attrIndex(e);
  r < 0 ? this.attrPush([e, t]) : this.attrs[r][1] = this.attrs[r][1] + " " + t;
};
var zn = Re, $3 = zn;
function hr(n, e, t) {
  this.src = n, this.env = t, this.tokens = [], this.inlineMode = !1, this.md = e;
}
hr.prototype.Token = $3;
var U3 = hr, V3 = Pn, yn = [
  ["normalize", E3],
  ["block", A3],
  ["inline", C3],
  ["linkify", T3],
  ["replacements", O3],
  ["smartquotes", z3]
];
function $n() {
  this.ruler = new V3();
  for (var n = 0; n < yn.length; n++)
    this.ruler.push(yn[n][0], yn[n][1]);
}
$n.prototype.process = function(n) {
  var e, t, r;
  for (r = this.ruler.getRules(""), e = 0, t = r.length; e < t; e++)
    r[e](n);
};
$n.prototype.State = U3;
var G3 = $n, wn = I.isSpace;
function En(n, e) {
  var t = n.bMarks[e] + n.tShift[e], r = n.eMarks[e];
  return n.src.substr(t, r - t);
}
function At(n) {
  var e = [], t = 0, r = n.length, o, s = !1, c = 0, i = "";
  for (o = n.charCodeAt(t); t < r; )
    o === 124 && (s ? (i += n.substring(c, t - 1), c = t) : (e.push(i + n.substring(c, t)), i = "", c = t + 1)), s = o === 92, t++, o = n.charCodeAt(t);
  return e.push(i + n.substring(c)), e;
}
var H3 = function(e, t, r, o) {
  var s, c, i, a, l, u, p, f, h, k, v, A, y, g, w, C, q, _;
  if (t + 2 > r || (u = t + 1, e.sCount[u] < e.blkIndent) || e.sCount[u] - e.blkIndent >= 4 || (i = e.bMarks[u] + e.tShift[u], i >= e.eMarks[u]) || (q = e.src.charCodeAt(i++), q !== 124 && q !== 45 && q !== 58) || i >= e.eMarks[u] || (_ = e.src.charCodeAt(i++), _ !== 124 && _ !== 45 && _ !== 58 && !wn(_)) || q === 45 && wn(_))
    return !1;
  for (; i < e.eMarks[u]; ) {
    if (s = e.src.charCodeAt(i), s !== 124 && s !== 45 && s !== 58 && !wn(s))
      return !1;
    i++;
  }
  for (c = En(e, t + 1), p = c.split("|"), k = [], a = 0; a < p.length; a++) {
    if (v = p[a].trim(), !v) {
      if (a === 0 || a === p.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(v))
      return !1;
    v.charCodeAt(v.length - 1) === 58 ? k.push(v.charCodeAt(0) === 58 ? "center" : "right") : v.charCodeAt(0) === 58 ? k.push("left") : k.push("");
  }
  if (c = En(e, t).trim(), c.indexOf("|") === -1 || e.sCount[t] - e.blkIndent >= 4 || (p = At(c), p.length && p[0] === "" && p.shift(), p.length && p[p.length - 1] === "" && p.pop(), f = p.length, f === 0 || f !== k.length))
    return !1;
  if (o)
    return !0;
  for (g = e.parentType, e.parentType = "table", C = e.md.block.ruler.getRules("blockquote"), h = e.push("table_open", "table", 1), h.map = A = [t, 0], h = e.push("thead_open", "thead", 1), h.map = [t, t + 1], h = e.push("tr_open", "tr", 1), h.map = [t, t + 1], a = 0; a < p.length; a++)
    h = e.push("th_open", "th", 1), k[a] && (h.attrs = [["style", "text-align:" + k[a]]]), h = e.push("inline", "", 0), h.content = p[a].trim(), h.children = [], h = e.push("th_close", "th", -1);
  for (h = e.push("tr_close", "tr", -1), h = e.push("thead_close", "thead", -1), u = t + 2; u < r && !(e.sCount[u] < e.blkIndent); u++) {
    for (w = !1, a = 0, l = C.length; a < l; a++)
      if (C[a](e, u, r, !0)) {
        w = !0;
        break;
      }
    if (w || (c = En(e, u).trim(), !c) || e.sCount[u] - e.blkIndent >= 4)
      break;
    for (p = At(c), p.length && p[0] === "" && p.shift(), p.length && p[p.length - 1] === "" && p.pop(), u === t + 2 && (h = e.push("tbody_open", "tbody", 1), h.map = y = [t + 2, 0]), h = e.push("tr_open", "tr", 1), h.map = [u, u + 1], a = 0; a < f; a++)
      h = e.push("td_open", "td", 1), k[a] && (h.attrs = [["style", "text-align:" + k[a]]]), h = e.push("inline", "", 0), h.content = p[a] ? p[a].trim() : "", h.children = [], h = e.push("td_close", "td", -1);
    h = e.push("tr_close", "tr", -1);
  }
  return y && (h = e.push("tbody_close", "tbody", -1), y[1] = u), h = e.push("table_close", "table", -1), A[1] = u, e.parentType = g, e.line = u, !0;
}, j3 = function(e, t, r) {
  var o, s, c;
  if (e.sCount[t] - e.blkIndent < 4)
    return !1;
  for (s = o = t + 1; o < r; ) {
    if (e.isEmpty(o)) {
      o++;
      continue;
    }
    if (e.sCount[o] - e.blkIndent >= 4) {
      o++, s = o;
      continue;
    }
    break;
  }
  return e.line = s, c = e.push("code_block", "code", 0), c.content = e.getLines(t, s, 4 + e.blkIndent, !1) + `
`, c.map = [t, e.line], !0;
}, Z3 = function(e, t, r, o) {
  var s, c, i, a, l, u, p, f = !1, h = e.bMarks[t] + e.tShift[t], k = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || h + 3 > k || (s = e.src.charCodeAt(h), s !== 126 && s !== 96) || (l = h, h = e.skipChars(h, s), c = h - l, c < 3) || (p = e.src.slice(l, h), i = e.src.slice(h, k), s === 96 && i.indexOf(String.fromCharCode(s)) >= 0))
    return !1;
  if (o)
    return !0;
  for (a = t; a++, !(a >= r || (h = l = e.bMarks[a] + e.tShift[a], k = e.eMarks[a], h < k && e.sCount[a] < e.blkIndent)); )
    if (e.src.charCodeAt(h) === s && !(e.sCount[a] - e.blkIndent >= 4) && (h = e.skipChars(h, s), !(h - l < c) && (h = e.skipSpaces(h), !(h < k)))) {
      f = !0;
      break;
    }
  return c = e.sCount[t], e.line = a + (f ? 1 : 0), u = e.push("fence", "code", 0), u.info = i, u.content = e.getLines(t + 1, a, c, !0), u.markup = p, u.map = [t, e.line], !0;
}, Ct = I.isSpace, W3 = function(e, t, r, o) {
  var s, c, i, a, l, u, p, f, h, k, v, A, y, g, w, C, q, _, M, $, H = e.lineMax, R = e.bMarks[t] + e.tShift[t], P = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(R++) !== 62)
    return !1;
  if (o)
    return !0;
  for (a = h = e.sCount[t] + 1, e.src.charCodeAt(R) === 32 ? (R++, a++, h++, s = !1, C = !0) : e.src.charCodeAt(R) === 9 ? (C = !0, (e.bsCount[t] + h) % 4 === 3 ? (R++, a++, h++, s = !1) : s = !0) : C = !1, k = [e.bMarks[t]], e.bMarks[t] = R; R < P && (c = e.src.charCodeAt(R), Ct(c)); ) {
    c === 9 ? h += 4 - (h + e.bsCount[t] + (s ? 1 : 0)) % 4 : h++;
    R++;
  }
  for (v = [e.bsCount[t]], e.bsCount[t] = e.sCount[t] + 1 + (C ? 1 : 0), u = R >= P, g = [e.sCount[t]], e.sCount[t] = h - a, w = [e.tShift[t]], e.tShift[t] = R - e.bMarks[t], _ = e.md.block.ruler.getRules("blockquote"), y = e.parentType, e.parentType = "blockquote", f = t + 1; f < r && ($ = e.sCount[f] < e.blkIndent, R = e.bMarks[f] + e.tShift[f], P = e.eMarks[f], !(R >= P)); f++) {
    if (e.src.charCodeAt(R++) === 62 && !$) {
      for (a = h = e.sCount[f] + 1, e.src.charCodeAt(R) === 32 ? (R++, a++, h++, s = !1, C = !0) : e.src.charCodeAt(R) === 9 ? (C = !0, (e.bsCount[f] + h) % 4 === 3 ? (R++, a++, h++, s = !1) : s = !0) : C = !1, k.push(e.bMarks[f]), e.bMarks[f] = R; R < P && (c = e.src.charCodeAt(R), Ct(c)); ) {
        c === 9 ? h += 4 - (h + e.bsCount[f] + (s ? 1 : 0)) % 4 : h++;
        R++;
      }
      u = R >= P, v.push(e.bsCount[f]), e.bsCount[f] = e.sCount[f] + 1 + (C ? 1 : 0), g.push(e.sCount[f]), e.sCount[f] = h - a, w.push(e.tShift[f]), e.tShift[f] = R - e.bMarks[f];
      continue;
    }
    if (u)
      break;
    for (q = !1, i = 0, l = _.length; i < l; i++)
      if (_[i](e, f, r, !0)) {
        q = !0;
        break;
      }
    if (q) {
      e.lineMax = f, e.blkIndent !== 0 && (k.push(e.bMarks[f]), v.push(e.bsCount[f]), w.push(e.tShift[f]), g.push(e.sCount[f]), e.sCount[f] -= e.blkIndent);
      break;
    }
    k.push(e.bMarks[f]), v.push(e.bsCount[f]), w.push(e.tShift[f]), g.push(e.sCount[f]), e.sCount[f] = -1;
  }
  for (A = e.blkIndent, e.blkIndent = 0, M = e.push("blockquote_open", "blockquote", 1), M.markup = ">", M.map = p = [t, 0], e.md.block.tokenize(e, t, f), M = e.push("blockquote_close", "blockquote", -1), M.markup = ">", e.lineMax = H, e.parentType = y, p[1] = e.line, i = 0; i < w.length; i++)
    e.bMarks[i + t] = k[i], e.tShift[i + t] = w[i], e.sCount[i + t] = g[i], e.bsCount[i + t] = v[i];
  return e.blkIndent = A, !0;
}, K3 = I.isSpace, J3 = function(e, t, r, o) {
  var s, c, i, a, l = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (s = e.src.charCodeAt(l++), s !== 42 && s !== 45 && s !== 95))
    return !1;
  for (c = 1; l < u; ) {
    if (i = e.src.charCodeAt(l++), i !== s && !K3(i))
      return !1;
    i === s && c++;
  }
  return c < 3 ? !1 : (o || (e.line = t + 1, a = e.push("hr", "hr", 0), a.map = [t, e.line], a.markup = Array(c + 1).join(String.fromCharCode(s))), !0);
}, dr = I.isSpace;
function St(n, e) {
  var t, r, o, s;
  return r = n.bMarks[e] + n.tShift[e], o = n.eMarks[e], t = n.src.charCodeAt(r++), t !== 42 && t !== 45 && t !== 43 || r < o && (s = n.src.charCodeAt(r), !dr(s)) ? -1 : r;
}
function Dt(n, e) {
  var t, r = n.bMarks[e] + n.tShift[e], o = r, s = n.eMarks[e];
  if (o + 1 >= s || (t = n.src.charCodeAt(o++), t < 48 || t > 57))
    return -1;
  for (; ; ) {
    if (o >= s)
      return -1;
    if (t = n.src.charCodeAt(o++), t >= 48 && t <= 57) {
      if (o - r >= 10)
        return -1;
      continue;
    }
    if (t === 41 || t === 46)
      break;
    return -1;
  }
  return o < s && (t = n.src.charCodeAt(o), !dr(t)) ? -1 : o;
}
function Y3(n, e) {
  var t, r, o = n.level + 2;
  for (t = e + 2, r = n.tokens.length - 2; t < r; t++)
    n.tokens[t].level === o && n.tokens[t].type === "paragraph_open" && (n.tokens[t + 2].hidden = !0, n.tokens[t].hidden = !0, t += 2);
}
var X3 = function(e, t, r, o) {
  var s, c, i, a, l, u, p, f, h, k, v, A, y, g, w, C, q, _, M, $, H, R, P, fe, oe, m, O, N, d = !1, x = !0;
  if (e.sCount[t] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[t] - e.listIndent >= 4 && e.sCount[t] < e.blkIndent)
    return !1;
  if (o && e.parentType === "paragraph" && e.sCount[t] >= e.blkIndent && (d = !0), (P = Dt(e, t)) >= 0) {
    if (p = !0, oe = e.bMarks[t] + e.tShift[t], y = Number(e.src.slice(oe, P - 1)), d && y !== 1)
      return !1;
  } else if ((P = St(e, t)) >= 0)
    p = !1;
  else
    return !1;
  if (d && e.skipSpaces(P) >= e.eMarks[t])
    return !1;
  if (A = e.src.charCodeAt(P - 1), o)
    return !0;
  for (v = e.tokens.length, p ? (N = e.push("ordered_list_open", "ol", 1), y !== 1 && (N.attrs = [["start", y]])) : N = e.push("bullet_list_open", "ul", 1), N.map = k = [t, 0], N.markup = String.fromCharCode(A), w = t, fe = !1, O = e.md.block.ruler.getRules("list"), _ = e.parentType, e.parentType = "list"; w < r; ) {
    for (R = P, g = e.eMarks[w], u = C = e.sCount[w] + P - (e.bMarks[t] + e.tShift[t]); R < g; ) {
      if (s = e.src.charCodeAt(R), s === 9)
        C += 4 - (C + e.bsCount[w]) % 4;
      else if (s === 32)
        C++;
      else
        break;
      R++;
    }
    if (c = R, c >= g ? l = 1 : l = C - u, l > 4 && (l = 1), a = u + l, N = e.push("list_item_open", "li", 1), N.markup = String.fromCharCode(A), N.map = f = [t, 0], p && (N.info = e.src.slice(oe, P - 1)), H = e.tight, $ = e.tShift[t], M = e.sCount[t], q = e.listIndent, e.listIndent = e.blkIndent, e.blkIndent = a, e.tight = !0, e.tShift[t] = c - e.bMarks[t], e.sCount[t] = C, c >= g && e.isEmpty(t + 1) ? e.line = Math.min(e.line + 2, r) : e.md.block.tokenize(e, t, r, !0), (!e.tight || fe) && (x = !1), fe = e.line - t > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = q, e.tShift[t] = $, e.sCount[t] = M, e.tight = H, N = e.push("list_item_close", "li", -1), N.markup = String.fromCharCode(A), w = t = e.line, f[1] = w, c = e.bMarks[t], w >= r || e.sCount[w] < e.blkIndent || e.sCount[t] - e.blkIndent >= 4)
      break;
    for (m = !1, i = 0, h = O.length; i < h; i++)
      if (O[i](e, w, r, !0)) {
        m = !0;
        break;
      }
    if (m)
      break;
    if (p) {
      if (P = Dt(e, w), P < 0)
        break;
      oe = e.bMarks[w] + e.tShift[w];
    } else if (P = St(e, w), P < 0)
      break;
    if (A !== e.src.charCodeAt(P - 1))
      break;
  }
  return p ? N = e.push("ordered_list_close", "ol", -1) : N = e.push("bullet_list_close", "ul", -1), N.markup = String.fromCharCode(A), k[1] = w, e.line = w, e.parentType = _, x && Y3(e, v), !0;
}, Q3 = I.normalizeReference, We = I.isSpace, e$ = function(e, t, r, o) {
  var s, c, i, a, l, u, p, f, h, k, v, A, y, g, w, C, q = 0, _ = e.bMarks[t] + e.tShift[t], M = e.eMarks[t], $ = t + 1;
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(_) !== 91)
    return !1;
  for (; ++_ < M; )
    if (e.src.charCodeAt(_) === 93 && e.src.charCodeAt(_ - 1) !== 92) {
      if (_ + 1 === M || e.src.charCodeAt(_ + 1) !== 58)
        return !1;
      break;
    }
  for (a = e.lineMax, w = e.md.block.ruler.getRules("reference"), k = e.parentType, e.parentType = "reference"; $ < a && !e.isEmpty($); $++)
    if (!(e.sCount[$] - e.blkIndent > 3) && !(e.sCount[$] < 0)) {
      for (g = !1, u = 0, p = w.length; u < p; u++)
        if (w[u](e, $, a, !0)) {
          g = !0;
          break;
        }
      if (g)
        break;
    }
  for (y = e.getLines(t, $, e.blkIndent, !1).trim(), M = y.length, _ = 1; _ < M; _++) {
    if (s = y.charCodeAt(_), s === 91)
      return !1;
    if (s === 93) {
      h = _;
      break;
    } else
      s === 10 ? q++ : s === 92 && (_++, _ < M && y.charCodeAt(_) === 10 && q++);
  }
  if (h < 0 || y.charCodeAt(h + 1) !== 58)
    return !1;
  for (_ = h + 2; _ < M; _++)
    if (s = y.charCodeAt(_), s === 10)
      q++;
    else if (!We(s))
      break;
  if (v = e.md.helpers.parseLinkDestination(y, _, M), !v.ok || (l = e.md.normalizeLink(v.str), !e.md.validateLink(l)))
    return !1;
  for (_ = v.pos, q += v.lines, c = _, i = q, A = _; _ < M; _++)
    if (s = y.charCodeAt(_), s === 10)
      q++;
    else if (!We(s))
      break;
  for (v = e.md.helpers.parseLinkTitle(y, _, M), _ < M && A !== _ && v.ok ? (C = v.str, _ = v.pos, q += v.lines) : (C = "", _ = c, q = i); _ < M && (s = y.charCodeAt(_), !!We(s)); )
    _++;
  if (_ < M && y.charCodeAt(_) !== 10 && C)
    for (C = "", _ = c, q = i; _ < M && (s = y.charCodeAt(_), !!We(s)); )
      _++;
  return _ < M && y.charCodeAt(_) !== 10 || (f = Q3(y.slice(1, h)), !f) ? !1 : (o || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[f] > "u" && (e.env.references[f] = { title: C, href: l }), e.parentType = k, e.line = t + q + 1), !0);
}, n$ = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], an = {}, t$ = "[a-zA-Z_:][a-zA-Z0-9:._-]*", r$ = "[^\"'=<>`\\x00-\\x20]+", o$ = "'[^']*'", s$ = '"[^"]*"', c$ = "(?:" + r$ + "|" + o$ + "|" + s$ + ")", i$ = "(?:\\s+" + t$ + "(?:\\s*=\\s*" + c$ + ")?)", gr = "<[A-Za-z][A-Za-z0-9\\-]*" + i$ + "*\\s*\\/?>", mr = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", a$ = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", l$ = "<[?][\\s\\S]*?[?]>", u$ = "<![A-Z]+\\s+[^>]*>", f$ = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", p$ = new RegExp("^(?:" + gr + "|" + mr + "|" + a$ + "|" + l$ + "|" + u$ + "|" + f$ + ")"), h$ = new RegExp("^(?:" + gr + "|" + mr + ")");
an.HTML_TAG_RE = p$;
an.HTML_OPEN_CLOSE_TAG_RE = h$;
var d$ = n$, g$ = an.HTML_OPEN_CLOSE_TAG_RE, Ee = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + d$.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(g$.source + "\\s*$"), /^$/, !1]
], m$ = function(e, t, r, o) {
  var s, c, i, a, l = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(l) !== 60)
    return !1;
  for (a = e.src.slice(l, u), s = 0; s < Ee.length && !Ee[s][0].test(a); s++)
    ;
  if (s === Ee.length)
    return !1;
  if (o)
    return Ee[s][2];
  if (c = t + 1, !Ee[s][1].test(a)) {
    for (; c < r && !(e.sCount[c] < e.blkIndent); c++)
      if (l = e.bMarks[c] + e.tShift[c], u = e.eMarks[c], a = e.src.slice(l, u), Ee[s][1].test(a)) {
        a.length !== 0 && c++;
        break;
      }
  }
  return e.line = c, i = e.push("html_block", "", 0), i.map = [t, c], i.content = e.getLines(t, c, e.blkIndent, !0), !0;
}, qt = I.isSpace, _$ = function(e, t, r, o) {
  var s, c, i, a, l = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (s = e.src.charCodeAt(l), s !== 35 || l >= u))
    return !1;
  for (c = 1, s = e.src.charCodeAt(++l); s === 35 && l < u && c <= 6; )
    c++, s = e.src.charCodeAt(++l);
  return c > 6 || l < u && !qt(s) ? !1 : (o || (u = e.skipSpacesBack(u, l), i = e.skipCharsBack(u, 35, l), i > l && qt(e.src.charCodeAt(i - 1)) && (u = i), e.line = t + 1, a = e.push("heading_open", "h" + String(c), 1), a.markup = "########".slice(0, c), a.map = [t, e.line], a = e.push("inline", "", 0), a.content = e.src.slice(l, u).trim(), a.map = [t, e.line], a.children = [], a = e.push("heading_close", "h" + String(c), -1), a.markup = "########".slice(0, c)), !0);
}, b$ = function(e, t, r) {
  var o, s, c, i, a, l, u, p, f, h = t + 1, k, v = e.md.block.ruler.getRules("paragraph");
  if (e.sCount[t] - e.blkIndent >= 4)
    return !1;
  for (k = e.parentType, e.parentType = "paragraph"; h < r && !e.isEmpty(h); h++)
    if (!(e.sCount[h] - e.blkIndent > 3)) {
      if (e.sCount[h] >= e.blkIndent && (l = e.bMarks[h] + e.tShift[h], u = e.eMarks[h], l < u && (f = e.src.charCodeAt(l), (f === 45 || f === 61) && (l = e.skipChars(l, f), l = e.skipSpaces(l), l >= u)))) {
        p = f === 61 ? 1 : 2;
        break;
      }
      if (!(e.sCount[h] < 0)) {
        for (s = !1, c = 0, i = v.length; c < i; c++)
          if (v[c](e, h, r, !0)) {
            s = !0;
            break;
          }
        if (s)
          break;
      }
    }
  return p ? (o = e.getLines(t, h, e.blkIndent, !1).trim(), e.line = h + 1, a = e.push("heading_open", "h" + String(p), 1), a.markup = String.fromCharCode(f), a.map = [t, e.line], a = e.push("inline", "", 0), a.content = o, a.map = [t, e.line - 1], a.children = [], a = e.push("heading_close", "h" + String(p), -1), a.markup = String.fromCharCode(f), e.parentType = k, !0) : !1;
}, v$ = function(e, t) {
  var r, o, s, c, i, a, l = t + 1, u = e.md.block.ruler.getRules("paragraph"), p = e.lineMax;
  for (a = e.parentType, e.parentType = "paragraph"; l < p && !e.isEmpty(l); l++)
    if (!(e.sCount[l] - e.blkIndent > 3) && !(e.sCount[l] < 0)) {
      for (o = !1, s = 0, c = u.length; s < c; s++)
        if (u[s](e, l, p, !0)) {
          o = !0;
          break;
        }
      if (o)
        break;
    }
  return r = e.getLines(t, l, e.blkIndent, !1).trim(), e.line = l, i = e.push("paragraph_open", "p", 1), i.map = [t, e.line], i = e.push("inline", "", 0), i.content = r, i.map = [t, e.line], i.children = [], i = e.push("paragraph_close", "p", -1), e.parentType = a, !0;
}, _r = zn, ln = I.isSpace;
function ue(n, e, t, r) {
  var o, s, c, i, a, l, u, p;
  for (this.src = n, this.md = e, this.env = t, this.tokens = r, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", s = this.src, p = !1, c = i = l = u = 0, a = s.length; i < a; i++) {
    if (o = s.charCodeAt(i), !p)
      if (ln(o)) {
        l++, o === 9 ? u += 4 - u % 4 : u++;
        continue;
      } else
        p = !0;
    (o === 10 || i === a - 1) && (o !== 10 && i++, this.bMarks.push(c), this.eMarks.push(i), this.tShift.push(l), this.sCount.push(u), this.bsCount.push(0), p = !1, l = 0, u = 0, c = i + 1);
  }
  this.bMarks.push(s.length), this.eMarks.push(s.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
ue.prototype.push = function(n, e, t) {
  var r = new _r(n, e, t);
  return r.block = !0, t < 0 && this.level--, r.level = this.level, t > 0 && this.level++, this.tokens.push(r), r;
};
ue.prototype.isEmpty = function(e) {
  return this.bMarks[e] + this.tShift[e] >= this.eMarks[e];
};
ue.prototype.skipEmptyLines = function(e) {
  for (var t = this.lineMax; e < t && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]); e++)
    ;
  return e;
};
ue.prototype.skipSpaces = function(e) {
  for (var t, r = this.src.length; e < r && (t = this.src.charCodeAt(e), !!ln(t)); e++)
    ;
  return e;
};
ue.prototype.skipSpacesBack = function(e, t) {
  if (e <= t)
    return e;
  for (; e > t; )
    if (!ln(this.src.charCodeAt(--e)))
      return e + 1;
  return e;
};
ue.prototype.skipChars = function(e, t) {
  for (var r = this.src.length; e < r && this.src.charCodeAt(e) === t; e++)
    ;
  return e;
};
ue.prototype.skipCharsBack = function(e, t, r) {
  if (e <= r)
    return e;
  for (; e > r; )
    if (t !== this.src.charCodeAt(--e))
      return e + 1;
  return e;
};
ue.prototype.getLines = function(e, t, r, o) {
  var s, c, i, a, l, u, p, f = e;
  if (e >= t)
    return "";
  for (u = new Array(t - e), s = 0; f < t; f++, s++) {
    for (c = 0, p = a = this.bMarks[f], f + 1 < t || o ? l = this.eMarks[f] + 1 : l = this.eMarks[f]; a < l && c < r; ) {
      if (i = this.src.charCodeAt(a), ln(i))
        i === 9 ? c += 4 - (c + this.bsCount[f]) % 4 : c++;
      else if (a - p < this.tShift[f])
        c++;
      else
        break;
      a++;
    }
    c > r ? u[s] = new Array(c - r + 1).join(" ") + this.src.slice(a, l) : u[s] = this.src.slice(a, l);
  }
  return u.join("");
};
ue.prototype.Token = _r;
var k$ = ue, x$ = Pn, Ke = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", H3, ["paragraph", "reference"]],
  ["code", j3],
  ["fence", Z3, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", W3, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", J3, ["paragraph", "reference", "blockquote", "list"]],
  ["list", X3, ["paragraph", "reference", "blockquote"]],
  ["reference", e$],
  ["html_block", m$, ["paragraph", "reference", "blockquote"]],
  ["heading", _$, ["paragraph", "reference", "blockquote"]],
  ["lheading", b$],
  ["paragraph", v$]
];
function un() {
  this.ruler = new x$();
  for (var n = 0; n < Ke.length; n++)
    this.ruler.push(Ke[n][0], Ke[n][1], { alt: (Ke[n][2] || []).slice() });
}
un.prototype.tokenize = function(n, e, t) {
  for (var r, o, s = this.ruler.getRules(""), c = s.length, i = e, a = !1, l = n.md.options.maxNesting; i < t && (n.line = i = n.skipEmptyLines(i), !(i >= t || n.sCount[i] < n.blkIndent)); ) {
    if (n.level >= l) {
      n.line = t;
      break;
    }
    for (o = 0; o < c && (r = s[o](n, i, t, !1), !r); o++)
      ;
    n.tight = !a, n.isEmpty(n.line - 1) && (a = !0), i = n.line, i < t && n.isEmpty(i) && (a = !0, i++, n.line = i);
  }
};
un.prototype.parse = function(n, e, t, r) {
  var o;
  n && (o = new this.State(n, e, t, r), this.tokenize(o, o.line, o.lineMax));
};
un.prototype.State = k$;
var y$ = un;
function w$(n) {
  switch (n) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
var E$ = function(e, t) {
  for (var r = e.pos; r < e.posMax && !w$(e.src.charCodeAt(r)); )
    r++;
  return r === e.pos ? !1 : (t || (e.pending += e.src.slice(e.pos, r)), e.pos = r, !0);
}, A$ = I.isSpace, C$ = function(e, t) {
  var r, o, s, c = e.pos;
  if (e.src.charCodeAt(c) !== 10)
    return !1;
  if (r = e.pending.length - 1, o = e.posMax, !t)
    if (r >= 0 && e.pending.charCodeAt(r) === 32)
      if (r >= 1 && e.pending.charCodeAt(r - 1) === 32) {
        for (s = r - 1; s >= 1 && e.pending.charCodeAt(s - 1) === 32; )
          s--;
        e.pending = e.pending.slice(0, s), e.push("hardbreak", "br", 0);
      } else
        e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0);
    else
      e.push("softbreak", "br", 0);
  for (c++; c < o && A$(e.src.charCodeAt(c)); )
    c++;
  return e.pos = c, !0;
}, S$ = I.isSpace, Un = [];
for (var Tt = 0; Tt < 256; Tt++)
  Un.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(n) {
  Un[n.charCodeAt(0)] = 1;
});
var D$ = function(e, t) {
  var r, o = e.pos, s = e.posMax;
  if (e.src.charCodeAt(o) !== 92)
    return !1;
  if (o++, o < s) {
    if (r = e.src.charCodeAt(o), r < 256 && Un[r] !== 0)
      return t || (e.pending += e.src[o]), e.pos += 2, !0;
    if (r === 10) {
      for (t || e.push("hardbreak", "br", 0), o++; o < s && (r = e.src.charCodeAt(o), !!S$(r)); )
        o++;
      return e.pos = o, !0;
    }
  }
  return t || (e.pending += "\\"), e.pos++, !0;
}, q$ = function(e, t) {
  var r, o, s, c, i, a, l, u, p = e.pos, f = e.src.charCodeAt(p);
  if (f !== 96)
    return !1;
  for (r = p, p++, o = e.posMax; p < o && e.src.charCodeAt(p) === 96; )
    p++;
  if (s = e.src.slice(r, p), l = s.length, e.backticksScanned && (e.backticks[l] || 0) <= r)
    return t || (e.pending += s), e.pos += l, !0;
  for (i = a = p; (i = e.src.indexOf("`", a)) !== -1; ) {
    for (a = i + 1; a < o && e.src.charCodeAt(a) === 96; )
      a++;
    if (u = a - i, u === l)
      return t || (c = e.push("code_inline", "code", 0), c.markup = s, c.content = e.src.slice(p, i).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), e.pos = a, !0;
    e.backticks[u] = i;
  }
  return e.backticksScanned = !0, t || (e.pending += s), e.pos += l, !0;
}, fn = {};
fn.tokenize = function(e, t) {
  var r, o, s, c, i, a = e.pos, l = e.src.charCodeAt(a);
  if (t || l !== 126 || (o = e.scanDelims(e.pos, !0), c = o.length, i = String.fromCharCode(l), c < 2))
    return !1;
  for (c % 2 && (s = e.push("text", "", 0), s.content = i, c--), r = 0; r < c; r += 2)
    s = e.push("text", "", 0), s.content = i + i, e.delimiters.push({
      marker: l,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: e.tokens.length - 1,
      end: -1,
      open: o.can_open,
      close: o.can_close
    });
  return e.pos += o.length, !0;
};
function Rt(n, e) {
  var t, r, o, s, c, i = [], a = e.length;
  for (t = 0; t < a; t++)
    o = e[t], o.marker === 126 && o.end !== -1 && (s = e[o.end], c = n.tokens[o.token], c.type = "s_open", c.tag = "s", c.nesting = 1, c.markup = "~~", c.content = "", c = n.tokens[s.token], c.type = "s_close", c.tag = "s", c.nesting = -1, c.markup = "~~", c.content = "", n.tokens[s.token - 1].type === "text" && n.tokens[s.token - 1].content === "~" && i.push(s.token - 1));
  for (; i.length; ) {
    for (t = i.pop(), r = t + 1; r < n.tokens.length && n.tokens[r].type === "s_close"; )
      r++;
    r--, t !== r && (c = n.tokens[r], n.tokens[r] = n.tokens[t], n.tokens[t] = c);
  }
}
fn.postProcess = function(e) {
  var t, r = e.tokens_meta, o = e.tokens_meta.length;
  for (Rt(e, e.delimiters), t = 0; t < o; t++)
    r[t] && r[t].delimiters && Rt(e, r[t].delimiters);
};
var pn = {};
pn.tokenize = function(e, t) {
  var r, o, s, c = e.pos, i = e.src.charCodeAt(c);
  if (t || i !== 95 && i !== 42)
    return !1;
  for (o = e.scanDelims(e.pos, i === 42), r = 0; r < o.length; r++)
    s = e.push("text", "", 0), s.content = String.fromCharCode(i), e.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: i,
      // Total length of these series of delimiters.
      //
      length: o.length,
      // A position of the token this delimiter corresponds to.
      //
      token: e.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: o.can_open,
      close: o.can_close
    });
  return e.pos += o.length, !0;
};
function Nt(n, e) {
  var t, r, o, s, c, i, a = e.length;
  for (t = a - 1; t >= 0; t--)
    r = e[t], !(r.marker !== 95 && r.marker !== 42) && r.end !== -1 && (o = e[r.end], i = t > 0 && e[t - 1].end === r.end + 1 && // check that first two markers match and adjacent
    e[t - 1].marker === r.marker && e[t - 1].token === r.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    e[r.end + 1].token === o.token + 1, c = String.fromCharCode(r.marker), s = n.tokens[r.token], s.type = i ? "strong_open" : "em_open", s.tag = i ? "strong" : "em", s.nesting = 1, s.markup = i ? c + c : c, s.content = "", s = n.tokens[o.token], s.type = i ? "strong_close" : "em_close", s.tag = i ? "strong" : "em", s.nesting = -1, s.markup = i ? c + c : c, s.content = "", i && (n.tokens[e[t - 1].token].content = "", n.tokens[e[r.end + 1].token].content = "", t--));
}
pn.postProcess = function(e) {
  var t, r = e.tokens_meta, o = e.tokens_meta.length;
  for (Nt(e, e.delimiters), t = 0; t < o; t++)
    r[t] && r[t].delimiters && Nt(e, r[t].delimiters);
};
var T$ = I.normalizeReference, An = I.isSpace, R$ = function(e, t) {
  var r, o, s, c, i, a, l, u, p, f = "", h = "", k = e.pos, v = e.posMax, A = e.pos, y = !0;
  if (e.src.charCodeAt(e.pos) !== 91 || (i = e.pos + 1, c = e.md.helpers.parseLinkLabel(e, e.pos, !0), c < 0))
    return !1;
  if (a = c + 1, a < v && e.src.charCodeAt(a) === 40) {
    for (y = !1, a++; a < v && (o = e.src.charCodeAt(a), !(!An(o) && o !== 10)); a++)
      ;
    if (a >= v)
      return !1;
    if (A = a, l = e.md.helpers.parseLinkDestination(e.src, a, e.posMax), l.ok) {
      for (f = e.md.normalizeLink(l.str), e.md.validateLink(f) ? a = l.pos : f = "", A = a; a < v && (o = e.src.charCodeAt(a), !(!An(o) && o !== 10)); a++)
        ;
      if (l = e.md.helpers.parseLinkTitle(e.src, a, e.posMax), a < v && A !== a && l.ok)
        for (h = l.str, a = l.pos; a < v && (o = e.src.charCodeAt(a), !(!An(o) && o !== 10)); a++)
          ;
    }
    (a >= v || e.src.charCodeAt(a) !== 41) && (y = !0), a++;
  }
  if (y) {
    if (typeof e.env.references > "u")
      return !1;
    if (a < v && e.src.charCodeAt(a) === 91 ? (A = a + 1, a = e.md.helpers.parseLinkLabel(e, a), a >= 0 ? s = e.src.slice(A, a++) : a = c + 1) : a = c + 1, s || (s = e.src.slice(i, c)), u = e.env.references[T$(s)], !u)
      return e.pos = k, !1;
    f = u.href, h = u.title;
  }
  return t || (e.pos = i, e.posMax = c, p = e.push("link_open", "a", 1), p.attrs = r = [["href", f]], h && r.push(["title", h]), e.md.inline.tokenize(e), p = e.push("link_close", "a", -1)), e.pos = a, e.posMax = v, !0;
}, N$ = I.normalizeReference, Cn = I.isSpace, M$ = function(e, t) {
  var r, o, s, c, i, a, l, u, p, f, h, k, v, A = "", y = e.pos, g = e.posMax;
  if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91 || (a = e.pos + 2, i = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1), i < 0))
    return !1;
  if (l = i + 1, l < g && e.src.charCodeAt(l) === 40) {
    for (l++; l < g && (o = e.src.charCodeAt(l), !(!Cn(o) && o !== 10)); l++)
      ;
    if (l >= g)
      return !1;
    for (v = l, p = e.md.helpers.parseLinkDestination(e.src, l, e.posMax), p.ok && (A = e.md.normalizeLink(p.str), e.md.validateLink(A) ? l = p.pos : A = ""), v = l; l < g && (o = e.src.charCodeAt(l), !(!Cn(o) && o !== 10)); l++)
      ;
    if (p = e.md.helpers.parseLinkTitle(e.src, l, e.posMax), l < g && v !== l && p.ok)
      for (f = p.str, l = p.pos; l < g && (o = e.src.charCodeAt(l), !(!Cn(o) && o !== 10)); l++)
        ;
    else
      f = "";
    if (l >= g || e.src.charCodeAt(l) !== 41)
      return e.pos = y, !1;
    l++;
  } else {
    if (typeof e.env.references > "u")
      return !1;
    if (l < g && e.src.charCodeAt(l) === 91 ? (v = l + 1, l = e.md.helpers.parseLinkLabel(e, l), l >= 0 ? c = e.src.slice(v, l++) : l = i + 1) : l = i + 1, c || (c = e.src.slice(a, i)), u = e.env.references[N$(c)], !u)
      return e.pos = y, !1;
    A = u.href, f = u.title;
  }
  return t || (s = e.src.slice(a, i), e.md.inline.parse(
    s,
    e.md,
    e.env,
    k = []
  ), h = e.push("image", "img", 0), h.attrs = r = [["src", A], ["alt", ""]], h.children = k, h.content = s, f && r.push(["title", f])), e.pos = l, e.posMax = g, !0;
}, L$ = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, F$ = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/, I$ = function(e, t) {
  var r, o, s, c, i, a, l = e.pos;
  if (e.src.charCodeAt(l) !== 60)
    return !1;
  for (i = e.pos, a = e.posMax; ; ) {
    if (++l >= a || (c = e.src.charCodeAt(l), c === 60))
      return !1;
    if (c === 62)
      break;
  }
  return r = e.src.slice(i + 1, l), F$.test(r) ? (o = e.md.normalizeLink(r), e.md.validateLink(o) ? (t || (s = e.push("link_open", "a", 1), s.attrs = [["href", o]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(r), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += r.length + 2, !0) : !1) : L$.test(r) ? (o = e.md.normalizeLink("mailto:" + r), e.md.validateLink(o) ? (t || (s = e.push("link_open", "a", 1), s.attrs = [["href", o]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(r), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += r.length + 2, !0) : !1) : !1;
}, O$ = an.HTML_TAG_RE;
function B$(n) {
  var e = n | 32;
  return e >= 97 && e <= 122;
}
var P$ = function(e, t) {
  var r, o, s, c, i = e.pos;
  return !e.md.options.html || (s = e.posMax, e.src.charCodeAt(i) !== 60 || i + 2 >= s) || (r = e.src.charCodeAt(i + 1), r !== 33 && r !== 63 && r !== 47 && !B$(r)) || (o = e.src.slice(i).match(O$), !o) ? !1 : (t || (c = e.push("html_inline", "", 0), c.content = e.src.slice(i, i + o[0].length)), e.pos += o[0].length, !0);
}, Mt = ar, z$ = I.has, $$ = I.isValidEntityCode, Lt = I.fromCodePoint, U$ = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, V$ = /^&([a-z][a-z0-9]{1,31});/i, G$ = function(e, t) {
  var r, o, s, c = e.pos, i = e.posMax;
  if (e.src.charCodeAt(c) !== 38)
    return !1;
  if (c + 1 < i) {
    if (r = e.src.charCodeAt(c + 1), r === 35) {
      if (s = e.src.slice(c).match(U$), s)
        return t || (o = s[1][0].toLowerCase() === "x" ? parseInt(s[1].slice(1), 16) : parseInt(s[1], 10), e.pending += $$(o) ? Lt(o) : Lt(65533)), e.pos += s[0].length, !0;
    } else if (s = e.src.slice(c).match(V$), s && z$(Mt, s[1]))
      return t || (e.pending += Mt[s[1]]), e.pos += s[0].length, !0;
  }
  return t || (e.pending += "&"), e.pos++, !0;
};
function Ft(n, e) {
  var t, r, o, s, c, i, a, l, u = {}, p = e.length;
  if (p) {
    var f = 0, h = -2, k = [];
    for (t = 0; t < p; t++)
      if (o = e[t], k.push(0), (e[f].marker !== o.marker || h !== o.token - 1) && (f = t), h = o.token, o.length = o.length || 0, !!o.close) {
        for (u.hasOwnProperty(o.marker) || (u[o.marker] = [-1, -1, -1, -1, -1, -1]), c = u[o.marker][(o.open ? 3 : 0) + o.length % 3], r = f - k[f] - 1, i = r; r > c; r -= k[r] + 1)
          if (s = e[r], s.marker === o.marker && s.open && s.end < 0 && (a = !1, (s.close || o.open) && (s.length + o.length) % 3 === 0 && (s.length % 3 !== 0 || o.length % 3 !== 0) && (a = !0), !a)) {
            l = r > 0 && !e[r - 1].open ? k[r - 1] + 1 : 0, k[t] = t - r + l, k[r] = l, o.open = !1, s.end = t, s.close = !1, i = -1, h = -2;
            break;
          }
        i !== -1 && (u[o.marker][(o.open ? 3 : 0) + (o.length || 0) % 3] = i);
      }
  }
}
var H$ = function(e) {
  var t, r = e.tokens_meta, o = e.tokens_meta.length;
  for (Ft(e, e.delimiters), t = 0; t < o; t++)
    r[t] && r[t].delimiters && Ft(e, r[t].delimiters);
}, j$ = function(e) {
  var t, r, o = 0, s = e.tokens, c = e.tokens.length;
  for (t = r = 0; t < c; t++)
    s[t].nesting < 0 && o--, s[t].level = o, s[t].nesting > 0 && o++, s[t].type === "text" && t + 1 < c && s[t + 1].type === "text" ? s[t + 1].content = s[t].content + s[t + 1].content : (t !== r && (s[r] = s[t]), r++);
  t !== r && (s.length = r);
}, Vn = zn, It = I.isWhiteSpace, Ot = I.isPunctChar, Bt = I.isMdAsciiPunct;
function Ue(n, e, t, r) {
  this.src = n, this.env = t, this.md = e, this.tokens = r, this.tokens_meta = Array(r.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1;
}
Ue.prototype.pushPending = function() {
  var n = new Vn("text", "", 0);
  return n.content = this.pending, n.level = this.pendingLevel, this.tokens.push(n), this.pending = "", n;
};
Ue.prototype.push = function(n, e, t) {
  this.pending && this.pushPending();
  var r = new Vn(n, e, t), o = null;
  return t < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), r.level = this.level, t > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], o = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(r), this.tokens_meta.push(o), r;
};
Ue.prototype.scanDelims = function(n, e) {
  var t = n, r, o, s, c, i, a, l, u, p, f = !0, h = !0, k = this.posMax, v = this.src.charCodeAt(n);
  for (r = n > 0 ? this.src.charCodeAt(n - 1) : 32; t < k && this.src.charCodeAt(t) === v; )
    t++;
  return s = t - n, o = t < k ? this.src.charCodeAt(t) : 32, l = Bt(r) || Ot(String.fromCharCode(r)), p = Bt(o) || Ot(String.fromCharCode(o)), a = It(r), u = It(o), u ? f = !1 : p && (a || l || (f = !1)), a ? h = !1 : l && (u || p || (h = !1)), e ? (c = f, i = h) : (c = f && (!h || l), i = h && (!f || p)), {
    can_open: c,
    can_close: i,
    length: s
  };
};
Ue.prototype.Token = Vn;
var Z$ = Ue, Pt = Pn, Sn = [
  ["text", E$],
  ["newline", C$],
  ["escape", D$],
  ["backticks", q$],
  ["strikethrough", fn.tokenize],
  ["emphasis", pn.tokenize],
  ["link", R$],
  ["image", M$],
  ["autolink", I$],
  ["html_inline", P$],
  ["entity", G$]
], Dn = [
  ["balance_pairs", H$],
  ["strikethrough", fn.postProcess],
  ["emphasis", pn.postProcess],
  ["text_collapse", j$]
];
function Ve() {
  var n;
  for (this.ruler = new Pt(), n = 0; n < Sn.length; n++)
    this.ruler.push(Sn[n][0], Sn[n][1]);
  for (this.ruler2 = new Pt(), n = 0; n < Dn.length; n++)
    this.ruler2.push(Dn[n][0], Dn[n][1]);
}
Ve.prototype.skipToken = function(n) {
  var e, t, r = n.pos, o = this.ruler.getRules(""), s = o.length, c = n.md.options.maxNesting, i = n.cache;
  if (typeof i[r] < "u") {
    n.pos = i[r];
    return;
  }
  if (n.level < c)
    for (t = 0; t < s && (n.level++, e = o[t](n, !0), n.level--, !e); t++)
      ;
  else
    n.pos = n.posMax;
  e || n.pos++, i[r] = n.pos;
};
Ve.prototype.tokenize = function(n) {
  for (var e, t, r = this.ruler.getRules(""), o = r.length, s = n.posMax, c = n.md.options.maxNesting; n.pos < s; ) {
    if (n.level < c)
      for (t = 0; t < o && (e = r[t](n, !1), !e); t++)
        ;
    if (e) {
      if (n.pos >= s)
        break;
      continue;
    }
    n.pending += n.src[n.pos++];
  }
  n.pending && n.pushPending();
};
Ve.prototype.parse = function(n, e, t, r) {
  var o, s, c, i = new this.State(n, e, t, r);
  for (this.tokenize(i), s = this.ruler2.getRules(""), c = s.length, o = 0; o < c; o++)
    s[o](i);
};
Ve.prototype.State = Z$;
var W$ = Ve, qn, zt;
function K$() {
  return zt || (zt = 1, qn = function(n) {
    var e = {};
    e.src_Any = lr().source, e.src_Cc = ur().source, e.src_Z = fr().source, e.src_P = Bn.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
    var t = "[><｜]";
    return e.src_pseudo_letter = "(?:(?!" + t + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + t + "|" + e.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + t + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]).|" + (n && n["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + e.src_ZCc + ").|;(?!" + e.src_ZCc + ").|\\!+(?!" + e.src_ZCc + "|[!]).|\\?(?!" + e.src_ZCc + "|[?]).)+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = // Allow letters & digits (http://test1)
    "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + t + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
  }), qn;
}
function Ln(n) {
  var e = Array.prototype.slice.call(arguments, 1);
  return e.forEach(function(t) {
    t && Object.keys(t).forEach(function(r) {
      n[r] = t[r];
    });
  }), n;
}
function hn(n) {
  return Object.prototype.toString.call(n);
}
function J$(n) {
  return hn(n) === "[object String]";
}
function Y$(n) {
  return hn(n) === "[object Object]";
}
function X$(n) {
  return hn(n) === "[object RegExp]";
}
function $t(n) {
  return hn(n) === "[object Function]";
}
function Q$(n) {
  return n.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var br = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function eU(n) {
  return Object.keys(n || {}).reduce(function(e, t) {
    return e || br.hasOwnProperty(t);
  }, !1);
}
var nU = {
  "http:": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.http || (t.re.http = new RegExp(
        "^\\/\\/" + t.re.src_auth + t.re.src_host_port_strict + t.re.src_path,
        "i"
      )), t.re.http.test(r) ? r.match(t.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.no_http || (t.re.no_http = new RegExp(
        "^" + t.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + t.re.src_domain + ")\\.)+" + t.re.src_domain_root + ")" + t.re.src_port + t.re.src_host_terminator + t.re.src_path,
        "i"
      )), t.re.no_http.test(r) ? e >= 3 && n[e - 3] === ":" || e >= 3 && n[e - 3] === "/" ? 0 : r.match(t.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.mailto || (t.re.mailto = new RegExp(
        "^" + t.re.src_email_name + "@" + t.re.src_host_strict,
        "i"
      )), t.re.mailto.test(r) ? r.match(t.re.mailto)[0].length : 0;
    }
  }
}, tU = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", rU = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
function oU(n) {
  n.__index__ = -1, n.__text_cache__ = "";
}
function sU(n) {
  return function(e, t) {
    var r = e.slice(t);
    return n.test(r) ? r.match(n)[0].length : 0;
  };
}
function Ut() {
  return function(n, e) {
    e.normalize(n);
  };
}
function en(n) {
  var e = n.re = K$()(n.__opts__), t = n.__tlds__.slice();
  n.onCompile(), n.__tlds_replaced__ || t.push(tU), t.push(e.src_xn), e.src_tlds = t.join("|");
  function r(i) {
    return i.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(r(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(r(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(r(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(r(e.tpl_host_fuzzy_test), "i");
  var o = [];
  n.__compiled__ = {};
  function s(i, a) {
    throw new Error('(LinkifyIt) Invalid schema "' + i + '": ' + a);
  }
  Object.keys(n.__schemas__).forEach(function(i) {
    var a = n.__schemas__[i];
    if (a !== null) {
      var l = { validate: null, link: null };
      if (n.__compiled__[i] = l, Y$(a)) {
        X$(a.validate) ? l.validate = sU(a.validate) : $t(a.validate) ? l.validate = a.validate : s(i, a), $t(a.normalize) ? l.normalize = a.normalize : a.normalize ? s(i, a) : l.normalize = Ut();
        return;
      }
      if (J$(a)) {
        o.push(i);
        return;
      }
      s(i, a);
    }
  }), o.forEach(function(i) {
    n.__compiled__[n.__schemas__[i]] && (n.__compiled__[i].validate = n.__compiled__[n.__schemas__[i]].validate, n.__compiled__[i].normalize = n.__compiled__[n.__schemas__[i]].normalize);
  }), n.__compiled__[""] = { validate: null, normalize: Ut() };
  var c = Object.keys(n.__compiled__).filter(function(i) {
    return i.length > 0 && n.__compiled__[i];
  }).map(Q$).join("|");
  n.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + c + ")", "i"), n.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + c + ")", "ig"), n.re.pretest = RegExp(
    "(" + n.re.schema_test.source + ")|(" + n.re.host_fuzzy_test.source + ")|@",
    "i"
  ), oU(n);
}
function cU(n, e) {
  var t = n.__index__, r = n.__last_index__, o = n.__text_cache__.slice(t, r);
  this.schema = n.__schema__.toLowerCase(), this.index = t + e, this.lastIndex = r + e, this.raw = o, this.text = o, this.url = o;
}
function Vt(n, e) {
  var t = new cU(n, e);
  return n.__compiled__[t.schema].normalize(t, n), t;
}
function Q(n, e) {
  if (!(this instanceof Q))
    return new Q(n, e);
  e || eU(n) && (e = n, n = {}), this.__opts__ = Ln({}, br, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = Ln({}, nU, n), this.__compiled__ = {}, this.__tlds__ = rU, this.__tlds_replaced__ = !1, this.re = {}, en(this);
}
Q.prototype.add = function(e, t) {
  return this.__schemas__[e] = t, en(this), this;
};
Q.prototype.set = function(e) {
  return this.__opts__ = Ln(this.__opts__, e), this;
};
Q.prototype.test = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return !1;
  var t, r, o, s, c, i, a, l, u;
  if (this.re.schema_test.test(e)) {
    for (a = this.re.schema_search, a.lastIndex = 0; (t = a.exec(e)) !== null; )
      if (s = this.testSchemaAt(e, t[2], a.lastIndex), s) {
        this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + s;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (l = e.search(this.re.host_fuzzy_test), l >= 0 && (this.__index__ < 0 || l < this.__index__) && (r = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (c = r.index + r[1].length, (this.__index__ < 0 || c < this.__index__) && (this.__schema__ = "", this.__index__ = c, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (u = e.indexOf("@"), u >= 0 && (o = e.match(this.re.email_fuzzy)) !== null && (c = o.index + o[1].length, i = o.index + o[0].length, (this.__index__ < 0 || c < this.__index__ || c === this.__index__ && i > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = c, this.__last_index__ = i))), this.__index__ >= 0;
};
Q.prototype.pretest = function(e) {
  return this.re.pretest.test(e);
};
Q.prototype.testSchemaAt = function(e, t, r) {
  return this.__compiled__[t.toLowerCase()] ? this.__compiled__[t.toLowerCase()].validate(e, r, this) : 0;
};
Q.prototype.match = function(e) {
  var t = 0, r = [];
  this.__index__ >= 0 && this.__text_cache__ === e && (r.push(Vt(this, t)), t = this.__last_index__);
  for (var o = t ? e.slice(t) : e; this.test(o); )
    r.push(Vt(this, t)), o = o.slice(this.__last_index__), t += this.__last_index__;
  return r.length ? r : null;
};
Q.prototype.tlds = function(e, t) {
  return e = Array.isArray(e) ? e : [e], t ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter(function(r, o, s) {
    return r !== s[o - 1];
  }).reverse(), en(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = !0, en(this), this);
};
Q.prototype.normalize = function(e) {
  e.schema || (e.url = "http://" + e.url), e.schema === "mailto:" && !/^mailto:/i.test(e.url) && (e.url = "mailto:" + e.url);
};
Q.prototype.onCompile = function() {
};
var iU = Q;
const Se = 2147483647, ie = 36, Gn = 1, Be = 26, aU = 38, lU = 700, vr = 72, kr = 128, xr = "-", uU = /^xn--/, fU = /[^\0-\x7E]/, pU = /[\x2E\u3002\uFF0E\uFF61]/g, hU = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, Tn = ie - Gn, ae = Math.floor, Rn = String.fromCharCode;
function me(n) {
  throw new RangeError(hU[n]);
}
function dU(n, e) {
  const t = [];
  let r = n.length;
  for (; r--; )
    t[r] = e(n[r]);
  return t;
}
function yr(n, e) {
  const t = n.split("@");
  let r = "";
  t.length > 1 && (r = t[0] + "@", n = t[1]), n = n.replace(pU, ".");
  const o = n.split("."), s = dU(o, e).join(".");
  return r + s;
}
function Hn(n) {
  const e = [];
  let t = 0;
  const r = n.length;
  for (; t < r; ) {
    const o = n.charCodeAt(t++);
    if (o >= 55296 && o <= 56319 && t < r) {
      const s = n.charCodeAt(t++);
      (s & 64512) == 56320 ? e.push(((o & 1023) << 10) + (s & 1023) + 65536) : (e.push(o), t--);
    } else
      e.push(o);
  }
  return e;
}
const wr = (n) => String.fromCodePoint(...n), gU = function(n) {
  return n - 48 < 10 ? n - 22 : n - 65 < 26 ? n - 65 : n - 97 < 26 ? n - 97 : ie;
}, Gt = function(n, e) {
  return n + 22 + 75 * (n < 26) - ((e != 0) << 5);
}, Er = function(n, e, t) {
  let r = 0;
  for (n = t ? ae(n / lU) : n >> 1, n += ae(n / e); n > Tn * Be >> 1; r += ie)
    n = ae(n / Tn);
  return ae(r + (Tn + 1) * n / (n + aU));
}, jn = function(n) {
  const e = [], t = n.length;
  let r = 0, o = kr, s = vr, c = n.lastIndexOf(xr);
  c < 0 && (c = 0);
  for (let i = 0; i < c; ++i)
    n.charCodeAt(i) >= 128 && me("not-basic"), e.push(n.charCodeAt(i));
  for (let i = c > 0 ? c + 1 : 0; i < t; ) {
    let a = r;
    for (let u = 1, p = ie; ; p += ie) {
      i >= t && me("invalid-input");
      const f = gU(n.charCodeAt(i++));
      (f >= ie || f > ae((Se - r) / u)) && me("overflow"), r += f * u;
      const h = p <= s ? Gn : p >= s + Be ? Be : p - s;
      if (f < h)
        break;
      const k = ie - h;
      u > ae(Se / k) && me("overflow"), u *= k;
    }
    const l = e.length + 1;
    s = Er(r - a, l, a == 0), ae(r / l) > Se - o && me("overflow"), o += ae(r / l), r %= l, e.splice(r++, 0, o);
  }
  return String.fromCodePoint(...e);
}, Zn = function(n) {
  const e = [];
  n = Hn(n);
  let t = n.length, r = kr, o = 0, s = vr;
  for (const a of n)
    a < 128 && e.push(Rn(a));
  let c = e.length, i = c;
  for (c && e.push(xr); i < t; ) {
    let a = Se;
    for (const u of n)
      u >= r && u < a && (a = u);
    const l = i + 1;
    a - r > ae((Se - o) / l) && me("overflow"), o += (a - r) * l, r = a;
    for (const u of n)
      if (u < r && ++o > Se && me("overflow"), u === r) {
        let p = o;
        for (let f = ie; ; f += ie) {
          const h = f <= s ? Gn : f >= s + Be ? Be : f - s;
          if (p < h)
            break;
          const k = p - h, v = ie - h;
          e.push(
            Rn(Gt(h + k % v, 0))
          ), p = ae(k / v);
        }
        e.push(Rn(Gt(p, 0))), s = Er(o, l, i === c), o = 0, ++i;
      }
    ++o, ++r;
  }
  return e.join("");
}, Ar = function(n) {
  return yr(n, function(e) {
    return uU.test(e) ? jn(e.slice(4).toLowerCase()) : e;
  });
}, Cr = function(n) {
  return yr(n, function(e) {
    return fU.test(e) ? "xn--" + Zn(e) : e;
  });
}, mU = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.1.0",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: Hn,
    encode: wr
  },
  decode: jn,
  encode: Zn,
  toASCII: Cr,
  toUnicode: Ar
}, _U = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: jn,
  default: mU,
  encode: Zn,
  toASCII: Cr,
  toUnicode: Ar,
  ucs2decode: Hn,
  ucs2encode: wr
}, Symbol.toStringTag, { value: "Module" })), bU = /* @__PURE__ */ No(_U);
var vU = {
  options: {
    html: !1,
    // Enable HTML tags in source
    xhtmlOut: !1,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 100
    // Internal protection, recursion limit
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, kU = {
  options: {
    html: !1,
    // Enable HTML tags in source
    xhtmlOut: !1,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "text_collapse"
      ]
    }
  }
}, xU = {
  options: {
    html: !0,
    // Enable HTML tags in source
    xhtmlOut: !0,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "text_collapse"
      ]
    }
  }
}, Ie = I, yU = cn, wU = x3, EU = G3, AU = y$, CU = W$, SU = iU, _e = qe, Sr = bU, DU = {
  default: vU,
  zero: kU,
  commonmark: xU
}, qU = /^(vbscript|javascript|file|data):/, TU = /^data:image\/(gif|png|jpeg|webp);/;
function RU(n) {
  var e = n.trim().toLowerCase();
  return qU.test(e) ? !!TU.test(e) : !0;
}
var Dr = ["http:", "https:", "mailto:"];
function NU(n) {
  var e = _e.parse(n, !0);
  if (e.hostname && (!e.protocol || Dr.indexOf(e.protocol) >= 0))
    try {
      e.hostname = Sr.toASCII(e.hostname);
    } catch {
    }
  return _e.encode(_e.format(e));
}
function MU(n) {
  var e = _e.parse(n, !0);
  if (e.hostname && (!e.protocol || Dr.indexOf(e.protocol) >= 0))
    try {
      e.hostname = Sr.toUnicode(e.hostname);
    } catch {
    }
  return _e.decode(_e.format(e), _e.decode.defaultChars + "%");
}
function ee(n, e) {
  if (!(this instanceof ee))
    return new ee(n, e);
  e || Ie.isString(n) || (e = n || {}, n = "default"), this.inline = new CU(), this.block = new AU(), this.core = new EU(), this.renderer = new wU(), this.linkify = new SU(), this.validateLink = RU, this.normalizeLink = NU, this.normalizeLinkText = MU, this.utils = Ie, this.helpers = Ie.assign({}, yU), this.options = {}, this.configure(n), e && this.set(e);
}
ee.prototype.set = function(n) {
  return Ie.assign(this.options, n), this;
};
ee.prototype.configure = function(n) {
  var e = this, t;
  if (Ie.isString(n) && (t = n, n = DU[t], !n))
    throw new Error('Wrong `markdown-it` preset "' + t + '", check name');
  if (!n)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return n.options && e.set(n.options), n.components && Object.keys(n.components).forEach(function(r) {
    n.components[r].rules && e[r].ruler.enableOnly(n.components[r].rules), n.components[r].rules2 && e[r].ruler2.enableOnly(n.components[r].rules2);
  }), this;
};
ee.prototype.enable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(o) {
    t = t.concat(this[o].ruler.enable(n, !0));
  }, this), t = t.concat(this.inline.ruler2.enable(n, !0));
  var r = n.filter(function(o) {
    return t.indexOf(o) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + r);
  return this;
};
ee.prototype.disable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(o) {
    t = t.concat(this[o].ruler.disable(n, !0));
  }, this), t = t.concat(this.inline.ruler2.disable(n, !0));
  var r = n.filter(function(o) {
    return t.indexOf(o) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + r);
  return this;
};
ee.prototype.use = function(n) {
  var e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return n.apply(n, e), this;
};
ee.prototype.parse = function(n, e) {
  if (typeof n != "string")
    throw new Error("Input data should be a String");
  var t = new this.core.State(n, this, e);
  return this.core.process(t), t.tokens;
};
ee.prototype.render = function(n, e) {
  return e = e || {}, this.renderer.render(this.parse(n, e), this.options, e);
};
ee.prototype.parseInline = function(n, e) {
  var t = new this.core.State(n, this, e);
  return t.inlineMode = !0, this.core.process(t), t.tokens;
};
ee.prototype.renderInline = function(n, e) {
  return e = e || {}, this.renderer.render(this.parseInline(n, e), this.options, e);
};
var LU = ee, FU = LU;
const IU = /* @__PURE__ */ ir(FU);
var OU = te({
  name: "VueMarkdown",
  props: {
    source: {
      type: String,
      required: !0
    },
    options: {
      type: Object,
      required: !1
    }
  },
  data: function() {
    return {
      md: null
    };
  },
  computed: {
    content: function() {
      var n, e = this.source;
      return (n = this.md) === null || n === void 0 ? void 0 : n.render(e);
    }
  },
  created: function() {
    var n;
    this.md = new IU((n = this.options) !== null && n !== void 0 ? n : {});
  },
  render: function() {
    return to("div", { innerHTML: this.content });
  }
});
const BU = OU;
function qr(n) {
  return n instanceof Map ? n.clear = n.delete = n.set = function() {
    throw new Error("map is read-only");
  } : n instanceof Set && (n.add = n.clear = n.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(n), Object.getOwnPropertyNames(n).forEach((e) => {
    const t = n[e], r = typeof t;
    (r === "object" || r === "function") && !Object.isFrozen(t) && qr(t);
  }), n;
}
class Ht {
  /**
   * @param {CompiledMode} mode
   */
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
}
function Tr(n) {
  return n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function he(n, ...e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const r in n)
    t[r] = n[r];
  return e.forEach(function(r) {
    for (const o in r)
      t[o] = r[o];
  }), /** @type {T} */
  t;
}
const PU = "</span>", jt = (n) => !!n.scope, zU = (n, { prefix: e }) => {
  if (n.startsWith("language:"))
    return n.replace("language:", "language-");
  if (n.includes(".")) {
    const t = n.split(".");
    return [
      `${e}${t.shift()}`,
      ...t.map((r, o) => `${r}${"_".repeat(o + 1)}`)
    ].join(" ");
  }
  return `${e}${n}`;
};
class $U {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(e, t) {
    this.buffer = "", this.classPrefix = t.classPrefix, e.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(e) {
    this.buffer += Tr(e);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(e) {
    if (!jt(e))
      return;
    const t = zU(
      e.scope,
      { prefix: this.classPrefix }
    );
    this.span(t);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(e) {
    jt(e) && (this.buffer += PU);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
}
const Zt = (n = {}) => {
  const e = { children: [] };
  return Object.assign(e, n), e;
};
class Wn {
  constructor() {
    this.rootNode = Zt(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(e) {
    this.top.children.push(e);
  }
  /** @param {string} scope */
  openNode(e) {
    const t = Zt({ scope: e });
    this.add(t), this.stack.push(t);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); )
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(e, t) {
    return typeof t == "string" ? e.addText(t) : t.children && (e.openNode(t), t.children.forEach((r) => this._walk(e, r)), e.closeNode(t)), e;
  }
  /**
   * @param {Node} node
   */
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((t) => typeof t == "string") ? e.children = [e.children.join("")] : e.children.forEach((t) => {
      Wn._collapse(t);
    }));
  }
}
class UU extends Wn {
  /**
   * @param {*} options
   */
  constructor(e) {
    super(), this.options = e;
  }
  /**
   * @param {string} text
   */
  addText(e) {
    e !== "" && this.add(e);
  }
  /** @param {string} scope */
  startScope(e) {
    this.openNode(e);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(e, t) {
    const r = e.root;
    t && (r.scope = `language:${t}`), this.add(r);
  }
  toHTML() {
    return new $U(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), !0;
  }
}
function Pe(n) {
  return n ? typeof n == "string" ? n : n.source : null;
}
function Rr(n) {
  return we("(?=", n, ")");
}
function VU(n) {
  return we("(?:", n, ")*");
}
function GU(n) {
  return we("(?:", n, ")?");
}
function we(...n) {
  return n.map((t) => Pe(t)).join("");
}
function HU(n) {
  const e = n[n.length - 1];
  return typeof e == "object" && e.constructor === Object ? (n.splice(n.length - 1, 1), e) : {};
}
function Kn(...n) {
  return "(" + (HU(n).capture ? "" : "?:") + n.map((r) => Pe(r)).join("|") + ")";
}
function Nr(n) {
  return new RegExp(n.toString() + "|").exec("").length - 1;
}
function jU(n, e) {
  const t = n && n.exec(e);
  return t && t.index === 0;
}
const ZU = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function Jn(n, { joinWith: e }) {
  let t = 0;
  return n.map((r) => {
    t += 1;
    const o = t;
    let s = Pe(r), c = "";
    for (; s.length > 0; ) {
      const i = ZU.exec(s);
      if (!i) {
        c += s;
        break;
      }
      c += s.substring(0, i.index), s = s.substring(i.index + i[0].length), i[0][0] === "\\" && i[1] ? c += "\\" + String(Number(i[1]) + o) : (c += i[0], i[0] === "(" && t++);
    }
    return c;
  }).map((r) => `(${r})`).join(e);
}
const WU = /\b\B/, Mr = "[a-zA-Z]\\w*", Yn = "[a-zA-Z_]\\w*", Lr = "\\b\\d+(\\.\\d+)?", Fr = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", Ir = "\\b(0b[01]+)", KU = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", JU = (n = {}) => {
  const e = /^#![ ]*\//;
  return n.binary && (n.begin = we(
    e,
    /.*\b/,
    n.binary,
    /\b.*/
  )), he({
    scope: "meta",
    begin: e,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (t, r) => {
      t.index !== 0 && r.ignoreMatch();
    }
  }, n);
}, ze = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, YU = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [ze]
}, XU = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [ze]
}, QU = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, dn = function(n, e, t = {}) {
  const r = he(
    {
      scope: "comment",
      begin: n,
      end: e,
      contains: []
    },
    t
  );
  r.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const o = Kn(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return r.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: we(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        o,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), r;
}, e8 = dn("//", "$"), n8 = dn("/\\*", "\\*/"), t8 = dn("#", "$"), r8 = {
  scope: "number",
  begin: Lr,
  relevance: 0
}, o8 = {
  scope: "number",
  begin: Fr,
  relevance: 0
}, s8 = {
  scope: "number",
  begin: Ir,
  relevance: 0
}, c8 = {
  // this outer rule makes sure we actually have a WHOLE regex and not simply
  // an expression such as:
  //
  //     3 / something
  //
  // (which will then blow up when regex's `illegal` sees the newline)
  begin: /(?=\/[^/\n]*\/)/,
  contains: [{
    scope: "regexp",
    begin: /\//,
    end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
      ze,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [ze]
      }
    ]
  }]
}, i8 = {
  scope: "title",
  begin: Mr,
  relevance: 0
}, a8 = {
  scope: "title",
  begin: Yn,
  relevance: 0
}, l8 = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + Yn,
  relevance: 0
}, u8 = function(n) {
  return Object.assign(
    n,
    {
      /** @type {ModeCallback} */
      "on:begin": (e, t) => {
        t.data._beginMatch = e[1];
      },
      /** @type {ModeCallback} */
      "on:end": (e, t) => {
        t.data._beginMatch !== e[1] && t.ignoreMatch();
      }
    }
  );
};
var Je = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MATCH_NOTHING_RE: WU,
  IDENT_RE: Mr,
  UNDERSCORE_IDENT_RE: Yn,
  NUMBER_RE: Lr,
  C_NUMBER_RE: Fr,
  BINARY_NUMBER_RE: Ir,
  RE_STARTERS_RE: KU,
  SHEBANG: JU,
  BACKSLASH_ESCAPE: ze,
  APOS_STRING_MODE: YU,
  QUOTE_STRING_MODE: XU,
  PHRASAL_WORDS_MODE: QU,
  COMMENT: dn,
  C_LINE_COMMENT_MODE: e8,
  C_BLOCK_COMMENT_MODE: n8,
  HASH_COMMENT_MODE: t8,
  NUMBER_MODE: r8,
  C_NUMBER_MODE: o8,
  BINARY_NUMBER_MODE: s8,
  REGEXP_MODE: c8,
  TITLE_MODE: i8,
  UNDERSCORE_TITLE_MODE: a8,
  METHOD_GUARD: l8,
  END_SAME_AS_BEGIN: u8
});
function f8(n, e) {
  n.input[n.index - 1] === "." && e.ignoreMatch();
}
function p8(n, e) {
  n.className !== void 0 && (n.scope = n.className, delete n.className);
}
function h8(n, e) {
  e && n.beginKeywords && (n.begin = "\\b(" + n.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", n.__beforeBegin = f8, n.keywords = n.keywords || n.beginKeywords, delete n.beginKeywords, n.relevance === void 0 && (n.relevance = 0));
}
function d8(n, e) {
  Array.isArray(n.illegal) && (n.illegal = Kn(...n.illegal));
}
function g8(n, e) {
  if (n.match) {
    if (n.begin || n.end)
      throw new Error("begin & end are not supported with match");
    n.begin = n.match, delete n.match;
  }
}
function m8(n, e) {
  n.relevance === void 0 && (n.relevance = 1);
}
const _8 = (n, e) => {
  if (!n.beforeMatch)
    return;
  if (n.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const t = Object.assign({}, n);
  Object.keys(n).forEach((r) => {
    delete n[r];
  }), n.keywords = t.keywords, n.begin = we(t.beforeMatch, Rr(t.begin)), n.starts = {
    relevance: 0,
    contains: [
      Object.assign(t, { endsParent: !0 })
    ]
  }, n.relevance = 0, delete t.beforeMatch;
}, b8 = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], v8 = "keyword";
function Or(n, e, t = v8) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof n == "string" ? o(t, n.split(" ")) : Array.isArray(n) ? o(t, n) : Object.keys(n).forEach(function(s) {
    Object.assign(
      r,
      Or(n[s], e, s)
    );
  }), r;
  function o(s, c) {
    e && (c = c.map((i) => i.toLowerCase())), c.forEach(function(i) {
      const a = i.split("|");
      r[a[0]] = [s, k8(a[0], a[1])];
    });
  }
}
function k8(n, e) {
  return e ? Number(e) : x8(n) ? 0 : 1;
}
function x8(n) {
  return b8.includes(n.toLowerCase());
}
const Wt = {}, ke = (n) => {
  console.error(n);
}, Kt = (n, ...e) => {
  console.log(`WARN: ${n}`, ...e);
}, Ae = (n, e) => {
  Wt[`${n}/${e}`] || (console.log(`Deprecated as of ${n}. ${e}`), Wt[`${n}/${e}`] = !0);
}, nn = new Error();
function Br(n, e, { key: t }) {
  let r = 0;
  const o = n[t], s = {}, c = {};
  for (let i = 1; i <= e.length; i++)
    c[i + r] = o[i], s[i + r] = !0, r += Nr(e[i - 1]);
  n[t] = c, n[t]._emit = s, n[t]._multi = !0;
}
function y8(n) {
  if (Array.isArray(n.begin)) {
    if (n.skip || n.excludeBegin || n.returnBegin)
      throw ke("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), nn;
    if (typeof n.beginScope != "object" || n.beginScope === null)
      throw ke("beginScope must be object"), nn;
    Br(n, n.begin, { key: "beginScope" }), n.begin = Jn(n.begin, { joinWith: "" });
  }
}
function w8(n) {
  if (Array.isArray(n.end)) {
    if (n.skip || n.excludeEnd || n.returnEnd)
      throw ke("skip, excludeEnd, returnEnd not compatible with endScope: {}"), nn;
    if (typeof n.endScope != "object" || n.endScope === null)
      throw ke("endScope must be object"), nn;
    Br(n, n.end, { key: "endScope" }), n.end = Jn(n.end, { joinWith: "" });
  }
}
function E8(n) {
  n.scope && typeof n.scope == "object" && n.scope !== null && (n.beginScope = n.scope, delete n.scope);
}
function A8(n) {
  E8(n), typeof n.beginScope == "string" && (n.beginScope = { _wrap: n.beginScope }), typeof n.endScope == "string" && (n.endScope = { _wrap: n.endScope }), y8(n), w8(n);
}
function C8(n) {
  function e(c, i) {
    return new RegExp(
      Pe(c),
      "m" + (n.case_insensitive ? "i" : "") + (n.unicodeRegex ? "u" : "") + (i ? "g" : "")
    );
  }
  class t {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(i, a) {
      a.position = this.position++, this.matchIndexes[this.matchAt] = a, this.regexes.push([a, i]), this.matchAt += Nr(i) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const i = this.regexes.map((a) => a[1]);
      this.matcherRe = e(Jn(i, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(i) {
      this.matcherRe.lastIndex = this.lastIndex;
      const a = this.matcherRe.exec(i);
      if (!a)
        return null;
      const l = a.findIndex((p, f) => f > 0 && p !== void 0), u = this.matchIndexes[l];
      return a.splice(0, l), Object.assign(a, u);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(i) {
      if (this.multiRegexes[i])
        return this.multiRegexes[i];
      const a = new t();
      return this.rules.slice(i).forEach(([l, u]) => a.addRule(l, u)), a.compile(), this.multiRegexes[i] = a, a;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(i, a) {
      this.rules.push([i, a]), a.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(i) {
      const a = this.getMatcher(this.regexIndex);
      a.lastIndex = this.lastIndex;
      let l = a.exec(i);
      if (this.resumingScanAtSamePosition() && !(l && l.index === this.lastIndex)) {
        const u = this.getMatcher(0);
        u.lastIndex = this.lastIndex + 1, l = u.exec(i);
      }
      return l && (this.regexIndex += l.position + 1, this.regexIndex === this.count && this.considerAll()), l;
    }
  }
  function o(c) {
    const i = new r();
    return c.contains.forEach((a) => i.addRule(a.begin, { rule: a, type: "begin" })), c.terminatorEnd && i.addRule(c.terminatorEnd, { type: "end" }), c.illegal && i.addRule(c.illegal, { type: "illegal" }), i;
  }
  function s(c, i) {
    const a = (
      /** @type CompiledMode */
      c
    );
    if (c.isCompiled)
      return a;
    [
      p8,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      g8,
      A8,
      _8
    ].forEach((u) => u(c, i)), n.compilerExtensions.forEach((u) => u(c, i)), c.__beforeBegin = null, [
      h8,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      d8,
      // default to 1 relevance if not specified
      m8
    ].forEach((u) => u(c, i)), c.isCompiled = !0;
    let l = null;
    return typeof c.keywords == "object" && c.keywords.$pattern && (c.keywords = Object.assign({}, c.keywords), l = c.keywords.$pattern, delete c.keywords.$pattern), l = l || /\w+/, c.keywords && (c.keywords = Or(c.keywords, n.case_insensitive)), a.keywordPatternRe = e(l, !0), i && (c.begin || (c.begin = /\B|\b/), a.beginRe = e(a.begin), !c.end && !c.endsWithParent && (c.end = /\B|\b/), c.end && (a.endRe = e(a.end)), a.terminatorEnd = Pe(a.end) || "", c.endsWithParent && i.terminatorEnd && (a.terminatorEnd += (c.end ? "|" : "") + i.terminatorEnd)), c.illegal && (a.illegalRe = e(
      /** @type {RegExp | string} */
      c.illegal
    )), c.contains || (c.contains = []), c.contains = [].concat(...c.contains.map(function(u) {
      return S8(u === "self" ? c : u);
    })), c.contains.forEach(function(u) {
      s(
        /** @type Mode */
        u,
        a
      );
    }), c.starts && s(c.starts, i), a.matcher = o(a), a;
  }
  if (n.compilerExtensions || (n.compilerExtensions = []), n.contains && n.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return n.classNameAliases = he(n.classNameAliases || {}), s(
    /** @type Mode */
    n
  );
}
function Pr(n) {
  return n ? n.endsWithParent || Pr(n.starts) : !1;
}
function S8(n) {
  return n.variants && !n.cachedVariants && (n.cachedVariants = n.variants.map(function(e) {
    return he(n, { variants: null }, e);
  })), n.cachedVariants ? n.cachedVariants : Pr(n) ? he(n, { starts: n.starts ? he(n.starts) : null }) : Object.isFrozen(n) ? he(n) : n;
}
var D8 = "11.8.0";
class q8 extends Error {
  constructor(e, t) {
    super(e), this.name = "HTMLInjectionError", this.html = t;
  }
}
const Nn = Tr, Jt = he, Yt = Symbol("nomatch"), T8 = 7, zr = function(n) {
  const e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null), r = [];
  let o = !0;
  const s = "Could not find the language '{}', did you forget to load/include a language module?", c = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let i = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: UU
  };
  function a(d) {
    return i.noHighlightRe.test(d);
  }
  function l(d) {
    let x = d.className + " ";
    x += d.parentNode ? d.parentNode.className : "";
    const D = i.languageDetectRe.exec(x);
    if (D) {
      const L = H(D[1]);
      return L || (Kt(s.replace("{}", D[1])), Kt("Falling back to no-highlight mode for this block.", d)), L ? D[1] : "no-highlight";
    }
    return x.split(/\s+/).find((L) => a(L) || H(L));
  }
  function u(d, x, D) {
    let L = "", U = "";
    typeof x == "object" ? (L = d, D = x.ignoreIllegals, U = x.language) : (Ae("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Ae("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), U = d, L = x), D === void 0 && (D = !0);
    const K = {
      code: L,
      language: U
    };
    O("before:highlight", K);
    const ne = K.result ? K.result : p(K.language, K.code, D);
    return ne.code = K.code, O("after:highlight", ne), ne;
  }
  function p(d, x, D, L) {
    const U = /* @__PURE__ */ Object.create(null);
    function K(b, E) {
      return b.keywords[E];
    }
    function ne() {
      if (!S.keywords) {
        j.addText(z);
        return;
      }
      let b = 0;
      S.keywordPatternRe.lastIndex = 0;
      let E = S.keywordPatternRe.exec(z), T = "";
      for (; E; ) {
        T += z.substring(b, E.index);
        const B = ce.case_insensitive ? E[0].toLowerCase() : E[0], W = K(S, B);
        if (W) {
          const [pe, Qr] = W;
          if (j.addText(T), T = "", U[B] = (U[B] || 0) + 1, U[B] <= T8 && (je += Qr), pe.startsWith("_"))
            T += E[0];
          else {
            const eo = ce.classNameAliases[pe] || pe;
            se(E[0], eo);
          }
        } else
          T += E[0];
        b = S.keywordPatternRe.lastIndex, E = S.keywordPatternRe.exec(z);
      }
      T += z.substring(b), j.addText(T);
    }
    function Ge() {
      if (z === "")
        return;
      let b = null;
      if (typeof S.subLanguage == "string") {
        if (!e[S.subLanguage]) {
          j.addText(z);
          return;
        }
        b = p(S.subLanguage, z, !0, tt[S.subLanguage]), tt[S.subLanguage] = /** @type {CompiledMode} */
        b._top;
      } else
        b = h(z, S.subLanguage.length ? S.subLanguage : null);
      S.relevance > 0 && (je += b.relevance), j.__addSublanguage(b._emitter, b.language);
    }
    function Y() {
      S.subLanguage != null ? Ge() : ne(), z = "";
    }
    function se(b, E) {
      b !== "" && (j.startScope(E), j.addText(b), j.endScope());
    }
    function Xn(b, E) {
      let T = 1;
      const B = E.length - 1;
      for (; T <= B; ) {
        if (!b._emit[T]) {
          T++;
          continue;
        }
        const W = ce.classNameAliases[b[T]] || b[T], pe = E[T];
        W ? se(pe, W) : (z = pe, ne(), z = ""), T++;
      }
    }
    function Qn(b, E) {
      return b.scope && typeof b.scope == "string" && j.openNode(ce.classNameAliases[b.scope] || b.scope), b.beginScope && (b.beginScope._wrap ? (se(z, ce.classNameAliases[b.beginScope._wrap] || b.beginScope._wrap), z = "") : b.beginScope._multi && (Xn(b.beginScope, E), z = "")), S = Object.create(b, { parent: { value: S } }), S;
    }
    function et(b, E, T) {
      let B = jU(b.endRe, T);
      if (B) {
        if (b["on:end"]) {
          const W = new Ht(b);
          b["on:end"](E, W), W.isMatchIgnored && (B = !1);
        }
        if (B) {
          for (; b.endsParent && b.parent; )
            b = b.parent;
          return b;
        }
      }
      if (b.endsWithParent)
        return et(b.parent, E, T);
    }
    function Wr(b) {
      return S.matcher.regexIndex === 0 ? (z += b[0], 1) : (_n = !0, 0);
    }
    function Kr(b) {
      const E = b[0], T = b.rule, B = new Ht(T), W = [T.__beforeBegin, T["on:begin"]];
      for (const pe of W)
        if (pe && (pe(b, B), B.isMatchIgnored))
          return Wr(E);
      return T.skip ? z += E : (T.excludeBegin && (z += E), Y(), !T.returnBegin && !T.excludeBegin && (z = E)), Qn(T, b), T.returnBegin ? 0 : E.length;
    }
    function Jr(b) {
      const E = b[0], T = x.substring(b.index), B = et(S, b, T);
      if (!B)
        return Yt;
      const W = S;
      S.endScope && S.endScope._wrap ? (Y(), se(E, S.endScope._wrap)) : S.endScope && S.endScope._multi ? (Y(), Xn(S.endScope, b)) : W.skip ? z += E : (W.returnEnd || W.excludeEnd || (z += E), Y(), W.excludeEnd && (z = E));
      do
        S.scope && j.closeNode(), !S.skip && !S.subLanguage && (je += S.relevance), S = S.parent;
      while (S !== B.parent);
      return B.starts && Qn(B.starts, b), W.returnEnd ? 0 : E.length;
    }
    function Yr() {
      const b = [];
      for (let E = S; E !== ce; E = E.parent)
        E.scope && b.unshift(E.scope);
      b.forEach((E) => j.openNode(E));
    }
    let He = {};
    function nt(b, E) {
      const T = E && E[0];
      if (z += b, T == null)
        return Y(), 0;
      if (He.type === "begin" && E.type === "end" && He.index === E.index && T === "") {
        if (z += x.slice(E.index, E.index + 1), !o) {
          const B = new Error(`0 width match regex (${d})`);
          throw B.languageName = d, B.badRule = He.rule, B;
        }
        return 1;
      }
      if (He = E, E.type === "begin")
        return Kr(E);
      if (E.type === "illegal" && !D) {
        const B = new Error('Illegal lexeme "' + T + '" for mode "' + (S.scope || "<unnamed>") + '"');
        throw B.mode = S, B;
      } else if (E.type === "end") {
        const B = Jr(E);
        if (B !== Yt)
          return B;
      }
      if (E.type === "illegal" && T === "")
        return 1;
      if (mn > 1e5 && mn > E.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return z += T, T.length;
    }
    const ce = H(d);
    if (!ce)
      throw ke(s.replace("{}", d)), new Error('Unknown language: "' + d + '"');
    const Xr = C8(ce);
    let gn = "", S = L || Xr;
    const tt = {}, j = new i.__emitter(i);
    Yr();
    let z = "", je = 0, de = 0, mn = 0, _n = !1;
    try {
      if (ce.__emitTokens)
        ce.__emitTokens(x, j);
      else {
        for (S.matcher.considerAll(); ; ) {
          mn++, _n ? _n = !1 : S.matcher.considerAll(), S.matcher.lastIndex = de;
          const b = S.matcher.exec(x);
          if (!b)
            break;
          const E = x.substring(de, b.index), T = nt(E, b);
          de = b.index + T;
        }
        nt(x.substring(de));
      }
      return j.finalize(), gn = j.toHTML(), {
        language: d,
        value: gn,
        relevance: je,
        illegal: !1,
        _emitter: j,
        _top: S
      };
    } catch (b) {
      if (b.message && b.message.includes("Illegal"))
        return {
          language: d,
          value: Nn(x),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: b.message,
            index: de,
            context: x.slice(de - 100, de + 100),
            mode: b.mode,
            resultSoFar: gn
          },
          _emitter: j
        };
      if (o)
        return {
          language: d,
          value: Nn(x),
          illegal: !1,
          relevance: 0,
          errorRaised: b,
          _emitter: j,
          _top: S
        };
      throw b;
    }
  }
  function f(d) {
    const x = {
      value: Nn(d),
      illegal: !1,
      relevance: 0,
      _top: c,
      _emitter: new i.__emitter(i)
    };
    return x._emitter.addText(d), x;
  }
  function h(d, x) {
    x = x || i.languages || Object.keys(e);
    const D = f(d), L = x.filter(H).filter(P).map(
      (Y) => p(Y, d, !1)
    );
    L.unshift(D);
    const U = L.sort((Y, se) => {
      if (Y.relevance !== se.relevance)
        return se.relevance - Y.relevance;
      if (Y.language && se.language) {
        if (H(Y.language).supersetOf === se.language)
          return 1;
        if (H(se.language).supersetOf === Y.language)
          return -1;
      }
      return 0;
    }), [K, ne] = U, Ge = K;
    return Ge.secondBest = ne, Ge;
  }
  function k(d, x, D) {
    const L = x && t[x] || D;
    d.classList.add("hljs"), d.classList.add(`language-${L}`);
  }
  function v(d) {
    let x = null;
    const D = l(d);
    if (a(D))
      return;
    if (O(
      "before:highlightElement",
      { el: d, language: D }
    ), d.children.length > 0 && (i.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(d)), i.throwUnescapedHTML))
      throw new q8(
        "One of your code blocks includes unescaped HTML.",
        d.innerHTML
      );
    x = d;
    const L = x.textContent, U = D ? u(L, { language: D, ignoreIllegals: !0 }) : h(L);
    d.innerHTML = U.value, k(d, D, U.language), d.result = {
      language: U.language,
      // TODO: remove with version 11.0
      re: U.relevance,
      relevance: U.relevance
    }, U.secondBest && (d.secondBest = {
      language: U.secondBest.language,
      relevance: U.secondBest.relevance
    }), O("after:highlightElement", { el: d, result: U, text: L });
  }
  function A(d) {
    i = Jt(i, d);
  }
  const y = () => {
    C(), Ae("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function g() {
    C(), Ae("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let w = !1;
  function C() {
    if (document.readyState === "loading") {
      w = !0;
      return;
    }
    document.querySelectorAll(i.cssSelector).forEach(v);
  }
  function q() {
    w && C();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", q, !1);
  function _(d, x) {
    let D = null;
    try {
      D = x(n);
    } catch (L) {
      if (ke("Language definition for '{}' could not be registered.".replace("{}", d)), o)
        ke(L);
      else
        throw L;
      D = c;
    }
    D.name || (D.name = d), e[d] = D, D.rawDefinition = x.bind(null, n), D.aliases && R(D.aliases, { languageName: d });
  }
  function M(d) {
    delete e[d];
    for (const x of Object.keys(t))
      t[x] === d && delete t[x];
  }
  function $() {
    return Object.keys(e);
  }
  function H(d) {
    return d = (d || "").toLowerCase(), e[d] || e[t[d]];
  }
  function R(d, { languageName: x }) {
    typeof d == "string" && (d = [d]), d.forEach((D) => {
      t[D.toLowerCase()] = x;
    });
  }
  function P(d) {
    const x = H(d);
    return x && !x.disableAutodetect;
  }
  function fe(d) {
    d["before:highlightBlock"] && !d["before:highlightElement"] && (d["before:highlightElement"] = (x) => {
      d["before:highlightBlock"](
        Object.assign({ block: x.el }, x)
      );
    }), d["after:highlightBlock"] && !d["after:highlightElement"] && (d["after:highlightElement"] = (x) => {
      d["after:highlightBlock"](
        Object.assign({ block: x.el }, x)
      );
    });
  }
  function oe(d) {
    fe(d), r.push(d);
  }
  function m(d) {
    const x = r.indexOf(d);
    x !== -1 && r.splice(x, 1);
  }
  function O(d, x) {
    const D = d;
    r.forEach(function(L) {
      L[D] && L[D](x);
    });
  }
  function N(d) {
    return Ae("10.7.0", "highlightBlock will be removed entirely in v12.0"), Ae("10.7.0", "Please use highlightElement now."), v(d);
  }
  Object.assign(n, {
    highlight: u,
    highlightAuto: h,
    highlightAll: C,
    highlightElement: v,
    // TODO: Remove with v12 API
    highlightBlock: N,
    configure: A,
    initHighlighting: y,
    initHighlightingOnLoad: g,
    registerLanguage: _,
    unregisterLanguage: M,
    listLanguages: $,
    getLanguage: H,
    registerAliases: R,
    autoDetection: P,
    inherit: Jt,
    addPlugin: oe,
    removePlugin: m
  }), n.debugMode = function() {
    o = !1;
  }, n.safeMode = function() {
    o = !0;
  }, n.versionString = D8, n.regex = {
    concat: we,
    lookahead: Rr,
    either: Kn,
    optional: GU,
    anyNumberOfTimes: VU
  };
  for (const d in Je)
    typeof Je[d] == "object" && qr(Je[d]);
  return Object.assign(n, Je), n;
}, De = zr({});
De.newInstance = () => zr({});
var R8 = De;
De.HighlightJS = De;
De.default = De;
const tn = /* @__PURE__ */ ir(R8), Fn = /* @__PURE__ */ te({
  __name: "Message",
  props: {
    message: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = n, { message: t } = ro(e), r = $e(() => ({
      "chat-message-from-user": t.value.sender === "user",
      "chat-message-from-bot": t.value.sender === "bot"
    })), o = {
      highlight(s, c) {
        if (c && tn.getLanguage(c))
          try {
            return tn.highlight(s, { language: c }).value;
          } catch {
          }
        return "";
      }
    };
    return (s, c) => (F(), G("div", {
      class: nr(["chat-message", r.value])
    }, [
      Le(s.$slots, "default", {}, () => [
        be(V(BU), {
          class: "chat-message-markdown",
          source: V(t).text,
          options: o
        }, null, 8, ["source"])
      ])
    ], 2));
  }
});
const N8 = /* @__PURE__ */ J("div", { class: "chat-message-typing-body" }, [
  /* @__PURE__ */ J("span", { class: "chat-message-typing-circle" }),
  /* @__PURE__ */ J("span", { class: "chat-message-typing-circle" }),
  /* @__PURE__ */ J("span", { class: "chat-message-typing-circle" })
], -1), M8 = /* @__PURE__ */ te({
  __name: "MessageTyping",
  props: {
    animation: {
      type: String,
      default: "bouncing"
    }
  },
  setup(n) {
    const e = n, t = {
      id: "typing",
      text: "",
      sender: "bot",
      createdAt: ""
    }, r = $e(() => ({
      // eslint-disable-next-line @typescript-eslint/naming-convention
      "chat-message-typing": !0,
      [`chat-message-typing-animation-${e.animation}`]: !0
    }));
    return (o, s) => (F(), X(V(Fn), {
      class: nr(r.value),
      message: t
    }, {
      default: ve(() => [
        N8
      ]),
      _: 1
    }, 8, ["class"]));
  }
});
const L8 = { class: "chat-messages-list" }, F8 = /* @__PURE__ */ te({
  __name: "MessagesList",
  props: {
    messages: {
      type: Array,
      required: !0
    }
  },
  setup(n) {
    const e = On(), { initialMessages: t, waitingForResponse: r } = e;
    return (o, s) => (F(), G("div", L8, [
      (F(!0), G(rt, null, ot(V(t), (c) => (F(), X(Fn, {
        key: c.id,
        message: c
      }, null, 8, ["message"]))), 128)),
      (F(!0), G(rt, null, ot(n.messages, (c) => (F(), X(Fn, {
        key: c.id,
        message: c
      }, null, 8, ["message"]))), 128)),
      V(r) ? (F(), X(M8, { key: 0 })) : Fe("", !0)
    ]));
  }
});
const I8 = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, O8 = /* @__PURE__ */ J("path", {
  fill: "currentColor",
  d: "m2 21l21-9L2 3v7l15 2l-15 2v7Z"
}, null, -1), B8 = [
  O8
];
function P8(n, e) {
  return F(), G("svg", I8, B8);
}
const z8 = { name: "mdi-send", render: P8 }, $8 = { class: "chat-input" }, U8 = ["placeholder", "onKeydown"], V8 = ["disabled"], G8 = /* @__PURE__ */ te({
  __name: "Input",
  setup(n) {
    const e = On(), { waitingForResponse: t } = e, { t: r } = rn(), o = Ce(""), s = $e(() => o.value === "" || t.value);
    async function c(a) {
      if (a.preventDefault(), s.value)
        return;
      const l = o.value;
      o.value = "", await e.sendMessage(l);
    }
    async function i(a) {
      a.shiftKey || await c(a);
    }
    return (a, l) => (F(), G("div", $8, [
      tr(J("textarea", {
        "onUpdate:modelValue": l[0] || (l[0] = (u) => o.value = u),
        rows: "1",
        placeholder: V(r)("inputPlaceholder"),
        onKeydown: oo(i, ["enter"])
      }, null, 40, U8), [
        [so, o.value]
      ]),
      J("button", {
        disabled: s.value,
        class: "chat-input-send-button",
        onClick: c
      }, [
        be(V(z8), {
          height: "32",
          width: "32"
        })
      ], 8, V8)
    ]));
  }
});
const $r = /* @__PURE__ */ te({
  __name: "Chat",
  setup(n) {
    const { t: e } = rn(), t = On(), { messages: r, currentSessionId: o } = t;
    async function s() {
      await t.loadPreviousSession(), Oe(() => {
        xe.emit("scrollToBottom");
      });
    }
    async function c() {
      t.startNewSession(), Oe(() => {
        xe.emit("scrollToBottom");
      });
    }
    return In(() => {
      s();
    }), (i, a) => (F(), X(vo, { class: "chat-wrapper" }, co({
      footer: ve(() => [
        V(o) ? (F(), X(G8, { key: 0 })) : (F(), X(Ro, { key: 1 }))
      ]),
      default: ve(() => [
        V(o) ? (F(), X(F8, {
          key: 1,
          messages: V(r)
        }, null, 8, ["messages"])) : (F(), X(wo, {
          key: 0,
          "onClick:button": c
        }))
      ]),
      _: 2
    }, [
      V(o) ? void 0 : {
        name: "header",
        fn: ve(() => [
          J("h1", null, Xe(V(e)("title")), 1),
          J("p", null, Xe(V(e)("subtitle")), 1)
        ]),
        key: "0"
      }
    ]), 1024));
  }
}), H8 = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, j8 = /* @__PURE__ */ J("path", {
  fill: "currentColor",
  d: "M12 3c5.5 0 10 3.58 10 8s-4.5 8-10 8c-1.24 0-2.43-.18-3.53-.5C5.55 21 2 21 2 21c2.33-2.33 2.7-3.9 2.75-4.5C3.05 15.07 2 13.13 2 11c0-4.42 4.5-8 10-8Z"
}, null, -1), Z8 = [
  j8
];
function W8(n, e) {
  return F(), G("svg", H8, Z8);
}
const K8 = { name: "mdi-chat", render: W8 }, J8 = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Y8 = /* @__PURE__ */ J("path", {
  fill: "currentColor",
  d: "M7.41 8.58L12 13.17l4.59-4.59L18 10l-6 6l-6-6l1.41-1.42Z"
}, null, -1), X8 = [
  Y8
];
function Q8(n, e) {
  return F(), G("svg", J8, X8);
}
const e5 = { name: "mdi-chevron-down", render: Q8 }, n5 = { class: "chat-window-wrapper" }, t5 = { class: "chat-window" }, r5 = /* @__PURE__ */ te({
  __name: "ChatWindow",
  setup(n) {
    const e = Ce(!1);
    function t() {
      e.value = !e.value, e.value && Oe(() => {
        xe.emit("scrollToBottom");
      });
    }
    return (r, o) => (F(), G("div", n5, [
      be(st, { name: "chat-window-transition" }, {
        default: ve(() => [
          tr(J("div", t5, [
            be($r)
          ], 512), [
            [io, e.value]
          ])
        ]),
        _: 1
      }),
      J("div", {
        class: "chat-window-toggle",
        onClick: t
      }, [
        be(st, {
          name: "chat-window-toggle-transition",
          mode: "out-in"
        }, {
          default: ve(() => [
            e.value ? (F(), X(V(e5), {
              key: 1,
              height: "32",
              width: "32"
            })) : (F(), X(V(K8), {
              key: 0,
              height: "32",
              width: "32"
            }))
          ]),
          _: 1
        })
      ])
    ]));
  }
});
function o5(n) {
  const e = n.regex, t = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, o = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, s = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, c = n.inherit(s, {
    begin: /\(/,
    end: /\)/
  }), i = n.inherit(n.APOS_STRING_MODE, { className: "string" }), a = n.inherit(n.QUOTE_STRING_MODE, { className: "string" }), l = {
    endsWithParent: !0,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: r,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: !0,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [o]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [o]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          s,
          a,
          i,
          c,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  s,
                  c,
                  a,
                  i
                ]
              }
            ]
          }
        ]
      },
      n.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      o,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              a
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [l],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [l],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: e.concat(
          /</,
          e.lookahead(e.concat(
            t,
            // <tag/>
            // <tag>
            // <tag ...
            e.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: t,
            relevance: 0,
            starts: l
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: e.concat(
          /<\//,
          e.lookahead(e.concat(
            t,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: t,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: !0
          }
        ]
      }
    ]
  };
}
const Xt = "[A-Za-z$_][0-9A-Za-z$_]*", s5 = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], c5 = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], Ur = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], Vr = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], Gr = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], i5 = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], a5 = [].concat(
  Gr,
  Ur,
  Vr
);
function l5(n) {
  const e = n.regex, t = (x, { after: D }) => {
    const L = "</" + x[0].slice(1);
    return x.input.indexOf(L, D) !== -1;
  }, r = Xt, o = {
    begin: "<>",
    end: "</>"
  }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, c = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (x, D) => {
      const L = x[0].length + x.index, U = x.input[L];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        U === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        U === ","
      ) {
        D.ignoreMatch();
        return;
      }
      U === ">" && (t(x, { after: L }) || D.ignoreMatch());
      let K;
      const ne = x.input.substring(L);
      if (K = ne.match(/^\s*=/)) {
        D.ignoreMatch();
        return;
      }
      if ((K = ne.match(/^\s+extends\s+/)) && K.index === 0) {
        D.ignoreMatch();
        return;
      }
    }
  }, i = {
    $pattern: Xt,
    keyword: s5,
    literal: c5,
    built_in: a5,
    "variable.language": i5
  }, a = "[0-9](_?[0-9])*", l = `\\.(${a})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", p = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${l})|\\.)?|(${l}))[eE][+-]?(${a})\\b` },
      { begin: `\\b(${u})\\b((${l})\\b|\\.)?|(${l})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: i,
    contains: []
    // defined later
  }, h = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, k = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, v = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, A = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      n.BACKSLASH_ESCAPE,
      f
    ]
  }, g = {
    className: "comment",
    variants: [
      n.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      n.C_BLOCK_COMMENT_MODE,
      n.C_LINE_COMMENT_MODE
    ]
  }, w = [
    n.APOS_STRING_MODE,
    n.QUOTE_STRING_MODE,
    h,
    k,
    v,
    A,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    p
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = w.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: i,
    contains: [
      "self"
    ].concat(w)
  });
  const C = [].concat(g, f.contains), q = C.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: i,
      contains: ["self"].concat(C)
    }
  ]), _ = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: i,
    contains: q
  }, M = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, $ = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...Ur,
        ...Vr
      ]
    }
  }, H = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, R = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [_],
    illegal: /%/
  }, P = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function fe(x) {
    return e.concat("(?!", x.join("|"), ")");
  }
  const oe = {
    match: e.concat(
      /\b/,
      fe([
        ...Gr,
        "super",
        "import"
      ]),
      r,
      e.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, m = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, O = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      _
    ]
  }, N = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n.UNDERSCORE_IDENT_RE + ")\\s*=>", d = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(N)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      _
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: i,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: q, CLASS_REFERENCE: $ },
    illegal: /#(?![$_A-z])/,
    contains: [
      n.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      H,
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE,
      h,
      k,
      v,
      A,
      g,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      p,
      $,
      {
        className: "attr",
        begin: r + e.lookahead(":"),
        relevance: 0
      },
      d,
      {
        // "value" container
        begin: "(" + n.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          g,
          n.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: N,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: n.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: i,
                    contains: q
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: o.begin, end: o.end },
              { match: s },
              {
                begin: c.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": c.isTrulyOpeningTag,
                end: c.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: c.begin,
                end: c.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      R,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + n.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          _,
          n.inherit(n.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      m,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [_]
      },
      oe,
      P,
      M,
      O,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
const u5 = /* @__PURE__ */ te({
  __name: "App",
  props: {},
  setup(n) {
    const { options: e } = cr(), t = $e(() => e.mode === "fullscreen");
    return In(() => {
      tn.registerLanguage("xml", o5), tn.registerLanguage("javascript", l5);
    }), (r, o) => t.value ? (F(), X(V($r), {
      key: 0,
      class: "n8n-chat"
    })) : (F(), X(V(r5), {
      key: 1,
      class: "n8n-chat"
    }));
  }
});
var Ye, f5 = new Uint8Array(16);
function p5() {
  if (!Ye && (Ye = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !Ye))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Ye(f5);
}
const h5 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function d5(n) {
  return typeof n == "string" && h5.test(n);
}
var Z = [];
for (var Mn = 0; Mn < 256; ++Mn)
  Z.push((Mn + 256).toString(16).substr(1));
function g5(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = (Z[n[e + 0]] + Z[n[e + 1]] + Z[n[e + 2]] + Z[n[e + 3]] + "-" + Z[n[e + 4]] + Z[n[e + 5]] + "-" + Z[n[e + 6]] + Z[n[e + 7]] + "-" + Z[n[e + 8]] + Z[n[e + 9]] + "-" + Z[n[e + 10]] + Z[n[e + 11]] + Z[n[e + 12]] + Z[n[e + 13]] + Z[n[e + 14]] + Z[n[e + 15]]).toLowerCase();
  if (!d5(t))
    throw TypeError("Stringified UUID is invalid");
  return t;
}
function Me(n, e, t) {
  n = n || {};
  var r = n.random || (n.rng || p5)();
  if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, e) {
    t = t || 0;
    for (var o = 0; o < 16; ++o)
      e[t + o] = r[o];
    return e;
  }
  return g5(r);
}
async function m5() {
  return "";
}
async function Hr(...n) {
  var r;
  const e = await m5();
  return await (await fetch(n[0], {
    ...n[1],
    mode: "cors",
    cache: "no-cache",
    headers: {
      ...e ? { authorization: `Bearer ${e}` } : {},
      ...(r = n[1]) == null ? void 0 : r.headers
    }
  })).json();
}
async function jr(n, e = {}, t = {}) {
  let r = n;
  return Object.keys(e).length > 0 && (r = `${r}?${new URLSearchParams(e).toString()}`), Hr(r, { ...t, method: "GET" });
}
async function Zr(n, e = {}, t = {}) {
  return Hr(n, {
    ...t,
    method: "POST",
    body: JSON.stringify(e)
  });
}
async function _5(n, e) {
  var r, o;
  return (((r = e.webhookConfig) == null ? void 0 : r.method) === "POST" ? Zr : jr)(
    `${e.webhookUrl}`,
    {
      action: "loadPreviousSession",
      sessionId: n
    },
    {
      headers: (o = e.webhookConfig) == null ? void 0 : o.headers
    }
  );
}
async function b5(n, e, t) {
  var o, s;
  return (((o = t.webhookConfig) == null ? void 0 : o.method) === "POST" ? Zr : jr)(
    `${t.webhookUrl}`,
    {
      action: "sendMessage",
      sessionId: e,
      message: n
    },
    {
      headers: (s = t.webhookConfig) == null ? void 0 : s.headers
    }
  );
}
const v5 = {
  install(n, e) {
    n.provide(sr, e);
    const t = Ce([]), r = Ce(null), o = Ce(!1), s = $e(
      () => (e.initialMessages ?? []).map((l) => ({
        id: Me(),
        text: l,
        sender: "bot",
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      }))
    );
    async function c(l) {
      const u = {
        id: Me(),
        text: l,
        sender: "user",
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      t.value.push(u), o.value = !0, Oe(() => {
        xe.emit("scrollToBottom");
      });
      const p = await b5(
        l,
        r.value,
        e
      ), f = {
        id: Me(),
        text: p.output,
        sender: "bot",
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      t.value.push(f), o.value = !1, Oe(() => {
        xe.emit("scrollToBottom");
      });
    }
    async function i() {
      const l = localStorage.getItem(ct) ?? Me(), u = await _5(l, e), p = (/* @__PURE__ */ new Date()).toISOString();
      return t.value = ((u == null ? void 0 : u.data) || []).map((f, h) => ({
        id: `${h}`,
        text: f.kwargs.content,
        sender: f.id.includes("HumanMessage") ? "user" : "bot",
        createdAt: p
      })), t.value.length && (r.value = l), l;
    }
    async function a() {
      r.value = Me(), localStorage.setItem(ct, r.value);
    }
    n.provide(or, {
      initialMessages: s,
      messages: t,
      currentSessionId: r,
      waitingForResponse: o,
      loadPreviousSession: i,
      startNewSession: a,
      sendMessage: c
    });
  }
};
function x5(n) {
  var o, s;
  const e = {
    ...Ne,
    ...n,
    webhookConfig: {
      ...Ne.webhookConfig,
      ...n == null ? void 0 : n.webhookConfig
    },
    i18n: {
      ...Ne.i18n,
      ...n == null ? void 0 : n.i18n,
      en: {
        ...(o = Ne.i18n) == null ? void 0 : o.en,
        ...(s = n == null ? void 0 : n.i18n) == null ? void 0 : s.en
      }
    },
    theme: {
      ...Ne.theme,
      ...n == null ? void 0 : n.theme
    }
  }, t = e.target ?? ko;
  typeof t == "string" && go(t);
  const r = ao(u5);
  return r.use(v5, e), r.mount(t), r;
}
export {
  x5 as createChat
};
